/* eslint-env browser */
/* exported VulnerabilityDataManager */

/**
 * @fileoverview
 * Vulnerability Data Management Module
 * Extracted from ModernVulnManager as part of JavaScript modularization effort.
 * 
 * This module provides:
 * - API data fetching and caching
 * - Device data processing and aggregation
 * - Data filtering and search functionality
 * - CVE grouping and vulnerability organization
 * - Statistics loading and management
 * 
 * @version 1.0.0
 * @author HexTrackr Team
 * @date 2025-09-05
 */

/**
 * VulnerabilityDataManager - Centralized data management for vulnerability system
 * 
 * Usage:
 * ```javascript
 * const dataManager = new VulnerabilityDataManager('/api');
 * await dataManager.loadData();
 * const filteredData = dataManager.filterData('searchTerm', 'Critical');
 * ```
 */
class VulnerabilityDataManager {
    constructor(apiBase = "/api") {
        this.apiBase = apiBase;
        this.vulnerabilities = [];
        this.filteredVulnerabilities = [];
        this.devices = [];
        this.historicalData = [];
        this.statistics = {};
        this.trends = {};
        this.uniqueAssets = new Set();
        
        // Event listeners for data updates
        this.listeners = new Map();
    }

    /**
     * Load vulnerability data from API endpoints
     * @returns {Promise<void>}
     */
    async loadData() {
        try {
            // Load current vulnerabilities
            const response = await fetch(`${this.apiBase}/vulnerabilities?limit=10000`);
            if (response.ok) {
                const result = await response.json();
                this.vulnerabilities = result.data || [];
            } else {
                this.vulnerabilities = [];
            }
            
            // Load historical trend data
            const trendsResponse = await fetch(`${this.apiBase}/vulnerabilities/trends`);
            if (trendsResponse.ok) {
                this.historicalData = await trendsResponse.json();
            } else {
                this.historicalData = [];
            }
            
            // Process the loaded data
            this.processDevices();
            await this.loadStatistics();
            this.filterData();
            
            // Notify listeners of data update
            this.emit("dataLoaded", {
                vulnerabilities: this.vulnerabilities,
                devices: this.devices,
                historicalData: this.historicalData,
                statistics: this.statistics
            });
            
        } catch (error) {
            console.error("Error loading vulnerability data:", error);
            this.emit("error", { message: "Error loading data from database", error });
            throw error;
        }
    }

    /**
     * Process vulnerability data to create device aggregations
     */
    processDevices() {
        const deviceMap = new Map();
        
        this.vulnerabilities.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    vulnerabilities: [],
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalCount: 0,
                    totalVPR: 0
                });
            }
            
            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;
            
            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;
            
            switch (vuln.severity) {
                case "Critical": 
                    device.criticalCount++; 
                    device.criticalVPR += vprScore;
                    break;
                case "High": 
                    device.highCount++; 
                    device.highVPR += vprScore;
                    break;
                case "Medium": 
                    device.mediumCount++; 
                    device.mediumVPR += vprScore;
                    break;
                case "Low": 
                    device.lowCount++; 
                    device.lowVPR += vprScore;
                    break;
            }
        });
        
        this.devices = Array.from(deviceMap.values());
        this.uniqueAssets = new Set(this.devices.map(d => d.hostname));
        
        // Notify listeners of device processing completion
        this.emit("devicesProcessed", { devices: this.devices });
    }

    /**
     * Load statistics and trend data from API
     * @returns {Promise<void>}
     */
    async loadStatistics() {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/recent-trends`);
            if (response.ok) {
                const trends = await response.json();
                this.statistics = {};
                this.trends = trends;
                
                Object.keys(trends).forEach(severity => {
                    this.statistics[severity.toLowerCase()] = {
                        count: trends[severity].current.count,
                        total_vpr: trends[severity].current.total_vpr,
                        avg_vpr: trends[severity].current.total_vpr / trends[severity].current.count || 0
                    };
                });
                
                // Notify listeners of statistics update
                this.emit("statisticsLoaded", { 
                    statistics: this.statistics, 
                    trends: this.trends 
                });
                
            }
        } catch (error) {
            console.error("Error loading statistics:", error);
            this.emit("error", { message: "Error loading statistics", error });
        }
    }

    /**
     * Filter vulnerability data based on search term and severity
     * @param {string} searchTerm - Search term for hostname, CVE, or plugin name
     * @param {string} severityFilter - Severity level filter
     * @returns {Array} Filtered vulnerabilities
     */
    filterData(searchTerm = null, severityFilter = null) {
        // Get current filter values from DOM if not provided
        const currentSearchTerm = searchTerm ?? 
            (document.getElementById("searchInput")?.value.toLowerCase() || "");
        const currentSeverityFilter = severityFilter ?? 
            (document.getElementById("severityFilter")?.value || "");

        this.filteredVulnerabilities = this.vulnerabilities.filter(vuln => {
            const matchesSearch = !currentSearchTerm || 
                vuln.hostname.toLowerCase().includes(currentSearchTerm) ||
                vuln.cve.toLowerCase().includes(currentSearchTerm) ||
                vuln.plugin_name.toLowerCase().includes(currentSearchTerm);
            
            const matchesSeverity = !currentSeverityFilter || vuln.severity === currentSeverityFilter;
            
            return matchesSearch && matchesSeverity;
        });

        // Notify listeners of filter update
        this.emit("dataFiltered", { 
            filteredVulnerabilities: this.filteredVulnerabilities,
            searchTerm: currentSearchTerm,
            severityFilter: currentSeverityFilter
        });

        return this.filteredVulnerabilities;
    }

    /**
     * Group vulnerabilities by CVE for card view display
     * @returns {Object} Grouped vulnerabilities by CVE or plugin ID
     */
    groupVulnerabilitiesByCVE() {
        const grouped = {};
        this.filteredVulnerabilities.forEach(vuln => {
            const key = vuln.cve || `plugin_${vuln.plugin_id}`;
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(vuln);
        });
        return grouped;
    }

    /**
     * Get device by hostname
     * @param {string} hostname - Device hostname
     * @returns {Object|null} Device object or null if not found
     */
    getDeviceByHostname(hostname) {
        return this.devices.find(d => d.hostname === hostname) || null;
    }

    /**
     * Get vulnerability statistics
     * @returns {Object} Current statistics object
     */
    getStatistics() {
        return this.statistics;
    }

    /**
     * Get trend data
     * @returns {Object} Current trend data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Get historical data for charting
     * @returns {Array} Historical trend data
     */
    getHistoricalData() {
        return this.historicalData;
    }

    /**
     * Get all vulnerability data
     * @returns {Array} All vulnerabilities
     */
    getAllVulnerabilities() {
        return this.vulnerabilities;
    }

    /**
     * Get filtered vulnerability data
     * @returns {Array} Filtered vulnerabilities
     */
    getFilteredVulnerabilities() {
        return this.filteredVulnerabilities;
    }

    /**
     * Get all processed devices
     * @returns {Array} All device objects
     */
    getDevices() {
        return this.devices;
    }

    /**
     * Get unique asset count
     * @returns {number} Number of unique assets
     */
    getUniqueAssetCount() {
        return this.uniqueAssets.size;
    }

    /**
     * Refresh all data from API
     * @returns {Promise<void>}
     */
    async refreshData() {
        await this.loadData();
    }

    // Event system for communication with other modules
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} callback - Callback function
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} callback - Callback function to remove
     */
    off(event, callback) {
        if (this.listeners.has(event)) {
            const callbacks = this.listeners.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    /**
     * Emit event to all listeners
     * @param {string} event - Event name
     * @param {Object} data - Event data
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in event listener for ${event}:`, error);
                }
            });
        }
    }
}