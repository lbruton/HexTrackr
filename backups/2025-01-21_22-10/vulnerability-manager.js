 
// eslint-disable-file
/* eslint-env browser, es6 */
/* global bootstrap, agGrid, ApexCharts, Papa, Sortable, createVulnerabilityGridOptions, PaginationController, VulnerabilityDataManager, window, document, console, setTimeout, FormData, fetch, confirm, localStorage, Blob, URL, btoa, alert */
/* exported ModernVulnManager */
 

/**
 * @fileoverview
 * This file defines the ModernVulnManager class, the core of the HexTrackr
 * vulnerability management dashboard. It handles all client-side logic, including:
 * - Data fetching, processing, and caching from the backend API.
 * - Initialization and management of the AG Grid for tabular data display.
 * - Rendering and updating of the ApexCharts for historical trend visualization.
 * - User interactions such as searching, filtering, and view switching.
 * - Modal dialogs for device details, vulnerability information, and CSV imports.
 * - Data import/export functionality.
 *
 * @version 2.0.0
 * @author Gemini
 * @date 2025-09-03
 */

// Note: PaginationController extracted to scripts/shared/pagination-controller.js

// Modern Vulnerability Management System
class ModernVulnManager {
    constructor() {
        this.currentView = "table";
        this.gridApi = null;
        this.chart = null;
        this.currentMetricType = "count"; // Default to showing count percentages
        this.apiBase = "/api"; // Base URL for API endpoints
        
        // Initialize data manager
        this.dataManager = new VulnerabilityDataManager("/api");
        
        // Initialize pagination controllers
        this.devicePagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        this.vulnerabilityPagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        
        // Setup data manager event listeners
        this.setupDataManagerListeners();
        
        this.setupEventListeners();
        this.initializeGrid();
        this.initializeChart();
        this.loadData();
    }

    setupDataManagerListeners() {
        // Listen to data manager events
        this.dataManager.on("dataLoaded", (_data) => {
            this.updateChart();
            this.updateCurrentView();
        });

        this.dataManager.on("dataFiltered", (data) => {
            if (this.gridApi) {
                this.gridApi.setGridOption("rowData", data.filteredVulnerabilities);
            }
            this.updateCurrentView();
        });

        this.dataManager.on("statisticsLoaded", (_data) => {
            this.updateStatisticsDisplay();
        });

        this.dataManager.on("error", (data) => {
            this.showToast(data.message, "danger");
        });
    }

    setupEventListeners() {
        // Import CSV - Show date picker modal
        document.getElementById("importCsvBtn").addEventListener("click", () => {
            document.getElementById("csvFileInput").click();
        });

        document.getElementById("csvFileInput").addEventListener("change", (e) => {
            this.showScanDateModal(e);
        });

        // Confirm scan date and proceed with import
        document.getElementById("confirmScanDate").addEventListener("click", () => {
            this.proceedWithImport();
        });

        // Search and filters
        document.getElementById("searchInput").addEventListener("input", (_e) => {
            this.dataManager.filterData();
        });

        document.getElementById("severityFilter").addEventListener("change", (_e) => {
            this.dataManager.filterData();
        });

        // View switcher for Tabler.io button group
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const view = e.target.dataset.view || e.target.closest("[data-view]").dataset.view;
                if (view) {
                    this.switchView(view);
                }
            });
        });

        // Export button
        document.getElementById("exportBtn").addEventListener("click", () => {
            this.exportData();
        });

        // Refresh button - Check if exists before adding listener
        const refreshBtn = document.getElementById("refreshBtn");
        if (refreshBtn) {
            refreshBtn.addEventListener("click", () => {
                this.dataManager.refreshData();
            });
        }

        // Save vulnerability edit
        const saveVulnEdit = document.getElementById("saveVulnEdit");
        if (saveVulnEdit) {
            saveVulnEdit.addEventListener("click", () => {
                this.saveVulnerabilityChanges();
            });
        }

        // Device modal functionality is now handled by device-security-modal.js module
    }

    initializeGrid() {
        const gridOptions = createVulnerabilityGridOptions(this);
        const gridDiv = document.getElementById("vulnGrid");
        
        if (this.gridApi) {
            this.gridApi.destroy();
        }

        this.gridApi = agGrid.createGrid(gridDiv, gridOptions);
    }

    initializeChart() {
        const options = {
            series: [{
                name: "Critical",
                data: []
            }, {
                name: "High",
                data: []
            }, {
                name: "Medium",
                data: []
            }, {
                name: "Low",
                data: []
            }],
            chart: {
                height: 450,
                type: "line",
                background: "transparent",
                fontFamily: "Inter, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif",
                zoom: {
                    enabled: true,
                    type: "x",
                    autoScaleYaxis: true,
                    zoomedArea: {
                        fill: {
                            color: "#90CAF9",
                            opacity: 0.4
                        },
                        stroke: {
                            color: "#0D47A1",
                            opacity: 0.4,
                            width: 1
                        }
                    }
                },
                toolbar: {
                    show: true,
                    offsetX: 0,
                    offsetY: 0,
                    tools: {
                        download: true,
                        selection: true,
                        zoom: true,
                        zoomin: true,
                        zoomout: true,
                        pan: true,
                        reset: true
                    },
                    export: {
                        csv: {
                            filename: `vulnerability-trends-${new Date().toISOString().split("T")[0]}`
                        },
                        png: {
                            filename: `vulnerability-trends-${new Date().toISOString().split("T")[0]}`
                        }
                    }
                },
                animations: {
                    enabled: true,
                    easing: "easeinout",
                    speed: 800,
                    animateGradually: {
                        enabled: true,
                        delay: 150
                    },
                    dynamicAnimation: {
                        enabled: true,
                        speed: 350
                    }
                }
            },
            colors: ["#dc2626", "#ea580c", "#2563eb", "#16a34a"],
            stroke: {
                curve: "smooth",
                width: 3,
                lineCap: "round"
            },
            markers: {
                size: 0,
                strokeWidth: 2,
                strokeColors: "#ffffff",
                fillOpacity: 1,
                hover: {
                    size: 10,
                    sizeOffset: 3
                },
                discrete: []
            },
            dataLabels: {
                enabled: false
            },
            grid: {
                show: true,
                borderColor: "#f1f5f9",
                strokeDashArray: 3,
                position: "back",
                xaxis: {
                    lines: {
                        show: true
                    }
                },
                yaxis: {
                    lines: {
                        show: true
                    }
                },
                padding: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            },
            xaxis: {
                type: "datetime",
                labels: {
                    style: {
                        colors: "#64748b",
                        fontSize: "13px",
                        fontFamily: "Inter, sans-serif",
                        fontWeight: 500
                    },
                    datetimeUTC: false,
                    format: "MMM dd",
                    rotate: 0
                },
                axisBorder: {
                    show: true,
                    color: "#e2e8f0",
                    height: 1
                },
                axisTicks: {
                    show: true,
                    color: "#e2e8f0",
                    height: 4
                },
                tooltip: {
                    enabled: false
                }
            },
            yaxis: {
                labels: {
                    style: {
                        colors: "#64748b",
                        fontSize: "13px",
                        fontFamily: "Inter, sans-serif",
                        fontWeight: 500
                    },
                    formatter: function(value) {
                        return Math.round(value).toLocaleString();
                    }
                },
                axisBorder: {
                    show: true,
                    color: "#e2e8f0"
                },
                axisTicks: {
                    show: true,
                    color: "#e2e8f0"
                },
                title: {
                    text: "Vulnerability Count",
                    style: {
                        color: "#475569",
                        fontSize: "14px",
                        fontFamily: "Inter, sans-serif",
                        fontWeight: 600
                    }
                },
                min: 0
            },
            legend: {
                show: true,
                position: "top",
                horizontalAlign: "left",
                floating: false,
                fontSize: "14px",
                fontFamily: "Inter, sans-serif",
                fontWeight: 500,
                offsetY: 0,
                offsetX: 0,
                markers: {
                    width: 16,
                    height: 16,
                    strokeWidth: 0,
                    radius: 8
                },
                itemMargin: {
                    horizontal: 20,
                    vertical: 8
                },
                labels: {
                    colors: "#374151"
                }
            },
            tooltip: {
                enabled: true,
                shared: true,
                intersect: false,
                theme: "light",
                style: {
                    fontSize: "13px",
                    fontFamily: "Inter, sans-serif"
                },
                x: {
                    format: "MMM dd, yyyy"
                },
                filter: {
                    seriesIndex: 0,
                    type: "none"
                },
                custom: function({ series, seriesIndex: _seriesIndex, dataPointIndex, w: _w }) {
                    const vulnerabilityTracker = window.vulnerabilityTracker;
                    if (!vulnerabilityTracker || !vulnerabilityTracker.historicalData) {return "";}
                    
                    const extendedData = vulnerabilityTracker.extendTimelineData(vulnerabilityTracker.historicalData);
                    const dataPoint = extendedData[dataPointIndex];
                    
                    if (!dataPoint || !dataPoint.hasActualData) {
                        return "";
                    }
                    
                    const date = new Date(dataPoint.scan_date || dataPoint.date).toLocaleDateString("en-US", { 
                        weekday: "long",
                        month: "long", 
                        day: "numeric", 
                        year: "numeric" 
                    });
                    
                    const currentMetric = document.querySelector("input[name=\"chart-metric\"]:checked")?.nextElementSibling?.dataset?.metric || "count";
                    
                    let tooltipContent = `
                        <div class="apexcharts-tooltip-custom" style="
                            background: white;
                            border: 1px solid #e2e8f0;
                            border-radius: 12px;
                            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
                            padding: 16px;
                            font-family: Inter, sans-serif;
                            min-width: 280px;
                            max-width: 320px;
                        ">
                            <div style="
                                font-weight: 600;
                                font-size: 14px;
                                color: #1f2937;
                                margin-bottom: 12px;
                                padding-bottom: 8px;
                                border-bottom: 1px solid #f3f4f6;
                                text-align: center;
                            ">${date}</div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                    `;
                    
                    const seriesNames = ["Critical", "High", "Medium", "Low"];
                    const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
                    
                    series.forEach((seriesData, index) => {
                        const value = seriesData[dataPointIndex];
                        if (value !== undefined && value !== null) {
                            const metric = currentMetric === "vpr" ? " VPR" : "";
                            
                            tooltipContent += `
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: space-between;
                                    padding: 6px 0;
                                ">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <div style="
                                            width: 14px;
                                            height: 14px;
                                            border-radius: 50%;
                                            background-color: ${colors[index]};
                                            border: 2px solid white;
                                            box-shadow: 0 0 0 1px ${colors[index]}40;
                                        "></div>
                                        <span style="
                                            font-size: 13px;
                                            color: #4b5563;
                                            font-weight: 500;
                                        ">${seriesNames[index]}</span>
                                    </div>
                                    <span style="
                                        font-size: 14px;
                                        font-weight: 600;
                                        color: #1f2937;
                                    ">${value.toLocaleString()}${metric}</span>
                                </div>
                            `;
                        }
                    });
                    
                    tooltipContent += `
                            </div>
                            <div style="
                                margin-top: 12px;
                                padding-top: 8px;
                                border-top: 1px solid #f3f4f6;
                                font-size: 11px;
                                color: #6b7280;
                                text-align: center;
                            ">üìä Data from vulnerability scan</div>
                        </div>
                    `;
                    
                    return tooltipContent;
                }
            },
            title: {
                text: "Historical Vulnerability Trends",
                align: "left",
                style: {
                    fontSize: "20px",
                    fontWeight: "600",
                    color: "#1f2937",
                    fontFamily: "Inter, sans-serif"
                },
                offsetY: 20
            },
            subtitle: {
                text: "Showing data points only for actual vulnerability scans",
                align: "left",
                style: {
                    fontSize: "14px",
                    fontWeight: "400",
                    color: "#6b7280",
                    fontFamily: "Inter, sans-serif"
                },
                offsetY: 45
            },
            theme: {
                mode: "light",
                palette: "palette1"
            },
            responsive: [{
                breakpoint: 768,
                options: {
                    chart: {
                        height: 350
                    },
                    legend: {
                        position: "bottom",
                        offsetY: 10
                    },
                    title: {
                        style: {
                            fontSize: "18px"
                        }
                    }
                }
            }]
        };

        this.chart = new ApexCharts(document.getElementById("historicalChart"), options);
        this.chart.render();
        
        setTimeout(() => {
            const chartContainer = document.getElementById("historicalChart");
            if (chartContainer) {
                let _pinnedTooltip = null;
                let tooltipCloseTime = null;
                
                chartContainer.addEventListener("click", (_e) => {
                    const tooltip = document.querySelector(".apexcharts-tooltip.persistent-tooltip");
                    if (tooltip && tooltip.style.opacity !== "0") {
                        _pinnedTooltip = tooltip;
                        tooltip.style.border = "2px solid #3b82f6";
                        tooltip.style.boxShadow = "0 4px 12px rgba(59, 130, 246, 0.3)";
                        tooltip.setAttribute("data-pinned", "true");
                        
                        if (!tooltip.querySelector(".close-btn")) {
                            const closeBtn = document.createElement("div");
                            closeBtn.className = "close-btn";
                            closeBtn.innerHTML = "‚úï";
                            closeBtn.style.cssText = `
                                position: absolute; top: 4px; right: 8px; 
                                cursor: pointer; color: #6b7280; font-size: 14px; 
                                width: 16px; height: 16px; display: flex; 
                                align-items: center; justify-content: center;
                                border-radius: 50%; background: #f3f4f6;
                            `;
                            closeBtn.addEventListener("mouseenter", () => {
                                closeBtn.style.background = "#e5e7eb";
                            });
                            closeBtn.addEventListener("mouseleave", () => {
                                closeBtn.style.background = "#f3f4f6";
                            });
                            closeBtn.addEventListener("click", (e) => {
                                e.stopPropagation();
                                tooltip.style.opacity = "0";
                                tooltip.style.display = "none";
                                tooltipCloseTime = Date.now();
                                _pinnedTooltip = null;
                            });
                            tooltip.appendChild(closeBtn);
                        }
                    }
                });
                
                chartContainer.addEventListener("mouseover", (_e) => {
                    if (tooltipCloseTime && (Date.now() - tooltipCloseTime) > 500) {
                        const tooltip = document.querySelector(".apexcharts-tooltip");
                        if (tooltip && tooltip.style.opacity === "0") {
                            tooltip.style.opacity = "";
                            tooltip.style.display = "";
                            tooltip.style.border = "2px solid #e5e7eb";
                            tooltip.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
                            tooltip.removeAttribute("data-pinned");
                            
                            const closeBtn = tooltip.querySelector(".close-btn");
                            if (closeBtn) {closeBtn.remove();}
                            
                            tooltipCloseTime = null;
                        }
                    }
                });
            }
        }, 100);
    }

    showScanDateModal(event) {
        this.pendingFile = event.target.files[0];
        if (!this.pendingFile) {return;}

        const today = new Date().toISOString().split("T")[0];
        document.getElementById("scanDateInput").value = today;

        const modal = new bootstrap.Modal(document.getElementById("scanDateModal"));
        modal.show();
    }

    async proceedWithImport() {
        const scanDate = document.getElementById("scanDateInput").value;
        if (!scanDate) {
            this.showToast("Please select a scan date", "danger");
            return;
        }

        const modal = bootstrap.Modal.getInstance(document.getElementById("scanDateModal"));
        modal.hide();

        await this.handleCsvImportWithDate(this.pendingFile, scanDate);
        
        this.pendingFile = null;
        document.getElementById("csvFileInput").value = "";
    }

    async handleCsvImportWithDate(file, scanDate) {
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                return;
            }
        }

        this.showLoading("Uploading CSV file...");

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");
            formData.append("scanDate", scanDate);

            const response = await fetch(`${this.apiBase}/vulnerabilities/import`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            this.showLoading("Processing data...");
            const result = await response.json();

            this.showLoading("Refreshing charts and data...");
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await this.loadData();

            this.hideLoading();
            
            let message = `CSV import completed! Processed ${result.rowsProcessed.toLocaleString()} rows from ${result.filename} with scan date ${scanDate}.`;
            if (result.insertCount || result.updateCount || result.removedStale) {
                message += ` Added: ${result.insertCount || 0}, Updated: ${result.updateCount || 0}, Removed: ${result.removedStale || 0} stale items.`;
            }
            
            this.showToast(message, "success");

        } catch (error) {
            this.hideLoading();
            console.error("Error importing CSV:", error);
            this.showToast("Error importing CSV: " + error.message, "danger");
        }
    }

    async handleCsvImport(event) {
        const file = event.target.files[0];
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                event.target.value = "";
                return;
            }
        }

        this.showLoading("Uploading CSV file...");

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");

            const response = await fetch(`${this.apiBase}/vulnerabilities/import`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            this.showLoading("Processing data...");
            const result = await response.json();

            this.showLoading("Updating display...");
            await this.loadData();

            this.hideLoading();
            this.showToast(`CSV import completed! Imported ${result.rowsProcessed.toLocaleString()} vulnerabilities from ${result.filename}.`, "success");

            event.target.value = "";
        } catch (error) {
            this.hideLoading();
            console.error("Error importing CSV:", error);
            this.showToast("Error importing CSV: " + error.message, "danger");
            event.target.value = "";
        }
    }

    calculateSeverity(vprScore) {
        if (vprScore >= 9.0) {return "Critical";}
        if (vprScore >= 7.0) {return "High";}
        if (vprScore >= 4.0) {return "Medium";}
        return "Low";
    }

    async loadData() {
        await this.dataManager.loadData();
    }

    updateStatisticsDisplay() {
        const statistics = this.dataManager.getStatistics();
        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            const stat = statistics[severity];
            if (stat) {
                const countEl = document.getElementById(`${severity}Count`);
                const vprEl = document.getElementById(`${severity}VPR`);
                
                if (countEl) {
                    countEl.textContent = stat.count;
                }
                
                if (vprEl) {
                    vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
                }
                
                const totalVprEl = document.getElementById(`${severity}TotalVPR`);
                const avgVprEl = document.getElementById(`${severity}AvgVPR`);
                
                if (totalVprEl) {
                    totalVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (avgVprEl) {
                    const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                    avgVprEl.textContent = `${average} avg`;
                }
                
                const legacyCountEl = document.getElementById(`${severity}-count`);
                const legacyVprEl = document.getElementById(`${severity}-vpr`);
                
                if (legacyCountEl) {
                    legacyCountEl.textContent = stat.count;
                }
                
                if (legacyVprEl) {
                    legacyVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (this.trends && this.trends[severity]) {
                    const trendEl = document.getElementById(`${severity}Trend`);
                    if (trendEl) {
                        const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
                        const trendData = this.trends[severityKey] ? this.trends[severityKey].trend : null;
                        
                        if (trendData) {
                            const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
                            const current = this.currentMetricType === "vpr" ? this.trends[severityKey].current.total_vpr : this.trends[severityKey].current.count;
                            const previous = current - change;
                            const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";
                            
                            let percentage = 0;
                            if (previous !== 0) {
                                percentage = Math.abs((change / previous) * 100);
                            }
                            
                            const iconEl = trendEl.querySelector("i");
                            const badgeEl = trendEl.querySelector(".trend-value");
                            
                            if (iconEl && badgeEl) {
                                if (direction === "up") {
                                    iconEl.className = "ti ti-trending-up fs-3";
                                    badgeEl.textContent = `+${percentage.toFixed(1)}%`;
                                } else if (direction === "down") {
                                    iconEl.className = "ti ti-trending-down fs-3";
                                    badgeEl.textContent = `-${percentage.toFixed(1)}%`;
                                } else {
                                    iconEl.className = "ti ti-minus fs-3";
                                    badgeEl.textContent = "0%";
                                }
                            }
                        }
                    }
                }
            }
        });
        
        const totalVulns = Object.values(this.statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = this.statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }
    }

    updateTrendIndicators(_currentStats) {
        const historicalData = this.dataManager.getHistoricalData();
        if (historicalData && historicalData.length > 0) {
            const latest = historicalData[historicalData.length - 1];
            const previous = historicalData.length > 1 ? historicalData[historicalData.length - 2] : latest;
            
            const trends = {
                critical: this.calculateTrend(previous.critical_vpr || 0, latest.critical_vpr || 0),
                high: this.calculateTrend(previous.high_vpr || 0, latest.high_vpr || 0),
                medium: this.calculateTrend(previous.medium_vpr || 0, latest.medium_vpr || 0),
                low: this.calculateTrend(previous.low_vpr || 0, latest.low_vpr || 0)
            };
            
            Object.keys(trends).forEach(severity => {
                const element = document.getElementById(`${severity}Trend`);
                if (element) {
                    const trend = trends[severity];
                    element.className = `trend-indicator trend-${trend.direction}`;
                    element.innerHTML = `<i class="fas fa-arrow-${trend.direction === "up" ? "up" : "down"} me-1"></i>${trend.direction === "up" ? "+" : ""}${trend.percentage}%`;
                }
            });
        } else {
            const trends = {
                critical: Math.random() > 0.5 ? "up" : "down",
                high: Math.random() > 0.5 ? "up" : "down",
                medium: Math.random() > 0.5 ? "up" : "down",
                low: Math.random() > 0.5 ? "up" : "down"
            };

            Object.keys(trends).forEach(severity => {
                const element = document.getElementById(`${severity}Trend`);
                if (element) {
                    const isUp = trends[severity] === "up";
                    const percentage = Math.floor(Math.random() * 20) + 1;
                    
                    element.className = `trend-indicator trend-${trends[severity]}`;
                    element.innerHTML = `<i class="fas fa-arrow-${isUp ? "up" : "down"} me-1"></i>${isUp ? "+" : "-"}${percentage}%`;
                }
            });
        }
    }

    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }
        
        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }
        
        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    /**
     * Updates pagination information display with actual row counts
     * Called by AG Grid when pagination changes
     */
    updatePaginationInfo(totalRows, currentPage, pageSize) {
        // This method is called by the AG Grid pagination handler
        // to update any custom pagination displays with actual counts
        console.log(`Pagination updated: ${totalRows} total rows, page ${currentPage + 1}, ${pageSize} per page`);
        
        // The AG Grid handles the pagination display automatically
        // This method is here for future custom pagination implementations
    }

    flipStatCards() {
        const cards = document.querySelectorAll(".stat-card-enhanced");
        
        cards.forEach(card => {
            const cardFront = card.querySelector(".card-front");
            const cardBack = card.querySelector(".card-back");
            
            if (cardFront && cardBack) {
                if (cardFront.style.display !== "none") {
                    cardFront.style.display = "none";
                    cardBack.style.display = "block";
                    this.currentMetricType = "vpr";
                } else {
                    cardFront.style.display = "block";
                    cardBack.style.display = "none";
                    this.currentMetricType = "count";
                }
            }
        });
        
        this.updateStatisticsDisplay();
    }

    extendTimelineData(originalData) {
        if (!originalData || originalData.length === 0) {return [];}
        
        const sortedData = [...originalData].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        const earliestDate = new Date(sortedData[0].date);
        const latestDate = new Date(sortedData[sortedData.length - 1].date);
        const currentDate = new Date();
        
        const backwardExtensionDays = 14;
        const extendedStartDate = new Date(earliestDate);
        extendedStartDate.setDate(extendedStartDate.getDate() - backwardExtensionDays);
        
        const extendedData = [];
        
        const earliestValues = sortedData[0];
        let currentExtensionDate = new Date(extendedStartDate);
        
        while (currentExtensionDate < earliestDate) {
            extendedData.push({
                date: currentExtensionDate.toISOString().split("T")[0],
                Critical: earliestValues.Critical,
                High: earliestValues.High,
                Medium: earliestValues.Medium,
                Low: earliestValues.Low,
                isExtended: true,
                extensionType: "backward",
                hasActualData: false
            });
            currentExtensionDate.setDate(currentExtensionDate.getDate() + 1);
        }
        
        sortedData.forEach(dataPoint => {
            extendedData.push({
                ...dataPoint,
                isExtended: false,
                extensionType: "actual",
                hasActualData: true
            });
        });
        
        const latestValues = sortedData[sortedData.length - 1];
        currentExtensionDate = new Date(latestDate);
        currentExtensionDate.setDate(currentExtensionDate.getDate() + 1);
        
        while (currentExtensionDate <= currentDate) {
            extendedData.push({
                date: currentExtensionDate.toISOString().split("T")[0],
                Critical: latestValues.Critical,
                High: latestValues.High,
                Medium: latestValues.Medium,
                Low: latestValues.Low,
                isExtended: true,
                extensionType: "forward",
                hasActualData: false
            });
            currentExtensionDate.setDate(currentExtensionDate.getDate() + 1);
        }
        
        return extendedData;
    }

    updateChart() {
        if (!this.chart || this.dataManager.getHistoricalData().length === 0) {return;}

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        
        const extendedData = this.extendTimelineData(this.dataManager.getHistoricalData());
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date).getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        this.chart.updateSeries(series);

        setTimeout(() => {
            if (this.chart && this.chart.resetSeries) {
                this.chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        this.chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        this.chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date).toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        const color = colors[index];
                        const label = metricType === "vpr" ? `${value.toFixed(2)} VPR points` : `${value} vulnerabilities`;
                        
                        tooltipContent += `
                            <div class="tooltip-series">
                                <span style="color: ${color};">‚óè</span>
                                <span class="tooltip-severity">${severity}:</span>
                                <span class="tooltip-value">${label}</span>
                            </div>`;
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        if (this.dataManager.getHistoricalData().length > 0) {
            const actualDataPoints = extendedData.filter(point => point.hasActualData);
            if (actualDataPoints.length > 0) {
                const latestActualDate = new Date(actualDataPoints[actualDataPoints.length - 1].date);
                const fourteenDaysAgo = new Date(latestActualDate.getTime() - (14 * 24 * 60 * 60 * 1000));
                
                this.chart.zoomX(fourteenDaysAgo.getTime(), latestActualDate.getTime());
            }
        }
    }



    switchView(viewType) {
        const radioButton = document.getElementById(`view-${viewType}`);
        if (radioButton) {
            radioButton.checked = true;
        }

        document.querySelectorAll(".view-content").forEach(view => {
            view.classList.add("d-none");
        });

        document.getElementById(`${viewType}View`).classList.remove("d-none");
        
        this.currentView = viewType;
        this.updateCurrentView();
    }

    updateCurrentView() {
        switch (this.currentView) {
            case "table":
                if (this.gridApi) {
                    this.gridApi.setRowData(this.dataManager.getFilteredVulnerabilities());
                }
                break;
            case "devices":
                this.renderDeviceCards();
                break;
            case "vulnerabilities":
                this.renderVulnerabilityCards();
                break;
        }
    }

    renderDeviceCards() {
        const container = document.getElementById("deviceCards");
        const filteredDevices = this.dataManager.getDevices().filter(device => {
            const searchTerm = document.getElementById("searchInput").value.toLowerCase();
            return !searchTerm || device.hostname.toLowerCase().includes(searchTerm);
        });

        // Sort devices by total VPR score (high to low)
        filteredDevices.sort((a, b) => {
            const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
            const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
            return bTotalVPR - aTotalVPR;
        });

        // Update pagination with filtered count
        this.devicePagination.setTotalItems(filteredDevices.length);
        
        // Get current page data
        const paginatedDevices = this.devicePagination.getCurrentPageData(filteredDevices);

        container.innerHTML = paginatedDevices.map(device => {
            const criticalVPR = device.criticalVPR || 0;
            const highVPR = device.highVPR || 0;
            const mediumVPR = device.mediumVPR || 0;
            const lowVPR = device.lowVPR || 0;
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card device-card">
                    <div class="card-body">
                        <div class="device-hostname">
                            <i class="fas fa-server me-2 text-primary"></i>
                            ${device.hostname}
                        </div>
                        
                        <div class="device-stats">
                            <div>
                                <div class="text-muted small">Total Vulnerabilities</div>
                                <div class="fw-bold">${device.totalCount}</div>
                            </div>
                            <div class="text-end">
                                <div class="text-muted small">Total VPR</div>
                                <div class="device-total-vpr">${totalVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${device.criticalCount}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${device.highCount}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${device.mediumCount}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${device.lowCount}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="card-actions">
                            <button class="btn btn-primary" 
                                    onclick="vulnManager.viewDeviceDetails('${device.hostname}')">
                                <i class="fas fa-eye me-1"></i>View Device Details
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;}).join("");

        // Render pagination controls
        this.devicePagination.renderPaginationControls(
            "devicePaginationControls",
            () => this.renderDeviceCards(),
            () => this.renderDeviceCards()
        );

        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }

    renderVulnerabilityCards() {
        const container = document.getElementById("vulnerabilityCards");
        const groupedVulns = this.dataManager.groupVulnerabilitiesByCVE();
        
        // Sort vulnerability groups by total VPR score (high to low)
        const sortedVulnEntries = Object.entries(groupedVulns).sort(([,vulnsA], [,vulnsB]) => {
            const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            return totalVPRB - totalVPRA;
        });

        // Update pagination with total count
        this.vulnerabilityPagination.setTotalItems(sortedVulnEntries.length);
        
        // Get current page data
        const paginatedVulnEntries = this.vulnerabilityPagination.getCurrentPageData(sortedVulnEntries);

        container.innerHTML = paginatedVulnEntries.map(([cve, vulns]) => {
            const criticalVulns = vulns.filter(v => v.severity === "Critical");
            const highVulns = vulns.filter(v => v.severity === "High");
            const mediumVulns = vulns.filter(v => v.severity === "Medium");
            const lowVulns = vulns.filter(v => v.severity === "Low");
            
            const criticalVPR = criticalVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const highVPR = highVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const mediumVPR = mediumVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const lowVPR = lowVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            const primaryVuln = vulns[0];
            const description = primaryVuln.description || primaryVuln.plugin_name || "No description available";
            
            // Create a safe data attribute for the vulnerability data
            const vulnDataId = `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            // Store the vulnerability data temporarily for modal access
            window.vulnModalData = window.vulnModalData || {};
            window.vulnModalData[vulnDataId] = primaryVuln;

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card vulnerability-card" style="cursor: pointer;" data-vuln-id="${vulnDataId}" onclick="vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                    <div class="card-body">
                        <div class="vulnerability-title">
                            ${description.substring(0, 100)}${description.length > 100 ? "..." : ""}
                        </div>
                        
                        <div class="vulnerability-meta">
                            <div>
                                ${(() => {
                                    if (cve && cve.startsWith("CVE-")) {
                                        return `<a href="#" class="vulnerability-cve" 
                                                   onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${cve}');">
                                                    ${cve}
                                                </a>`;
                                    }
                                    
                                    // Check for Cisco SA ID in plugin name
                                    if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
                                        const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
                                        if (ciscoSaMatch) {
                                            const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                                            return `<a href="#" class="vulnerability-cve text-warning" 
                                                       onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${ciscoId}');">
                                                        ${ciscoId}
                                                    </a>`;
                                        }
                                    }
                                    
                                    return `<span class="text-muted">Plugin ${primaryVuln.plugin_id}</span>`;
                                })()}
                            </div>
                            <div class="text-end">
                                <div class="vulnerability-vpr text-primary">
                                    ${totalVPR.toFixed(1)}
                                </div>
                                <div class="text-muted small">Total VPR</div>
                            </div>
                        </div>

                        <div class="mb-3">
                            <span class="badge severity-${primaryVuln.severity.toLowerCase()}">
                                ${primaryVuln.severity}
                            </span>
                            <span class="text-muted ms-2">
                                <i class="fas fa-server me-1"></i>
                                ${vulns.length} device${vulns.length !== 1 ? "s" : ""}
                            </span>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${criticalVulns.length}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${highVulns.length}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${mediumVulns.length}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${lowVulns.length}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        ${(() => {
                            // Check if we have CVE
                            if (cve && cve.startsWith("CVE-")) {
                                return `<div class="card-actions">
                                            <button class="btn btn-outline-primary btn-sm w-100" 
                                                    onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${cve}')">
                                                <i class="fas fa-external-link-alt me-1"></i>Lookup Vulnerability Details
                                            </button>
                                        </div>`;
                            }
                            
                            // Check for Cisco SA ID in plugin name
                            if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
                                const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
                                if (ciscoSaMatch) {
                                    const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                                    return `<div class="card-actions">
                                                <button class="btn btn-outline-warning btn-sm w-100" 
                                                        onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${ciscoId}')">
                                                    <i class="fas fa-external-link-alt me-1"></i>Lookup Cisco Advisory
                                                </button>
                                            </div>`;
                                }
                            }
                            
                            // Default action for no external reference
                            return `<div class="card-actions">
                                        <button class="btn btn-outline-info btn-sm w-100" onclick="event.stopPropagation(); vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                                            <i class="fas fa-info-circle me-1"></i>Click for Details
                                        </button>
                                    </div>`;
                        })()}
                    </div>
                </div>
            </div>
        `;}).join("");

        // Render pagination controls
        this.vulnerabilityPagination.renderPaginationControls(
            "vulnerabilityPaginationControls",
            () => this.renderVulnerabilityCards(),
            () => this.renderVulnerabilityCards()
        );

        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }


    viewDeviceDetails(hostname) {
        // Delegate to the device security modal module
        if (window.deviceSecurityModal) {
            window.deviceSecurityModal.showDeviceDetails(hostname, this.dataManager);
        } else {
            console.error("Device security modal module not loaded");
            this.showToast("Device security modal module not available", "error");
        }
    }

        viewVulnerabilityDetails(vulnerabilityId) {
        // Handle both old direct object calls and new ID-based calls
        let vulnerability;
        if (typeof vulnerabilityId === "string") {
            // New approach: get vulnerability from temporary storage
            vulnerability = window.vulnModalData && window.vulnModalData[vulnerabilityId];
        } else {
            // Legacy approach: direct object passed
            vulnerability = vulnerabilityId;
        }
        
        if (!vulnerability) {
            console.error("Vulnerability data not found");
            return;
        }

        const vulnLink = this.getVulnerabilityLink(vulnerability);
        
        document.getElementById("vulnerabilityInfo").innerHTML = `
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Vulnerability ID:</div>
                    <div class="col-sm-8">
                        ${vulnLink.url ? 
                            `<a href="#" class="text-primary text-decoration-none fw-bold" 
                               onclick="vulnManager.lookupVulnerability('${vulnLink.id}')">${vulnLink.id}</a>` :
                            `<span class="fw-bold text-muted">${vulnLink.id}</span>`
                        }
                        ${vulnLink.type === "cisco" ? 
                            "<small class=\"text-warning ms-2\">(Cisco Advisory)</small>" : 
                            vulnLink.type === "plugin" ? 
                            "<small class=\"text-muted ms-2\">(Plugin ID)</small>" : ""
                        }
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Plugin Name:</div>
                    <div class="col-sm-8 fw-bold">${vulnerability.plugin_name || "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Description:</div>
                    <div class="col-sm-8">${vulnerability.description || vulnerability.plugin_name || "No description available"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Solution:</div>
                    <div class="col-sm-8">${vulnerability.solution || "No solution provided"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">First Seen:</div>
                    <div class="col-sm-8">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString() : "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Port:</div>
                    <div class="col-sm-8">
                        <span class="badge bg-secondary">${vulnerability.port || "N/A"}</span>
                    </div>
                </div>
            </div>
        `;

        const vprScore = vulnerability.vpr_score || 0;
        const severity = vulnerability.severity || "Low";
        const severityColor = severity === "Critical" ? "red" : 
                            severity === "High" ? "orange" : 
                            severity === "Medium" ? "yellow" : "green";
        
        document.getElementById("vulnerabilityRiskSummary").innerHTML = `
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-${vprScore >= 9 ? "red" : vprScore >= 7 ? "orange" : vprScore >= 4 ? "yellow" : "green"} h2 mb-1">${vprScore.toFixed(1)}</div>
                        <div class="text-muted small">VPR Score</div>
                        <div class="text-muted small mt-1">
                            ${vprScore >= 9 ? "Critical Risk" : vprScore >= 7 ? "High Risk" : vprScore >= 4 ? "Medium Risk" : "Low Risk"}
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-${severityColor} h3 mb-1">${severity}</div>
                        <div class="text-muted small">Severity</div>
                        <div class="text-muted small mt-1">CVSS Based</div>
                    </div>
                </div>
            </div>
        `;

        const affectedAssets = this.dataManager.getAllVulnerabilities().filter(v => v.cve === vulnerability.cve);
        document.getElementById("affectedAssetsCount").textContent = `${affectedAssets.length} assets`;

        const assetsGridDiv = document.getElementById("vulnerabilityAssetsGrid");
        assetsGridDiv.innerHTML = "";

        const assetsColumnDefs = [
            {
                headerName: "Hostname",
                field: "hostname",
                width: 200,
                cellRenderer: (params) => {
                    const hostname = params.value;
                    return `<a href="#" class="text-primary text-decoration-none fw-bold" onclick="vulnManager.viewDeviceDetails('${hostname}')">${hostname}</a>`;
                }
            },
            {
                headerName: "Port",
                field: "port",
                width: 100,
                cellRenderer: (params) => {
                    return `<span class="badge bg-secondary">${params.value || "N/A"}</span>`;
                }
            },
            {
                headerName: "First Seen",
                field: "first_seen",
                width: 150,
                cellRenderer: (params) => {
                    return params.value ? new Date(params.value).toLocaleDateString() : "N/A";
                }
            },
            {
                headerName: "Last Seen",
                field: "last_seen",
                width: 150,
                cellRenderer: (params) => {
                    const lastSeen = params.data.last_seen;
                    const scanDate = params.data.scan_date;
                    
                    if (lastSeen && lastSeen.trim() !== "") {
                        return new Date(lastSeen).toLocaleDateString();
                    } else if (scanDate && scanDate.trim() !== "") {
                        return new Date(scanDate).toLocaleDateString();
                    }
                    return "N/A";
                }
            },
            { headerName: "Plugin Output", field: "plugin_output", flex: 1 }
        ];

        const assetsGridOptions = {
            columnDefs: assetsColumnDefs,
            rowData: affectedAssets,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 15,
            animateRows: true
        };

        new agGrid.Grid(assetsGridDiv, assetsGridOptions);

        const modal = new bootstrap.Modal(document.getElementById("vulnerabilityModal"));
        modal.show();
    }

    // Extract Cisco vulnerability ID from plugin name
    extractCiscoVulnId(pluginName) {
        if (!pluginName || typeof pluginName !== "string") {
            return null;
        }
        
        // Look for cisco-sa- pattern in plugin name
        const ciscoSaMatch = pluginName.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
        if (ciscoSaMatch) {
            return `cisco-sa-${ciscoSaMatch[1]}`;
        }
        
        return null;
    }

    // Determine vulnerability ID type and create appropriate link
    getVulnerabilityLink(vulnData) {
        const { cve, plugin_name } = vulnData;
        
        // Check for CVE first
        if (cve && cve.startsWith("CVE-")) {
            return {
                id: cve,
                type: "cve",
                url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve.trim()}`
            };
        }
        
        // Check for Cisco SA ID in plugin name
        const ciscoId = this.extractCiscoVulnId(plugin_name);
        if (ciscoId) {
            return {
                id: ciscoId,
                type: "cisco",
                url: `https://www.cisco.com/c/en/us/support/docs/csa/${ciscoId}.html`
            };
        }
        
        // Fall back to plugin ID
        return {
            id: `Plugin ${vulnData.plugin_id}`,
            type: "plugin",
            url: null
        };
    }

    // Enhanced lookup method that handles different vulnerability ID types
    async lookupVulnerability(vulnId, pluginName = null) {
        // If CVE, use existing CVE lookup
        if (vulnId && vulnId.startsWith("CVE-")) {
            return this.lookupCVE(vulnId);
        }
        
        // If it looks like a Cisco SA ID, open Cisco advisory
        if (vulnId && vulnId.startsWith("cisco-sa-")) {
            const popup = window.open(
                `https://www.cisco.com/c/en/us/support/docs/csa/${vulnId}.html`,
                `Cisco_Advisory_${vulnId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            
            if (popup) {
                popup.focus();
                this.showToast(`Opened Cisco advisory for ${vulnId}`, "success");
            } else {
                this.showToast("Popup blocked - please allow popups for vulnerability lookups", "warning");
            }
            return;
        }
        
        // If we have plugin name, try to extract Cisco ID from it
        if (pluginName) {
            const ciscoId = this.extractCiscoVulnId(pluginName);
            if (ciscoId) {
                return this.lookupVulnerability(ciscoId);
            }
        }
        
        // Default fallback
        this.showToast("No external vulnerability reference available for this item", "info");
    }

    async lookupCVE(cveId) {
        const cveIds = cveId.includes(",") ? cveId.split(",").map(id => id.trim()) 
                                           : cveId.includes(" ") ? cveId.split(" ").filter(id => id.startsWith("CVE-"))
                                           : [cveId.trim()];

        const ciscoClientId = localStorage.getItem("cisco_client_id");
        const ciscoClientSecret = localStorage.getItem("cisco_client_secret");

        if (ciscoClientId && ciscoClientSecret && cveIds.length === 1) {
            await this.lookupCVEWithCiscoAPI(cveIds[0], ciscoClientId, ciscoClientSecret);
        } else {
            this.openCVEPopups(cveIds);
        }
    }

    async lookupCVEWithCiscoAPI(cveId, clientId, clientSecret) {
        try {
            this.showLoading(`Looking up ${cveId} via Cisco PSIRT...`);
            
            const tokenResponse = await fetch("https://id.cisco.com/oauth2/default/v1/token", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Authorization": "Basic " + btoa(`${clientId}:${clientSecret}`)
                },
                body: "grant_type=client_credentials"
            });

            if (tokenResponse.ok) {
                const tokenData = await tokenResponse.json();
                
                const psirtResponse = await fetch(`https://api.cisco.com/security/advisories/cve/${cveId}`, {
                    headers: {
                        "Authorization": `Bearer ${tokenData.access_token}`,
                        "Accept": "application/json"
                    }
                });

                this.hideLoading();

                if (psirtResponse.ok) {
                    const data = await psirtResponse.json();
                    this.displayCVEInfo(cveId, data);
                } else {
                    this.showToast(`No Cisco advisory found for ${cveId}. Opening external lookup...`, "warning");
                    this.openCVEPopups([cveId]);
                }
            } else {
                this.hideLoading();
                this.showToast("Failed to authenticate with Cisco API. Using external lookup...", "warning");
                this.openCVEPopups([cveId]);
            }
        } catch (_error) {
            this.hideLoading();
            this.showToast("Error with Cisco API. Using external lookup...", "warning");
            this.openCVEPopups([cveId]);
        }
    }

    openCVEPopups(cveIds) {
        if (!Array.isArray(cveIds) || cveIds.length === 0) {
            this.showToast("No valid CVE IDs found", "warning");
            return;
        }

        let successCount = 0;
        let blockedCount = 0;

        cveIds.forEach((cveId, index) => {
            if (!cveId.startsWith("CVE-")) {
                return;
            }

            setTimeout(() => {
                const popup = window.open(
                    `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId.trim()}`,
                    `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                    "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes,top=50,left=" + (100 + index * 50)
                );
                
                if (popup) {
                    popup.focus();
                    successCount++;
                } else {
                    blockedCount++;
                }

                if (index === cveIds.length - 1) {
                    setTimeout(() => {
                        if (blockedCount > 0) {
                            this.showToast(`${successCount} CVE lookup(s) opened. ${blockedCount} popup(s) blocked. Please allow popups for full CVE lookups.`, "warning");
                        } else if (successCount > 0) {
                            this.showToast(`${successCount} CVE lookup(s) opened successfully`, "success");
                        }
                    }, 100);
                }
            }, index * 200);
        });
    }

    displayCVEInfo(cveId, data) {
        let message = `CVE Information for ${cveId}:\n\n`;
        if (data.advisories && data.advisories.length > 0) {
            const advisory = data.advisories[0];
            message += `Title: ${advisory.advisoryTitle}\n`;
            message += `Severity: ${advisory.sir}\n`;
            message += `CVSSv3 Score: ${advisory.cvssBaseScore}\n`;
            message += `Publication Date: ${advisory.publicationUrl}\n`;
        }
        alert(message);
    }

    exportData() {
        const dataToExport = this.dataManager.getFilteredVulnerabilities();
        const csv = Papa.unparse(dataToExport);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Data exported successfully!", "success");
    }

    async refreshData() {
        this.showLoading("Refreshing data...");
        await new Promise(resolve => setTimeout(resolve, 1000));
        await this.loadData();
        this.hideLoading();
        this.showToast("Data refreshed successfully!", "success");
    }

    async fetchTenableHistoricalData() {
        const tenableApiKey = localStorage.getItem("tenable_api_key");
        const tenableSecretKey = localStorage.getItem("tenable_secret_key");
        
        if (!tenableApiKey || !tenableSecretKey) {
            this.showToast("Tenable API credentials not configured", "warning");
            return;
        }
        
        try {
            this.showLoading("Fetching historical VPR data from Tenable...");
            
            const response = await fetch(`${this.apiBase}/tenable/historical-vpr`, {
                headers: {
                    "X-Tenable-Api-Key": tenableApiKey,
                    "X-Tenable-Secret-Key": tenableSecretKey
                }
            });
            
            this.hideLoading();
            
            if (response.ok) {
                const data = await response.json();
                this.showToast(`Fetched ${data.count} historical VPR records`, "success");
                
                await this.loadData();
            } else {
                const error = await response.json();
                this.showToast("Failed to fetch Tenable data: " + error.error, "danger");
            }
        } catch (error) {
            this.hideLoading();
            this.showToast("Error fetching Tenable data: " + error.message, "danger");
        }
    }

    showClearDataConfirmation() {
        if (confirm("Are you sure you want to clear all vulnerability data? This action cannot be undone.")) {
            this.clearAllData();
        }
    }

    async clearAllData() {
        try {
            this.showLoading("Clearing all data...");
            
            const response = await fetch(`${this.apiBase}/vulnerabilities/clear`, {
                method: "DELETE"
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Clear operation failed");
            }

            this.showLoading("Updating display...");
            
            await this.loadData();
            
            this.hideLoading();
            
            this.showToast("All vulnerability data cleared successfully!", "success");
        } catch (error) {
            this.hideLoading();
            console.error("Error clearing data:", error);
            this.showToast("Error clearing data: " + error.message, "danger");
        }
    }

    showLoading(message) {
        this.hideLoading();
        
        const toastHtml = `
            <div class="toast show position-fixed top-0 end-0 m-3" id="progressToast" style="z-index: 9999;">
                        <div class="toast-header bg-primary text-white">
                            <div class="spinner-border spinner-border-sm me-2" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <strong class="me-auto">Processing</strong>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
                        </div>
                        <div class="toast-body">${message}</div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML("beforeend", toastHtml);
                
                setTimeout(() => this.hideLoading(), 10000);
    }

    hideLoading() {
        const toast = document.getElementById("progressToast");
        if (toast) {
            toast.remove();
        }
        
        document.querySelectorAll(".modal-backdrop").forEach(el => el.remove());
        document.body.classList.remove("modal-open");
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
    }

    showToast(message, type) {
        const toastContainer = document.getElementById("toastContainer") || this.createToastContainer();
        const toastId = "toast_" + Date.now();
        
        const toastHtml = `
            <div class="toast align-items-center text-bg-${type} border-0" role="alert" id="${toastId}">
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;
        
        toastContainer.insertAdjacentHTML("beforeend", toastHtml);
        
        const toastElement = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastElement);
        toast.show();
        
        toastElement.addEventListener("hidden.bs.toast", () => {
            toastElement.remove();
        });
    }

    createToastContainer() {
        const container = document.createElement("div");
        container.id = "toastContainer";
        container.className = "toast-container position-fixed bottom-0 end-0 p-3";
        container.style.zIndex = "9999";
        document.body.appendChild(container);
        return container;
    }

    editVulnerability(id) {
        const allVulns = this.dataManager.getAllVulnerabilities();
        const filteredVulns = this.dataManager.getFilteredVulnerabilities();
        const vuln = allVulns[id] || filteredVulns[id];
        if (!vuln) {
            this.showToast("Vulnerability not found", "danger");
            return;
        }

        document.getElementById("editVulnId").value = id;
        document.getElementById("editHostname").value = vuln.hostname || "";
        document.getElementById("editIpAddress").value = vuln.ip_address || "";
        document.getElementById("editSeverity").value = vuln.severity || "";
        document.getElementById("editState").value = vuln.state || "open";
        document.getElementById("editNotes").value = vuln.notes || "";

        const modal = new bootstrap.Modal(document.getElementById("editVulnModal"));
        modal.show();
    }

    async saveVulnerabilityChanges() {
        const id = document.getElementById("editVulnId").value;
        const formData = {
            hostname: document.getElementById("editHostname").value,
            ip_address: document.getElementById("editIpAddress").value,
            severity: document.getElementById("editSeverity").value,
            state: document.getElementById("editState").value,
            notes: document.getElementById("editNotes").value
        };

        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                this.showToast("Vulnerability updated successfully!", "success");
                await this.loadData();
                bootstrap.Modal.getInstance(document.getElementById("editVulnModal")).hide();
            } else {
                this.showToast("Failed to update vulnerability", "danger");
            }
        } catch (error) {
            this.showToast("Error updating vulnerability: " + error.message, "danger");
        }
    }

    async deleteVulnerability(id) {
        if (!confirm("Are you sure you want to delete this vulnerability? This action cannot be undone.")) {
            return;
        }

        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "DELETE"
            });

            if (response.ok) {
                this.showToast("Vulnerability deleted successfully!", "success");
                await this.loadData();
            } else {
                this.showToast("Failed to delete vulnerability", "danger");
            }
        } catch (error) {
            this.showToast("Error deleting vulnerability: " + error.message, "danger");
        }
    }

    async refreshVulnerability(id) {
        const allVulns = this.dataManager.getAllVulnerabilities();
        const filteredVulns = this.dataManager.getFilteredVulnerabilities();
        const vuln = allVulns[id] || filteredVulns[id];
        if (!vuln) {
            this.showToast("Vulnerability not found", "danger");
            return;
        }

        this.showToast("Refreshing vulnerability data...", "info");
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        this.showToast("Vulnerability data refreshed!", "success");
    }

    exportDeviceReport(hostname) {
        const device = this.dataManager.getDeviceByHostname(hostname);
        if (!device) {return;}

        const csvData = device.vulnerabilities.map(vuln => ({
            "Device": hostname,
            "CVE": vuln.cve || "N/A",
            "VPR Score": vuln.vpr_score || 0,
            "Severity": vuln.severity,
            "Plugin Name": vuln.plugin_name,
            "Port": vuln.port || "N/A",
            "First Seen": vuln.first_seen ? new Date(vuln.first_seen).toLocaleDateString() : "N/A",
            "Last Seen": vuln.last_seen && vuln.last_seen.trim() !== "" 
                ? new Date(vuln.last_seen).toLocaleDateString() 
                : (vuln.scan_date && vuln.scan_date.trim() !== "" 
                    ? new Date(vuln.scan_date).toLocaleDateString() 
                    : "N/A")
        }));

        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `device_${hostname}_vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Device report exported for ${hostname}`, "success");
    }

    exportVulnerabilityReport() {
        const modal = document.getElementById("vulnerabilityModal");
        if (!modal.classList.contains("show")) {return;}

        const vulnTitle = modal.querySelector(".modal-title").textContent;
        const vulnInfo = modal.querySelector("#vulnerabilityInfo").innerHTML;
        
        const reportContent = `
            ${vulnTitle}\n
                    Generated: ${new Date().toLocaleString()}\n
                    ${vulnInfo.replace(/<[^>]*>/g, "").replace(/&nbsp;/g, " ")}
                `;

        const blob = new Blob([reportContent], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerability_report_${new Date().toISOString().split("T")[0]}.txt`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Vulnerability report exported", "success");
    }

    generateDevicePDF(_hostname) {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    generateVulnerabilityPDF() {
        this.showToast("PDF generation feature coming soon!", "info");
    }


}