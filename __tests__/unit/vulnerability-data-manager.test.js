/**
 * @fileoverview Unit tests for VulnerabilityDataManager
 * Tests the core data management functionality for vulnerabilities
 */

// Mock fetch globally for Node.js environment
global.fetch = jest.fn();

// Import the class being tested
const path = require('path');
const fs = require('fs');

// Load the actual class (we'll need to adjust this when we extract the module)
let VulnerabilityDataManager;

beforeAll(() => {
  // For now, simulate loading the class from the current location
  // This will be updated when we extract the actual module
  const classPath = path.join(__dirname, '../../scripts/shared/vulnerability-data.js');
  
  // Mock implementation until we have the actual extracted module
  VulnerabilityDataManager = class {
    constructor(apiBase = "/api") {
      this.apiBase = apiBase;
      this.vulnerabilities = [];
      this.filteredVulnerabilities = [];
      this.devices = [];
      this.historicalData = [];
      this.statistics = {};
      this.trends = {};
      this.uniqueAssets = new Set();
      this.listeners = new Map();
    }

    async loadData() {
      // Mock implementation
      const response = await fetch(`${this.apiBase}/vulnerabilities`);
      const data = await response.json();
      this.vulnerabilities = data.vulnerabilities || [];
      this.devices = data.devices || [];
      this.processDevices();
      return data;
    }

    processDevices() {
      this.uniqueAssets.clear();
      this.devices.forEach(device => {
        if (device.hostname) {
          this.uniqueAssets.add(this.normalizeHostname(device.hostname));
        }
      });
    }

    normalizeHostname(hostname) {
      if (!hostname) return '';
      return hostname.split('.')[0].toLowerCase();
    }

    filterData(searchTerm = null, severityFilter = null) {
      let filtered = [...this.vulnerabilities];

      if (searchTerm) {
        const search = searchTerm.toLowerCase();
        filtered = filtered.filter(vuln => 
          (vuln.hostname && vuln.hostname.toLowerCase().includes(search)) ||
          (vuln.cve && vuln.cve.toLowerCase().includes(search)) ||
          (vuln.plugin_name && vuln.plugin_name.toLowerCase().includes(search)) ||
          (vuln.description && vuln.description.toLowerCase().includes(search))
        );
      }

      if (severityFilter && severityFilter !== 'All') {
        filtered = filtered.filter(vuln => vuln.severity === severityFilter);
      }

      this.filteredVulnerabilities = filtered;
      return filtered;
    }

    groupVulnerabilitiesByCVE() {
      const grouped = {};
      this.vulnerabilities.forEach(vuln => {
        const key = vuln.cve || vuln.plugin_name || 'unknown';
        if (!grouped[key]) {
          grouped[key] = {
            ...vuln,
            affectedDevices: []
          };
        }
        grouped[key].affectedDevices.push({
          hostname: vuln.hostname,
          first_detected: vuln.first_detected,
          last_seen: vuln.last_seen,
          state: vuln.state
        });
      });
      return grouped;
    }

    getStatistics() {
      return this.statistics;
    }

    getAllVulnerabilities() {
      return this.vulnerabilities;
    }

    getFilteredVulnerabilities() {
      return this.filteredVulnerabilities;
    }

    getDevices() {
      return this.devices;
    }

    getUniqueAssetCount() {
      return this.uniqueAssets.size;
    }

    on(event, callback) {
      if (!this.listeners.has(event)) {
        this.listeners.set(event, []);
      }
      this.listeners.get(event).push(callback);
    }

    off(event, callback) {
      if (this.listeners.has(event)) {
        const callbacks = this.listeners.get(event);
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(event, data) {
      if (this.listeners.has(event)) {
        this.listeners.get(event).forEach(callback => {
          try {
            callback(data);
          } catch (error) {
            console.error('Error in event listener:', error);
          }
        });
      }
    }
  };
});

describe('VulnerabilityDataManager', () => {
  let dataManager;
  let mockFetch;

  beforeEach(() => {
    // Reset mocks
    fetch.mockClear();
    mockFetch = fetch;
    
    // Create fresh instance for each test
    dataManager = new VulnerabilityDataManager('/api');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Constructor', () => {
    test('initializes with default API base', () => {
      const manager = new VulnerabilityDataManager();
      expect(manager.apiBase).toBe('/api');
    });

    test('initializes with custom API base', () => {
      const manager = new VulnerabilityDataManager('/custom/api');
      expect(manager.apiBase).toBe('/custom/api');
    });

    test('initializes empty data structures', () => {
      expect(dataManager.vulnerabilities).toEqual([]);
      expect(dataManager.devices).toEqual([]);
      expect(dataManager.statistics).toEqual({});
      expect(dataManager.uniqueAssets.size).toBe(0);
    });

    test('initializes event listener system', () => {
      expect(dataManager.listeners).toBeInstanceOf(Map);
      expect(dataManager.listeners.size).toBe(0);
    });
  });

  describe('Data Loading', () => {
    test('loadData fetches from correct API endpoint', async () => {
      const mockResponse = {
        vulnerabilities: [
          { id: 1, cve: 'CVE-2024-0001', severity: 'Critical', hostname: 'device-001' }
        ],
        devices: [
          { hostname: 'device-001', ip: '192.168.1.10' }
        ]
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await dataManager.loadData();

      expect(mockFetch).toHaveBeenCalledWith('/api/vulnerabilities');
      expect(dataManager.vulnerabilities).toEqual(mockResponse.vulnerabilities);
      expect(dataManager.devices).toEqual(mockResponse.devices);
    });

    test('loadData handles API errors gracefully', async () => {
      mockFetch.mockRejectedValueOnce(new Error('API Error'));

      await expect(dataManager.loadData()).rejects.toThrow('API Error');
    });

    test('loadData processes devices after loading', async () => {
      const mockResponse = {
        vulnerabilities: [],
        devices: [
          { hostname: 'device-001.company.local' },
          { hostname: 'device-002.local' }
        ]
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await dataManager.loadData();

      expect(dataManager.uniqueAssets.size).toBe(2);
      expect(dataManager.uniqueAssets.has('device-001')).toBe(true);
      expect(dataManager.uniqueAssets.has('device-002')).toBe(true);
    });
  });

  describe('Hostname Normalization', () => {
    test('normalizeHostname removes domain suffix', () => {
      expect(dataManager.normalizeHostname('device-001.company.local')).toBe('device-001');
      expect(dataManager.normalizeHostname('server.domain.com')).toBe('server');
    });

    test('normalizeHostname converts to lowercase', () => {
      expect(dataManager.normalizeHostname('DEVICE-001')).toBe('device-001');
      expect(dataManager.normalizeHostname('Server.Local')).toBe('server');
    });

    test('normalizeHostname handles edge cases', () => {
      expect(dataManager.normalizeHostname('')).toBe('');
      expect(dataManager.normalizeHostname(null)).toBe('');
      expect(dataManager.normalizeHostname(undefined)).toBe('');
      expect(dataManager.normalizeHostname('192.168.1.100')).toBe('192');
    });
  });

  describe('Data Filtering', () => {
    beforeEach(() => {
      // Setup test data
      dataManager.vulnerabilities = [
        {
          id: 1,
          cve: 'CVE-2024-0001',
          plugin_name: 'Test Plugin 1',
          severity: 'Critical',
          hostname: 'device-001',
          description: 'Critical vulnerability in device 001'
        },
        {
          id: 2,
          cve: 'CVE-2024-0002',
          plugin_name: 'Test Plugin 2',
          severity: 'High',
          hostname: 'device-002',
          description: 'High priority issue in device 002'
        },
        {
          id: 3,
          cve: 'CVE-2024-0003',
          plugin_name: 'Another Plugin',
          severity: 'Critical',
          hostname: 'server-001',
          description: 'Server security vulnerability'
        }
      ];
    });

    test('filterData returns all data when no filters applied', () => {
      const result = dataManager.filterData();
      expect(result).toHaveLength(3);
      expect(result).toEqual(dataManager.vulnerabilities);
    });

    test('filterData filters by search term in hostname', () => {
      const result = dataManager.filterData('device');
      expect(result).toHaveLength(2);
      expect(result.every(v => v.hostname.includes('device'))).toBe(true);
    });

    test('filterData filters by search term in CVE', () => {
      const result = dataManager.filterData('CVE-2024-0001');
      expect(result).toHaveLength(1);
      expect(result[0].cve).toBe('CVE-2024-0001');
    });

    test('filterData filters by search term in description', () => {
      const result = dataManager.filterData('server');
      expect(result).toHaveLength(1);
      expect(result[0].description).toContain('Server');
    });

    test('filterData filters by severity', () => {
      const result = dataManager.filterData(null, 'Critical');
      expect(result).toHaveLength(2);
      expect(result.every(v => v.severity === 'Critical')).toBe(true);
    });

    test('filterData combines search term and severity filter', () => {
      const result = dataManager.filterData('device', 'Critical');
      expect(result).toHaveLength(1);
      expect(result[0].hostname).toBe('device-001');
      expect(result[0].severity).toBe('Critical');
    });

    test('filterData is case insensitive', () => {
      const result = dataManager.filterData('CRITICAL');
      expect(result).toHaveLength(1);
      expect(result[0].description).toContain('Critical');
    });

    test('filterData updates filteredVulnerabilities property', () => {
      dataManager.filterData('device');
      expect(dataManager.filteredVulnerabilities).toHaveLength(2);
    });
  });

  describe('CVE Grouping', () => {
    test('groupVulnerabilitiesByCVE groups by CVE identifier', () => {
      dataManager.vulnerabilities = [
        { cve: 'CVE-2024-0001', hostname: 'device-001', severity: 'Critical' },
        { cve: 'CVE-2024-0001', hostname: 'device-002', severity: 'Critical' },
        { cve: 'CVE-2024-0002', hostname: 'device-003', severity: 'High' }
      ];

      const grouped = dataManager.groupVulnerabilitiesByCVE();

      expect(Object.keys(grouped)).toHaveLength(2);
      expect(grouped['CVE-2024-0001'].affectedDevices).toHaveLength(2);
      expect(grouped['CVE-2024-0002'].affectedDevices).toHaveLength(1);
    });

    test('groupVulnerabilitiesByCVE handles vulnerabilities without CVE', () => {
      dataManager.vulnerabilities = [
        { plugin_name: 'Test Plugin', hostname: 'device-001', severity: 'Medium' },
        { hostname: 'device-002', severity: 'Low' }
      ];

      const grouped = dataManager.groupVulnerabilitiesByCVE();

      expect(grouped['Test Plugin']).toBeDefined();
      expect(grouped['unknown']).toBeDefined();
    });
  });

  describe('Event System', () => {
    test('on() registers event listeners', () => {
      const callback = jest.fn();
      dataManager.on('dataLoaded', callback);

      expect(dataManager.listeners.has('dataLoaded')).toBe(true);
      expect(dataManager.listeners.get('dataLoaded')).toContain(callback);
    });

    test('emit() triggers registered listeners', () => {
      const callback = jest.fn();
      dataManager.on('dataLoaded', callback);

      const testData = { count: 10 };
      dataManager.emit('dataLoaded', testData);

      expect(callback).toHaveBeenCalledWith(testData);
    });

    test('off() removes specific event listeners', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      
      dataManager.on('dataLoaded', callback1);
      dataManager.on('dataLoaded', callback2);
      dataManager.off('dataLoaded', callback1);

      dataManager.emit('dataLoaded', {});

      expect(callback1).not.toHaveBeenCalled();
      expect(callback2).toHaveBeenCalled();
    });

    test('emit() handles errors in listeners gracefully', () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      const faultyCallback = jest.fn(() => {
        throw new Error('Callback error');
      });
      
      dataManager.on('test', faultyCallback);
      
      expect(() => dataManager.emit('test', {})).not.toThrow();
      expect(consoleSpy).toHaveBeenCalledWith('Error in event listener:', expect.any(Error));
      
      consoleSpy.mockRestore();
    });
  });

  describe('Data Getters', () => {
    test('getAllVulnerabilities returns all vulnerabilities', () => {
      const testData = [{ id: 1, cve: 'CVE-2024-0001' }];
      dataManager.vulnerabilities = testData;
      
      expect(dataManager.getAllVulnerabilities()).toBe(testData);
    });

    test('getFilteredVulnerabilities returns filtered results', () => {
      const filtered = [{ id: 1, cve: 'CVE-2024-0001' }];
      dataManager.filteredVulnerabilities = filtered;
      
      expect(dataManager.getFilteredVulnerabilities()).toBe(filtered);
    });

    test('getDevices returns device list', () => {
      const devices = [{ hostname: 'device-001' }];
      dataManager.devices = devices;
      
      expect(dataManager.getDevices()).toBe(devices);
    });

    test('getUniqueAssetCount returns unique asset count', () => {
      dataManager.uniqueAssets.add('device-001');
      dataManager.uniqueAssets.add('device-002');
      
      expect(dataManager.getUniqueAssetCount()).toBe(2);
    });

    test('getStatistics returns statistics object', () => {
      const stats = { total: 100, critical: 10 };
      dataManager.statistics = stats;
      
      expect(dataManager.getStatistics()).toBe(stats);
    });
  });
});