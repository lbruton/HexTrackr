/**
 * @fileoverview Unit tests for VulnerabilityStatisticsManager
 * Tests the statistics, trends, and chart functionality
 */

const VulnerabilityStatisticsManager = require('../../scripts/shared/vulnerability-statistics.js');

// Mock DOM methods and elements
const createMockElement = (textContent = '', innerHTML = '') => ({
    textContent,
    innerHTML,
    className: '',
    querySelector: jest.fn(),
    style: { display: 'block' }
});

global.document = {
    getElementById: jest.fn(),
    querySelector: jest.fn(),
    querySelectorAll: jest.fn(() => [])
};

// Mock CustomEvent for Node.js test environment
global.CustomEvent = class CustomEvent extends Event {
    constructor(type, eventInitDict = {}) {
        super(type, eventInitDict);
        this.detail = eventInitDict.detail;
    }
};

// Mock Event class if not available
if (typeof global.Event === 'undefined') {
    global.Event = class Event {
        constructor(type, eventInitDict = {}) {
            this.type = type;
            this.bubbles = eventInitDict.bubbles || false;
            this.cancelable = eventInitDict.cancelable || false;
        }
    };
}

describe('VulnerabilityStatisticsManager', () => {
    let statisticsManager;
    let mockDataManager;

    beforeEach(() => {
        // Mock data manager
        mockDataManager = {
            getStatistics: jest.fn(),
            getHistoricalData: jest.fn(),
            extendTimelineData: jest.fn()
        };

        // Reset DOM mocks
        document.getElementById.mockReset();
        document.querySelector.mockReset();

        // Create fresh instance for each test
        statisticsManager = new VulnerabilityStatisticsManager(mockDataManager);
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('Constructor', () => {
        test('initializes with data manager reference', () => {
            expect(statisticsManager.dataManager).toBe(mockDataManager);
        });

        test('initializes default properties', () => {
            expect(statisticsManager.trends).toEqual({});
            expect(statisticsManager.currentMetricType).toBe('vpr');
        });

        test('extends EventTarget for event handling', () => {
            expect(statisticsManager instanceof EventTarget).toBe(true);
        });
    });

    describe('Statistics Display', () => {
        test('updateStatisticsDisplay handles missing statistics gracefully', () => {
            mockDataManager.getStatistics.mockReturnValue(null);
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

            statisticsManager.updateStatisticsDisplay();

            expect(consoleSpy).toHaveBeenCalledWith('Statistics data not available');
            consoleSpy.mockRestore();
        });

        test('updateStatisticsDisplay updates DOM elements with statistics', () => {
            const mockStatistics = {
                critical: { count: 10, total_vpr: 25.5 },
                high: { count: 15, total_vpr: 30.0 },
                medium: { count: 8, total_vpr: 12.8 },
                low: { count: 5, total_vpr: 5.0 },
                info: { count: 2, total_vpr: 1.0 }
            };

            mockDataManager.getStatistics.mockReturnValue(mockStatistics);

            const mockElements = {
                criticalCount: createMockElement(),
                criticalVPR: createMockElement(),
                'total-vulns': createMockElement()
            };

            document.getElementById.mockImplementation(id => mockElements[id] || null);

            statisticsManager.updateStatisticsDisplay();

            expect(document.getElementById).toHaveBeenCalledWith('criticalCount');
            expect(document.getElementById).toHaveBeenCalledWith('criticalVPR');
            expect(document.getElementById).toHaveBeenCalledWith('total-vulns');
        });

        test('updateStatisticsDisplay emits statisticsDisplayUpdated event', (done) => {
            const mockStatistics = {
                critical: { count: 10, total_vpr: 25.5 }
            };

            mockDataManager.getStatistics.mockReturnValue(mockStatistics);
            document.getElementById.mockReturnValue(null);

            statisticsManager.addEventListener('statisticsDisplayUpdated', (event) => {
                expect(event.detail.statistics).toBe(mockStatistics);
                expect(event.detail.totalVulns).toBe(10);
                done();
            });

            statisticsManager.updateStatisticsDisplay();
        });
    });

    describe('Trend Calculations', () => {
        test('calculateTrend handles stable values', () => {
            const result = statisticsManager.calculateTrend(10, 10);
            expect(result).toEqual({ direction: 'stable', percentage: '0' });
        });

        test('calculateTrend handles zero to non-zero increase', () => {
            const result = statisticsManager.calculateTrend(0, 10);
            expect(result).toEqual({ direction: 'up', percentage: '100' });
        });

        test('calculateTrend handles percentage increase', () => {
            const result = statisticsManager.calculateTrend(10, 15);
            expect(result).toEqual({ direction: 'up', percentage: '50.0' });
        });

        test('calculateTrend handles percentage decrease', () => {
            const result = statisticsManager.calculateTrend(20, 15);
            expect(result).toEqual({ direction: 'down', percentage: '25.0' });
        });

        test('calculateTrend handles small changes as stable', () => {
            const result = statisticsManager.calculateTrend(100, 100.5);
            expect(result).toEqual({ direction: 'stable', percentage: '0' });
        });
    });

    describe('Trend Indicators', () => {
        test('updateTrendIndicators uses historical data when available', () => {
            const mockHistoricalData = [
                { critical_vpr: 20, high_vpr: 15, medium_vpr: 10, low_vpr: 5 },
                { critical_vpr: 25, high_vpr: 18, medium_vpr: 12, low_vpr: 6 }
            ];

            mockDataManager.getHistoricalData.mockReturnValue(mockHistoricalData);

            const mockTrendElement = createMockElement();
            document.getElementById.mockReturnValue(mockTrendElement);

            statisticsManager.updateTrendIndicators({});

            expect(mockDataManager.getHistoricalData).toHaveBeenCalled();
            expect(document.getElementById).toHaveBeenCalledWith('criticalTrend');
        });

        test('updateTrendIndicators generates mock trends when no historical data', () => {
            mockDataManager.getHistoricalData.mockReturnValue([]);

            const mockTrendElement = createMockElement();
            document.getElementById.mockReturnValue(mockTrendElement);

            statisticsManager.updateTrendIndicators({});

            expect(document.getElementById).toHaveBeenCalledWith('criticalTrend');
        });

        test('updateTrendIndicators emits trendsUpdated event with historical data', (done) => {
            const mockHistoricalData = [
                { critical_vpr: 20, high_vpr: 15, medium_vpr: 10, low_vpr: 5 }
            ];

            mockDataManager.getHistoricalData.mockReturnValue(mockHistoricalData);
            document.getElementById.mockReturnValue(createMockElement());

            statisticsManager.addEventListener('trendsUpdated', (event) => {
                expect(event.detail.historicalData).toBe(mockHistoricalData);
                expect(event.detail.trends).toBeDefined();
                done();
            });

            statisticsManager.updateTrendIndicators({});
        });

        test('updateTrendIndicators emits mockTrendsGenerated event without historical data', (done) => {
            mockDataManager.getHistoricalData.mockReturnValue([]);
            document.getElementById.mockReturnValue(createMockElement());

            statisticsManager.addEventListener('mockTrendsGenerated', (event) => {
                expect(event.detail.trends).toBeDefined();
                done();
            });

            statisticsManager.updateTrendIndicators({});
        });
    });

    describe('Chart Updates', () => {
        test('updateChart returns early when no chart provided', () => {
            statisticsManager.updateChart(null);
            expect(mockDataManager.getHistoricalData).not.toHaveBeenCalled();
        });

        test('updateChart returns early when no historical data', () => {
            mockDataManager.getHistoricalData.mockReturnValue([]);
            const mockChart = { updateSeries: jest.fn() };

            statisticsManager.updateChart(mockChart);

            expect(mockChart.updateSeries).not.toHaveBeenCalled();
        });

        test('updateChart processes data and updates chart', () => {
            const mockHistoricalData = [
                { date: '2024-09-01', Critical: { total_vpr: 25, count: 5 } }
            ];
            const mockExtendedData = [
                { date: '2024-09-01', Critical: { total_vpr: 25, count: 5 }, hasActualData: true }
            ];

            mockDataManager.getHistoricalData.mockReturnValue(mockHistoricalData);
            mockDataManager.extendTimelineData.mockReturnValue(mockExtendedData);

            const mockChart = {
                updateSeries: jest.fn(),
                updateOptions: jest.fn(),
                resetSeries: jest.fn(),
                zoomX: jest.fn()
            };

            document.querySelector.mockReturnValue(null);

            statisticsManager.updateChart(mockChart);

            expect(mockChart.updateSeries).toHaveBeenCalled();
            expect(mockChart.updateOptions).toHaveBeenCalled();
        });

        test('updateChart emits chartUpdated event', (done) => {
            const mockHistoricalData = [
                { date: '2024-09-01', Critical: { total_vpr: 25 } }
            ];
            mockDataManager.getHistoricalData.mockReturnValue(mockHistoricalData);
            mockDataManager.extendTimelineData.mockReturnValue(mockHistoricalData);

            const mockChart = {
                updateSeries: jest.fn(),
                updateOptions: jest.fn()
            };

            document.querySelector.mockReturnValue(null);

            statisticsManager.addEventListener('chartUpdated', (event) => {
                expect(event.detail.series).toBeDefined();
                expect(event.detail.metricType).toBe('vpr');
                done();
            });

            statisticsManager.updateChart(mockChart);
        });
    });

    describe('Metric Type Management', () => {
        test('getCurrentMetricType returns current metric type', () => {
            expect(statisticsManager.getCurrentMetricType()).toBe('vpr');
        });

        test('setCurrentMetricType updates and emits event', (done) => {
            statisticsManager.addEventListener('metricTypeChanged', (event) => {
                expect(event.detail.metricType).toBe('count');
                done();
            });

            statisticsManager.setCurrentMetricType('count');
            expect(statisticsManager.getCurrentMetricType()).toBe('count');
        });
    });

    describe('Trends Management', () => {
        test('getTrends returns current trends data', () => {
            expect(statisticsManager.getTrends()).toEqual({});
        });

        test('setTrends updates trends and emits event', (done) => {
            const newTrends = { critical: 'up', high: 'down' };

            statisticsManager.addEventListener('trendsSet', (event) => {
                expect(event.detail.trends).toBe(newTrends);
                done();
            });

            statisticsManager.setTrends(newTrends);
            expect(statisticsManager.getTrends()).toBe(newTrends);
        });
    });
});