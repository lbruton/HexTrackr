/* eslint-env jest */
/* global describe, test, expect, beforeEach, jest */

/**
 * @fileoverview Unit tests for VulnerabilityCoreOrchestrator
 * Tests the coordination and event management between vulnerability modules
 */

describe('VulnerabilityCoreOrchestrator', () => {
    let orchestrator;
    let mockParentManager;
    let mockDataManager;
    let mockStatisticsManager;
    let mockChartManager;
    let mockSearchManager;
    let mockGridManager;
    let mockCardsManager;

    beforeEach(() => {
        // Reset modules
        jest.resetModules();
        jest.clearAllMocks();

        // Create mock parent manager
        mockParentManager = {
            showToast: jest.fn()
        };

        // Create mock managers with EventTarget
        mockDataManager = {
            addEventListener: jest.fn(),
            fetchVulnerabilities: jest.fn().mockResolvedValue({ success: true }),
            getCurrentData: jest.fn().mockReturnValue([]),
            getHistoricalData: jest.fn().mockReturnValue([])
        };

        mockStatisticsManager = {
            addEventListener: jest.fn(),
            updateStatisticsDisplay: jest.fn(),
            updateTrendIndicators: jest.fn()
        };

        mockChartManager = {
            addEventListener: jest.fn(),
            updateChart: jest.fn(),
            initializeChart: jest.fn()
        };

        mockSearchManager = {
            addEventListener: jest.fn(),
            initializeSearch: jest.fn(),
            clearSearch: jest.fn()
        };

        mockGridManager = {
            addEventListener: jest.fn(),
            initializeGrid: jest.fn(),
            updateGrid: jest.fn(),
            switchView: jest.fn()
        };

        mockCardsManager = {
            addEventListener: jest.fn(),
            renderDeviceCards: jest.fn(),
            renderVulnerabilityCards: jest.fn()
        };

        // Mock the module constructors
        jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-data.js', () => ({
            VulnerabilityDataManager: jest.fn(() => mockDataManager)
        }));

        jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-statistics.js', () => ({
            VulnerabilityStatisticsManager: jest.fn(() => mockStatisticsManager)
        }));

        jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-chart-manager.js', () => ({
            VulnerabilityChartManager: jest.fn(() => mockChartManager)
        }));

        jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-search.js', () => ({
            VulnerabilitySearchManager: jest.fn(() => mockSearchManager)
        }));

        jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-grid.js', () => ({
            VulnerabilityGridManager: jest.fn(() => mockGridManager)
        }));

        jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-cards.js', () => ({
            VulnerabilityCardsManager: jest.fn(() => mockCardsManager)
        }));

        // Import the orchestrator after mocks are set up
        const { VulnerabilityCoreOrchestrator } = require('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-core.js');
        orchestrator = new VulnerabilityCoreOrchestrator();
    });

    describe('Module Initialization', () => {
        test('should initialize all modules in correct order', async () => {
            await orchestrator.initializeAllModules(mockParentManager);

            expect(orchestrator.dataManager).toBeDefined();
            expect(orchestrator.statisticsManager).toBeDefined();
            expect(orchestrator.chartManager).toBeDefined();
            expect(orchestrator.searchManager).toBeDefined();
            expect(orchestrator.gridManager).toBeDefined();
            expect(orchestrator.cardsManager).toBeDefined();
        });

        test('should set up event listeners during initialization', async () => {
            await orchestrator.initializeAllModules(mockParentManager);

            // Verify event listeners were registered
            expect(mockDataManager.addEventListener).toHaveBeenCalled();
            expect(mockStatisticsManager.addEventListener).toHaveBeenCalled();
            expect(mockChartManager.addEventListener).toHaveBeenCalled();
            expect(mockSearchManager.addEventListener).toHaveBeenCalled();
            expect(mockGridManager.addEventListener).toHaveBeenCalled();
        });
    });

    describe('View Switching', () => {
        beforeEach(async () => {
            await orchestrator.initializeAllModules(mockParentManager);
        });

        test('should switch to table view', () => {
            orchestrator.switchView('table');
            expect(mockGridManager.switchView).toHaveBeenCalledWith('table');
        });

        test('should switch to devices view', () => {
            orchestrator.switchView('devices');
            expect(mockGridManager.switchView).toHaveBeenCalledWith('devices');
        });

        test('should switch to vulnerabilities view', () => {
            orchestrator.switchView('vulnerabilities');
            expect(mockGridManager.switchView).toHaveBeenCalledWith('vulnerabilities');
        });
    });

    describe('Data Loading', () => {
        beforeEach(async () => {
            await orchestrator.initializeAllModules(mockParentManager);
        });

        test('should load data from data manager', async () => {
            await orchestrator.loadData();
            expect(mockDataManager.fetchVulnerabilities).toHaveBeenCalled();
        });

        test('should handle data load errors gracefully', async () => {
            mockDataManager.fetchVulnerabilities.mockRejectedValue(new Error('Network error'));
            
            await expect(orchestrator.loadData()).rejects.toThrow('Network error');
        });
    });

    describe('Event Coordination', () => {
        beforeEach(async () => {
            await orchestrator.initializeAllModules(mockParentManager);
        });

        test('should coordinate data refresh across modules', async () => {
            // Simulate data refresh event
            const dataRefreshHandler = mockDataManager.addEventListener.mock.calls
                .find(call => call[0] === 'dataRefreshed')[1];
            
            if (dataRefreshHandler) {
                const mockEvent = { detail: { data: [] } };
                dataRefreshHandler(mockEvent);

                expect(mockStatisticsManager.updateStatisticsDisplay).toHaveBeenCalled();
                expect(mockChartManager.updateChart).toHaveBeenCalled();
            }
        });

        test('should handle search events', () => {
            // Simulate search event
            const searchHandler = mockSearchManager.addEventListener.mock.calls
                .find(call => call[0] === 'searchPerformed');
            
            expect(searchHandler).toBeDefined();
        });
    });

    describe('Detail Views', () => {
        beforeEach(async () => {
            await orchestrator.initializeAllModules(mockParentManager);
        });

        test('should handle device details request', () => {
            const hostname = 'test-server-01';
            orchestrator.viewDeviceDetails(hostname);
            
            // Verify the method exists and can be called
            expect(orchestrator.viewDeviceDetails).toBeDefined();
        });

        test('should handle vulnerability details request', () => {
            const vulnId = 'CVE-2024-1234';
            orchestrator.viewVulnerabilityDetails(vulnId);
            
            // Verify the method exists and can be called
            expect(orchestrator.viewVulnerabilityDetails).toBeDefined();
        });
    });

    describe('Export Functions', () => {
        beforeEach(async () => {
            await orchestrator.initializeAllModules(mockParentManager);
        });

        test('should handle device report export', async () => {
            const hostname = 'test-server-01';
            await orchestrator.exportDeviceReport(hostname);
            
            // Verify the method exists
            expect(orchestrator.exportDeviceReport).toBeDefined();
        });

        test('should handle vulnerability report export', () => {
            orchestrator.exportVulnerabilityReport();
            
            // Verify the method exists
            expect(orchestrator.exportVulnerabilityReport).toBeDefined();
        });
    });

    describe('Error Handling', () => {
        test('should handle initialization errors gracefully', async () => {
            // Mock a constructor to throw an error
            jest.doMock('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-data.js', () => ({
                VulnerabilityDataManager: jest.fn(() => {
                    throw new Error('Initialization failed');
                })
            }));

            // Re-import after mock change
            jest.resetModules();
            const { VulnerabilityCoreOrchestrator } = require('/Volumes/DATA/GitHub/HexTrackr/app/public/scripts/shared/vulnerability-core.js');
            const errorOrchestrator = new VulnerabilityCoreOrchestrator();

            await expect(errorOrchestrator.initializeAllModules(mockParentManager))
                .rejects.toThrow('Initialization failed');
        });
    });

    describe('Toast Notifications', () => {
        beforeEach(async () => {
            await orchestrator.initializeAllModules(mockParentManager);
        });

        test('should show success toast', () => {
            orchestrator.showToast('Operation successful', 'success');
            expect(mockParentManager.showToast).toHaveBeenCalledWith('Operation successful', 'success');
        });

        test('should show error toast', () => {
            orchestrator.showToast('Operation failed', 'error');
            expect(mockParentManager.showToast).toHaveBeenCalledWith('Operation failed', 'error');
        });
    });
});