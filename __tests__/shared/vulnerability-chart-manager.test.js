/**
 * @fileoverview VulnerabilityChartManager Unit Tests
 * Tests the chart management functionality for vulnerability data visualization
 */

// Mock ApexCharts instance methods
const mockChartInstance = {
    render: jest.fn(),
    updateSeries: jest.fn(),
    zoomX: jest.fn(),
    destroy: jest.fn(),
    dataURI: jest.fn().mockResolvedValue('data:image/png;base64,test')
};

// Mock ApexCharts constructor
const mockApexCharts = jest.fn().mockImplementation(() => mockChartInstance);
global.ApexCharts = mockApexCharts;

// Import the class we're testing
const VulnerabilityChartManager = require('../../scripts/shared/vulnerability-chart-manager');

describe('VulnerabilityChartManager', () => {
    let chartManager;
    let mockStatisticsManager;
    let mockDataManager;
    const containerId = 'test-chart-container';

    beforeEach(() => {
        // Reset all mocks
        jest.clearAllMocks();
        
        // Reset chart instance methods
        mockChartInstance.render.mockClear();
        mockChartInstance.updateSeries.mockClear();
        mockChartInstance.zoomX.mockClear();
        mockChartInstance.destroy.mockClear();
        mockChartInstance.dataURI.mockClear();
        
        // Mock DOM element for chart container
        const mockElement = document.createElement('div');
        mockElement.id = containerId;
        document.body.appendChild(mockElement);
        
        // Mock statistics manager
        mockStatisticsManager = {
            updateChart: jest.fn(),
            currentMetricType: 'vpr'
        };
        
        // Mock data manager
        mockDataManager = {
            getHistoricalData: jest.fn().mockReturnValue([
                { date: '2025-01-01', Critical: { total_vpr: 10, count: 5 }, hasActualData: true },
                { date: '2025-01-02', Critical: { total_vpr: 15, count: 7 }, hasActualData: true }
            ]),
            extendTimelineData: jest.fn().mockImplementation(data => data)
        };

        // Create chart manager instance
        chartManager = new VulnerabilityChartManager(containerId, mockStatisticsManager, mockDataManager);
    });

    afterEach(() => {
        if (chartManager) {
            chartManager.destroy();
        }
    });

    describe('Constructor', () => {
        test('should initialize with correct properties', () => {
            expect(chartManager.containerId).toBe(containerId);
            expect(chartManager.statisticsManager).toBe(mockStatisticsManager);
            expect(chartManager.dataManager).toBe(mockDataManager);
            expect(chartManager.chart).toBeNull();
        });

        test('should extend EventTarget', () => {
            expect(chartManager).toBeInstanceOf(EventTarget);
        });
    });

    describe('initialize()', () => {
        test('should create ApexCharts instance', () => {
            chartManager.initialize();
            
            expect(global.ApexCharts).toHaveBeenCalledTimes(1);
            expect(chartManager.chart).toBeTruthy();
        });

        test('should call render on chart instance', () => {
            chartManager.initialize();
            
            expect(mockChartInstance.render).toHaveBeenCalledTimes(1);
        });

        test('should emit chartInitialized event', (done) => {
            chartManager.addEventListener('chartInitialized', (event) => {
                expect(event.detail).toEqual({ containerId });
                done();
            });
            
            chartManager.initialize();
        });

        test('should not reinitialize if chart already exists', () => {
            chartManager.initialize();
            const firstChart = chartManager.chart;
            
            chartManager.initialize();
            
            expect(chartManager.chart).toBe(firstChart);
            expect(global.ApexCharts).toHaveBeenCalledTimes(1);
        });
    });

    describe('update()', () => {
        beforeEach(() => {
            chartManager.initialize();
        });

        test('should call statisticsManager.updateChart with chart instance', () => {
            chartManager.update();
            
            expect(mockStatisticsManager.updateChart).toHaveBeenCalledWith(chartManager.chart);
        });

        test('should call zoomToRecentData when historical data exists', () => {
            const zoomSpy = jest.spyOn(chartManager, 'zoomToRecentData');
            
            chartManager.update();
            
            expect(zoomSpy).toHaveBeenCalledWith(14);
        });

        test('should emit chartUpdated event', (done) => {
            chartManager.addEventListener('chartUpdated', (event) => {
                expect(event.detail).toEqual({ 
                    containerId,
                    hasData: true 
                });
                done();
            });
            
            chartManager.update();
        });

        test('should handle case when no chart exists', () => {
            chartManager.chart = null;
            
            expect(() => chartManager.update()).not.toThrow();
            expect(mockStatisticsManager.updateChart).not.toHaveBeenCalled();
        });

        test('should handle case when no historical data exists', () => {
            mockDataManager.getHistoricalData.mockReturnValue([]);
            const zoomSpy = jest.spyOn(chartManager, 'zoomToRecentData');
            
            chartManager.update();
            
            expect(zoomSpy).not.toHaveBeenCalled();
        });
    });

    describe('zoomToRecentData()', () => {
        beforeEach(() => {
            chartManager.initialize();
        });

        test('should zoom to last 14 days by default', () => {
            const mockDate = new Date('2025-01-02');
            const expectedStart = new Date(mockDate.getTime() - (14 * 24 * 60 * 60 * 1000));
            
            chartManager.zoomToRecentData();
            
            expect(chartManager.chart.zoomX).toHaveBeenCalledWith(
                expectedStart.getTime(),
                mockDate.getTime()
            );
        });

        test('should accept custom number of days', () => {
            const days = 7;
            const mockDate = new Date('2025-01-02');
            const expectedStart = new Date(mockDate.getTime() - (days * 24 * 60 * 60 * 1000));
            
            chartManager.zoomToRecentData(days);
            
            expect(chartManager.chart.zoomX).toHaveBeenCalledWith(
                expectedStart.getTime(),
                mockDate.getTime()
            );
        });

        test('should handle case when no chart exists', () => {
            chartManager.chart = null;
            
            expect(() => chartManager.zoomToRecentData()).not.toThrow();
        });

        test('should handle case when no historical data exists', () => {
            mockDataManager.getHistoricalData.mockReturnValue([]);
            
            chartManager.zoomToRecentData();
            
            expect(chartManager.chart.zoomX).not.toHaveBeenCalled();
        });

        test('should find actual data points correctly', () => {
            const testData = [
                { date: '2025-01-01', hasActualData: false },
                { date: '2025-01-02', hasActualData: true },
                { date: '2025-01-03', hasActualData: true },
                { date: '2025-01-04', hasActualData: false }
            ];
            mockDataManager.extendTimelineData.mockReturnValue(testData);
            
            chartManager.zoomToRecentData();
            
            // Should zoom to the latest actual data point (2025-01-03)
            const expectedEnd = new Date('2025-01-03').getTime();
            const expectedStart = expectedEnd - (14 * 24 * 60 * 60 * 1000);
            
            expect(chartManager.chart.zoomX).toHaveBeenCalledWith(expectedStart, expectedEnd);
        });
    });

    describe('destroy()', () => {
        test('should destroy chart instance when it exists', () => {
            chartManager.initialize();
            
            chartManager.destroy();
            
            expect(chartManager.chart.destroy).toHaveBeenCalledTimes(1);
            expect(chartManager.chart).toBeNull();
        });

        test('should emit chartDestroyed event', (done) => {
            chartManager.initialize();
            
            chartManager.addEventListener('chartDestroyed', (event) => {
                expect(event.detail).toEqual({ containerId });
                done();
            });
            
            chartManager.destroy();
        });

        test('should handle case when no chart exists', () => {
            expect(() => chartManager.destroy()).not.toThrow();
            expect(chartManager.chart).toBeNull();
        });
    });

    describe('exportChart()', () => {
        beforeEach(() => {
            chartManager.initialize();
            // Mock chart dataURI method for export testing
            chartManager.chart.dataURI = jest.fn().mockResolvedValue('data:image/png;base64,test');
        });

        test('should export chart as PNG by default', async () => {
            const result = await chartManager.exportChart();
            
            expect(chartManager.chart.dataURI).toHaveBeenCalledWith({
                type: 'png',
                width: undefined,
                height: undefined
            });
            expect(result).toBe('data:image/png;base64,test');
        });

        test('should support different formats', async () => {
            await chartManager.exportChart('svg');
            
            expect(chartManager.chart.dataURI).toHaveBeenCalledWith({
                type: 'svg',
                width: undefined,
                height: undefined
            });
        });

        test('should handle export with custom dimensions', async () => {
            await chartManager.exportChart('png', 800, 600);
            
            expect(chartManager.chart.dataURI).toHaveBeenCalledWith({
                type: 'png',
                width: 800,
                height: 600
            });
        });

        test('should return null when no chart exists', async () => {
            chartManager.chart = null;
            
            const result = await chartManager.exportChart();
            
            expect(result).toBeNull();
        });
    });
});