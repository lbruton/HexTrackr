/**
 * @fileoverview
 * Jest tests for the ModernVulnManager progress modal integration.
 * Focuses on CSV import flow, WebSocket integration, and fallback behaviors.
 */

/* eslint-env jest */
/* global jest, describe, beforeEach, afterEach, test, expect, fetch */

// Mock fetch globally
global.fetch = jest.fn();

// Mock WebSocketClient
const mockWebSocketClientInstance = {
    connect: jest.fn(() => Promise.resolve(true)),
    isSocketConnected: jest.fn(() => true),
    joinProgressRoom: jest.fn(),
    leaveProgressRoom: jest.fn(),
    on: jest.fn(),
    off: jest.fn(),
};
const MockWebSocketClient = jest.fn(() => mockWebSocketClientInstance);

// Mock ProgressModal
const mockProgressModalInstance = {
    show: jest.fn(),
    hide: jest.fn(),
    showError: jest.fn(),
    showSuccess: jest.fn(),
    destroy: jest.fn(),
};
const MockProgressModal = jest.fn(() => mockProgressModalInstance);

// Mock other dependencies
const mockVulnerabilityDataManager = {
    loadData: jest.fn(() => Promise.resolve()),
    on: jest.fn(),
};
const MockVulnerabilityDataManager = jest.fn(() => mockVulnerabilityDataManager);

const mockPaginationController = {
    setItemsPerPage: jest.fn(),
    setCurrentPage: jest.fn(),
};
const MockPaginationController = jest.fn(() => mockPaginationController);

// Mock DOM elements
const createMockElement = (id) => ({
    addEventListener: jest.fn(),
    click: jest.fn(),
    textContent: "",
    value: "",
    style: {},
    classList: {
        add: jest.fn(),
        remove: jest.fn(),
        contains: jest.fn(() => false),
    }
});

// Mock document methods
global.document = {
    getElementById: jest.fn((id) => createMockElement(id)),
    querySelectorAll: jest.fn(() => []),
    createElement: jest.fn(() => createMockElement()),
    body: {
        appendChild: jest.fn(),
        removeChild: jest.fn(),
    }
};

// Mock console to reduce noise
jest.spyOn(console, "log").mockImplementation(() => {});
jest.spyOn(console, "warn").mockImplementation(() => {});
jest.spyOn(console, "error").mockImplementation(() => {});

// Store originals
const originalWebSocketClient = global.WebSocketClient;
const originalProgressModal = global.ProgressModal;
const originalVulnerabilityDataManager = global.VulnerabilityDataManager;
const originalPaginationController = global.PaginationController;

describe("ModernVulnManager Progress Integration", () => {
    let ModernVulnManager;
    let vulnManager;

    beforeAll(() => {
        // Set up global mocks
        global.WebSocketClient = MockWebSocketClient;
        global.ProgressModal = MockProgressModal;
        global.VulnerabilityDataManager = MockVulnerabilityDataManager;
        global.PaginationController = MockPaginationController;

        // Mock additional globals that ModernVulnManager might use
        global.bootstrap = { Modal: jest.fn() };
        global.agGrid = { createGrid: jest.fn() };
        global.ApexCharts = jest.fn();
        
        // Import ModernVulnManager after setting up mocks
        // Note: This would typically require the actual module, but for demonstration
        // we'll create a simplified version that focuses on the progress modal integration
        ModernVulnManager = class {
            constructor() {
                this.apiBase = "/api";
                this.websocketClient = null;
                this.progressModal = null;
                this.dataManager = new MockVulnerabilityDataManager();
                this.devicePagination = new MockPaginationController();
                this.vulnerabilityPagination = new MockPaginationController();
                
                this.initializeWebSocketAndProgressModal();
            }

            async initializeWebSocketAndProgressModal() {
                try {
                    if (typeof WebSocketClient !== "undefined") {
                        this.websocketClient = new WebSocketClient();
                        await this.websocketClient.connect();
                        console.log("WebSocket client connected for progress tracking");
                    } else {
                        console.warn("WebSocket client not available - progress modal will work in manual mode");
                    }
                    
                    if (typeof ProgressModal !== "undefined") {
                        this.progressModal = new ProgressModal(this.websocketClient);
                        console.log("Progress modal initialized");
                    } else {
                        console.warn("Progress modal not available - falling back to traditional loading indicators");
                    }
                } catch (error) {
                    console.error("Error initializing WebSocket/Progress modal:", error);
                }
            }

            showLoading(message) {
                // Mock implementation
                console.log("Loading:", message);
            }

            hideLoading() {
                // Mock implementation
                console.log("Hide loading");
            }

            showToast(message, type) {
                // Mock implementation
                console.log("Toast:", message, type);
            }

            async loadData() {
                return this.dataManager.loadData();
            }

            async handleCsvImportWithDate(file, scanDate) {
                if (!file) {return;}

                if (file.size > 10 * 1024 * 1024) {
                    if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                        return;
                    }
                }

                const useProgressModal = this.progressModal && this.websocketClient?.isSocketConnected();
                let sessionId = null;

                try {
                    const formData = new FormData();
                    formData.append("csvFile", file);
                    formData.append("vendor", "cisco");
                    formData.append("scanDate", scanDate);

                    if (useProgressModal) {
                        sessionId = `import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        formData.append("sessionId", sessionId);
                        
                        this.progressModal.show({
                            title: "Importing CSV Data",
                            sessionId: sessionId,
                            allowCancel: true,
                            onCancel: () => this.cancelCsvImport(sessionId),
                            initialMessage: `Uploading ${file.name}...`
                        });
                    } else {
                        this.showLoading("Uploading CSV file...");
                    }

                    const response = await fetch(`${this.apiBase}/vulnerabilities/import-staging`, {
                        method: "POST",
                        body: formData
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || "Import failed");
                    }

                    const result = await response.json();

                    if (!useProgressModal) {
                        this.showLoading("Processing data...");
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        this.showLoading("Refreshing charts and data...");
                        await this.loadData();
                        
                        this.hideLoading();
                        
                        let message = `CSV import completed! Processed ${result.rowsProcessed.toLocaleString()} rows from ${result.filename} with scan date ${scanDate}.`;
                        if (result.insertCount || result.updateCount || result.removedStale) {
                            message += ` Added: ${result.insertCount || 0}, Updated: ${result.updateCount || 0}, Removed: ${result.removedStale || 0} stale items.`;
                        }
                        
                        this.showToast(message, "success");
                    } else {
                        setTimeout(async () => {
                            await this.loadData();
                        }, 1000);
                    }

                } catch (error) {
                    console.error("Error importing CSV:", error);
                    
                    if (useProgressModal && this.progressModal) {
                        this.progressModal.showError(`Import failed: ${error.message}`);
                    } else {
                        this.hideLoading();
                        this.showToast("Error importing CSV: " + error.message, "danger");
                    }
                }
            }

            async cancelCsvImport(sessionId) {
                try {
                    await fetch(`${this.apiBase}/vulnerabilities/import-cancel`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ sessionId })
                    });
                    
                    this.showToast("CSV import cancelled", "warning");
                } catch (error) {
                    console.error("Error cancelling import:", error);
                    this.showToast("Failed to cancel import: " + error.message, "danger");
                }
            }
        };
    });

    beforeEach(() => {
        // Reset all mocks
        jest.clearAllMocks();
        fetch.mockClear();
        
        // Reset WebSocket client mock state
        mockWebSocketClientInstance.isSocketConnected.mockReturnValue(true);
        mockWebSocketClientInstance.connect.mockResolvedValue(true);
        
        // Create new instance for each test
        vulnManager = new ModernVulnManager();
    });

    afterAll(() => {
        // Restore originals
        global.WebSocketClient = originalWebSocketClient;
        global.ProgressModal = originalProgressModal;
        global.VulnerabilityDataManager = originalVulnerabilityDataManager;
        global.PaginationController = originalPaginationController;
        
        console.log.mockRestore();
        console.warn.mockRestore();
        console.error.mockRestore();
    });

    describe("Initialization", () => {
        test("initializeWebSocketAndProgressModal creates WebSocket client and progress modal when available", async () => {
            expect(MockWebSocketClient).toHaveBeenCalledTimes(1);
            expect(mockWebSocketClientInstance.connect).toHaveBeenCalledTimes(1);
            expect(MockProgressModal).toHaveBeenCalledWith(mockWebSocketClientInstance);
            expect(vulnManager.websocketClient).toBeTruthy();
            expect(vulnManager.progressModal).toBeTruthy();
        });

        test("initializeWebSocketAndProgressModal handles WebSocket connection failure gracefully", async () => {
            MockWebSocketClient.mockClear();
            mockWebSocketClientInstance.connect.mockRejectedValueOnce(new Error("Connection failed"));
            
            const vulnManagerWithFailure = new ModernVulnManager();
            
            // Should complete initialization despite WebSocket failure
            expect(vulnManagerWithFailure.websocketClient).toBeTruthy();
            expect(vulnManagerWithFailure.progressModal).toBeTruthy();
        });

        test("initializeWebSocketAndProgressModal handles missing WebSocketClient", async () => {
            global.WebSocketClient = undefined;
            
            const vulnManagerNoWS = new ModernVulnManager();
            
            expect(vulnManagerNoWS.websocketClient).toBe(null);
            expect(MockProgressModal).toHaveBeenCalledWith(null);
        });

        test("initializeWebSocketAndProgressModal handles missing ProgressModal", async () => {
            global.ProgressModal = undefined;
            
            const vulnManagerNoModal = new ModernVulnManager();
            
            expect(vulnManagerNoModal.progressModal).toBe(null);
        });
    });

    describe("CSV Import with Progress Modal", () => {
        test("handleCsvImportWithDate uses ProgressModal when WebSocket is connected", async () => {
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve({
                    rowsProcessed: 100,
                    filename: "test.csv",
                    insertCount: 50,
                    updateCount: 25
                })
            });

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            expect(mockProgressModalInstance.show).toHaveBeenCalledWith({
                title: "Importing CSV Data",
                sessionId: expect.stringMatching(/^import_\d+_[a-z0-9]{9}$/),
                allowCancel: true,
                onCancel: expect.any(Function),
                initialMessage: "Uploading test.csv..."
            });

            expect(fetch).toHaveBeenCalledWith(
                "/api/vulnerabilities/import-staging",
                expect.objectContaining({
                    method: "POST",
                    body: expect.any(FormData)
                })
            );
        });

        test("handleCsvImportWithDate falls back to showLoading when WebSocket is not connected", async () => {
            mockWebSocketClientInstance.isSocketConnected.mockReturnValue(false);
            
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve({
                    rowsProcessed: 100,
                    filename: "test.csv"
                })
            });

            jest.spyOn(vulnManager, "showLoading");
            jest.spyOn(vulnManager, "hideLoading");
            jest.spyOn(vulnManager, "showToast");

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            expect(mockProgressModalInstance.show).not.toHaveBeenCalled();
            expect(vulnManager.showLoading).toHaveBeenCalledWith("Uploading CSV file...");
            expect(vulnManager.showLoading).toHaveBeenCalledWith("Processing data...");
            expect(vulnManager.showLoading).toHaveBeenCalledWith("Refreshing charts and data...");
            expect(vulnManager.hideLoading).toHaveBeenCalled();
            expect(vulnManager.showToast).toHaveBeenCalledWith(
                expect.stringContaining("CSV import completed!"),
                "success"
            );
        });

        test("handleCsvImportWithDate handles large file confirmation", async () => {
            const mockFile = { 
                name: "large-test.csv", 
                size: 20 * 1024 * 1024 // 20MB
            };
            const scanDate = "2025-01-07";
            
            // Mock confirm to return false (user declines)
            global.confirm = jest.fn(() => false);

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            expect(global.confirm).toHaveBeenCalledWith(
                "This file is 20MB. Large files will be processed server-side for better performance. Continue?"
            );
            expect(fetch).not.toHaveBeenCalled();
            expect(mockProgressModalInstance.show).not.toHaveBeenCalled();
        });

        test("handleCsvImportWithDate handles fetch errors with progress modal", async () => {
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: false,
                json: () => Promise.resolve({ error: "Server error occurred" })
            });

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            expect(mockProgressModalInstance.showError).toHaveBeenCalledWith("Import failed: Server error occurred");
        });

        test("handleCsvImportWithDate handles fetch errors with fallback mode", async () => {
            mockWebSocketClientInstance.isSocketConnected.mockReturnValue(false);
            
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: false,
                json: () => Promise.resolve({ error: "Server error occurred" })
            });

            jest.spyOn(vulnManager, "hideLoading");
            jest.spyOn(vulnManager, "showToast");

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            expect(vulnManager.hideLoading).toHaveBeenCalled();
            expect(vulnManager.showToast).toHaveBeenCalledWith(
                "Error importing CSV: Server error occurred",
                "danger"
            );
        });

        test("handleCsvImportWithDate generates unique session IDs", async () => {
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValue({
                ok: true,
                json: () => Promise.resolve({ rowsProcessed: 100, filename: "test.csv" })
            });

            const sessionIds = [];
            
            // Collect session IDs from multiple calls
            for (let i = 0; i < 3; i++) {
                await vulnManager.handleCsvImportWithDate(mockFile, scanDate);
                const lastCall = mockProgressModalInstance.show.mock.calls[i];
                sessionIds.push(lastCall[0].sessionId);
            }

            // All session IDs should be unique
            const uniqueIds = new Set(sessionIds);
            expect(uniqueIds.size).toBe(3);
            
            // All should match the expected format
            sessionIds.forEach(id => {
                expect(id).toMatch(/^import_\d+_[a-z0-9]{9}$/);
            });
        });
    });

    describe("Cancel Import Functionality", () => {
        test("cancelCsvImport sends cancellation request", async () => {
            const sessionId = "test-session-123";
            
            fetch.mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve({ message: "Import cancelled" })
            });

            jest.spyOn(vulnManager, "showToast");

            await vulnManager.cancelCsvImport(sessionId);

            expect(fetch).toHaveBeenCalledWith(
                "/api/vulnerabilities/import-cancel",
                {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ sessionId })
                }
            );
            expect(vulnManager.showToast).toHaveBeenCalledWith("CSV import cancelled", "warning");
        });

        test("cancelCsvImport handles cancellation errors", async () => {
            const sessionId = "test-session-123";
            
            fetch.mockRejectedValueOnce(new Error("Network error"));

            jest.spyOn(vulnManager, "showToast");

            await vulnManager.cancelCsvImport(sessionId);

            expect(vulnManager.showToast).toHaveBeenCalledWith(
                "Failed to cancel import: Network error",
                "danger"
            );
        });

        test("onCancel callback is properly wired in progress modal", async () => {
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve({ rowsProcessed: 100, filename: "test.csv" })
            });

            jest.spyOn(vulnManager, "cancelCsvImport");

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            // Get the onCancel callback that was passed to the progress modal
            const showCall = mockProgressModalInstance.show.mock.calls[0];
            const onCancelCallback = showCall[0].onCancel;

            // Execute the callback
            onCancelCallback();

            expect(vulnManager.cancelCsvImport).toHaveBeenCalledWith(
                expect.stringMatching(/^import_\d+_[a-z0-9]{9}$/)
            );
        });
    });

    describe("Data Loading Integration", () => {
        test("loadData is called after successful import in fallback mode", async () => {
            mockWebSocketClientInstance.isSocketConnected.mockReturnValue(false);
            
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve({ rowsProcessed: 100, filename: "test.csv" })
            });

            jest.spyOn(vulnManager, "loadData");

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);

            expect(vulnManager.loadData).toHaveBeenCalled();
        });

        test("loadData is called after successful import in progress modal mode", async () => {
            const mockFile = { 
                name: "test.csv", 
                size: 1024 
            };
            const scanDate = "2025-01-07";
            
            fetch.mockResolvedValueOnce({
                ok: true,
                json: () => Promise.resolve({ rowsProcessed: 100, filename: "test.csv" })
            });

            jest.spyOn(vulnManager, "loadData");
            jest.useFakeTimers();

            await vulnManager.handleCsvImportWithDate(mockFile, scanDate);
            
            // Fast-forward the setTimeout
            jest.advanceTimersByTime(1000);

            expect(vulnManager.loadData).toHaveBeenCalled();
            jest.useRealTimers();
        });
    });
});