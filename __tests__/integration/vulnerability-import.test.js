/**
 * @fileoverview Integration tests for vulnerability CSV import functionality
 * Tests the complete workflow from CSV parsing to database storage
 */

const fs = require('fs');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();
const Papa = require('papaparse');

// Mock database for testing
let testDb;

beforeAll(async () => {
  // Create in-memory SQLite database for testing
  testDb = new sqlite3.Database(':memory:');
  
  // Create test tables (simplified schema)
  await new Promise((resolve, reject) => {
    testDb.serialize(() => {
      testDb.run(`CREATE TABLE IF NOT EXISTS vulnerabilities_current (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        hostname TEXT NOT NULL,
        cve TEXT,
        plugin_name TEXT,
        severity TEXT,
        description TEXT,
        first_detected TEXT,
        last_seen TEXT,
        state TEXT DEFAULT 'ACTIVE',
        vendor TEXT,
        vpr_score REAL
      )`, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  });

  await new Promise((resolve, reject) => {
    testDb.run(`CREATE TABLE IF NOT EXISTS vulnerability_snapshots (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      import_id TEXT NOT NULL,
      hostname TEXT NOT NULL,
      cve TEXT,
      plugin_name TEXT,
      severity TEXT,
      description TEXT,
      first_detected TEXT,
      last_seen TEXT,
      state TEXT,
      vendor TEXT,
      import_timestamp TEXT DEFAULT CURRENT_TIMESTAMP
    )`, (err) => {
      if (err) reject(err);
      else resolve();
    });
  });
});

afterAll(async () => {
  if (testDb) {
    await new Promise((resolve) => {
      testDb.close(resolve);
    });
  }
});

beforeEach(async () => {
  // Clear tables before each test
  await new Promise((resolve) => {
    testDb.serialize(() => {
      testDb.run('DELETE FROM vulnerabilities_current');
      testDb.run('DELETE FROM vulnerability_snapshots', resolve);
    });
  });
});

describe('Vulnerability CSV Import Integration', () => {
  
  describe('CSV Parsing', () => {
    test('parses basic CSV file correctly', async () => {
      const csvPath = path.join(__dirname, '../fixtures/test-vulnerabilities-basic.csv');
      const csvContent = fs.readFileSync(csvPath, 'utf8');
      
      const result = Papa.parse(csvContent, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (header) => header.trim()
      });

      expect(result.errors).toHaveLength(0);
      expect(result.data).toHaveLength(4);
      expect(result.data[0]).toHaveProperty('hostname', 'device-001.company.local');
      expect(result.data[0]).toHaveProperty('cve', 'CVE-2024-0001');
      expect(result.data[0]).toHaveProperty('severity', 'Critical');
    });

    test('handles edge cases in CSV parsing', async () => {
      const csvPath = path.join(__dirname, '../fixtures/test-vulnerabilities-edge-cases.csv');
      const csvContent = fs.readFileSync(csvPath, 'utf8');
      
      const result = Papa.parse(csvContent, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (header) => header.trim()
      });

      expect(result.errors).toHaveLength(0);
      
      // Check handling of special characters
      const unicodeRecord = result.data.find(r => r.hostname === 'device-unicode-ñ.local');
      expect(unicodeRecord).toBeDefined();
      expect(unicodeRecord.description).toContain('ñáéíóú');
      
      // Check handling of empty CVE
      const emptyCveRecord = result.data.find(r => r.hostname === 'device-empty-cve');
      expect(emptyCveRecord).toBeDefined();
      expect(emptyCveRecord.cve).toBe('');
      
      // Check handling of commas and quotes
      const commaRecord = result.data.find(r => r.hostname === 'device with spaces.local');
      expect(commaRecord).toBeDefined();
      expect(commaRecord.plugin_name).toBe('Plugin, with commas');
      expect(commaRecord.description).toContain('"quotes"');
    });

    test('processes large CSV datasets efficiently', async () => {
      const csvPath = path.join(__dirname, '../fixtures/test-vulnerabilities-large-dataset.csv');
      const csvContent = fs.readFileSync(csvPath, 'utf8');
      
      const startTime = Date.now();
      const result = Papa.parse(csvContent, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (header) => header.trim()
      });
      const parseTime = Date.now() - startTime;

      expect(result.errors).toHaveLength(0);
      expect(result.data).toHaveLength(1000);
      expect(parseTime).toBeLessThan(1000); // Should parse 1000 records in < 1 second
    });
  });

  describe('Hostname Normalization', () => {
    const normalizeHostname = (hostname) => {
      if (!hostname) return '';
      return hostname.split('.')[0].toLowerCase();
    };

    test('normalizes hostnames correctly', () => {
      expect(normalizeHostname('device-001.company.local')).toBe('device-001');
      expect(normalizeHostname('SERVER.DOMAIN.COM')).toBe('server');
      expect(normalizeHostname('192.168.1.100')).toBe('192');
      expect(normalizeHostname('')).toBe('');
    });

    test('handles edge case hostnames', () => {
      expect(normalizeHostname('device with spaces.local')).toBe('device with spaces');
      expect(normalizeHostname('device-unicode-ñ.local')).toBe('device-unicode-ñ');
    });
  });

  describe('Vulnerability Deduplication Logic', () => {
    const createDeduplicationKey = (hostname, cve, plugin_name, plugin_id) => {
      const normalizedHostname = hostname ? hostname.split('.')[0].toLowerCase() : '';
      if (cve && cve.trim()) {
        return `${normalizedHostname}|${cve.trim()}`;
      }
      return `${normalizedHostname}|${plugin_id || plugin_name || 'unknown'}`;
    };

    test('creates correct deduplication keys', () => {
      expect(createDeduplicationKey('device-001.local', 'CVE-2024-0001')).toBe('device-001|CVE-2024-0001');
      expect(createDeduplicationKey('device-002', '', 'Test Plugin', '12345')).toBe('device-002|12345');
      expect(createDeduplicationKey('device-003', '', 'Test Plugin')).toBe('device-003|Test Plugin');
    });

    test('handles duplicate vulnerabilities correctly', () => {
      const vulnerabilities = [
        { hostname: 'device-001.local', cve: 'CVE-2024-0001', severity: 'Critical' },
        { hostname: 'device-001.local', cve: 'CVE-2024-0001', severity: 'High' }, // Duplicate - different severity
        { hostname: 'device-002.local', cve: 'CVE-2024-0001', severity: 'Critical' } // Different device
      ];

      const dedupMap = new Map();
      
      vulnerabilities.forEach(vuln => {
        const key = createDeduplicationKey(vuln.hostname, vuln.cve);
        if (!dedupMap.has(key)) {
          dedupMap.set(key, vuln);
        } else {
          // Update with latest data (rollover logic)
          dedupMap.set(key, { ...dedupMap.get(key), ...vuln });
        }
      });

      expect(dedupMap.size).toBe(2); // Two unique vulnerabilities
      expect(dedupMap.get('device-001|CVE-2024-0001').severity).toBe('High'); // Latest wins
    });
  });

  describe('Database Integration', () => {
    const insertVulnerability = (vuln) => {
      return new Promise((resolve, reject) => {
        const stmt = testDb.prepare(`INSERT INTO vulnerabilities_current 
          (hostname, cve, plugin_name, severity, description, first_detected, last_seen, state, vendor)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`);
        
        stmt.run([
          vuln.hostname,
          vuln.cve,
          vuln.plugin_name,
          vuln.severity,
          vuln.description,
          vuln.first_detected,
          vuln.last_seen,
          vuln.state,
          vuln.vendor
        ], function(err) {
          stmt.finalize();
          if (err) reject(err);
          else resolve(this.lastID);
        });
      });
    };

    const getVulnerabilities = () => {
      return new Promise((resolve, reject) => {
        testDb.all('SELECT * FROM vulnerabilities_current ORDER BY id', (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });
    };

    test('inserts vulnerability data correctly', async () => {
      const testVuln = {
        hostname: 'device-001.local',
        cve: 'CVE-2024-0001',
        plugin_name: 'Test Plugin',
        severity: 'Critical',
        description: 'Test vulnerability',
        first_detected: '2024-09-01T10:00:00Z',
        last_seen: '2024-09-07T10:00:00Z',
        state: 'ACTIVE',
        vendor: 'CISCO'
      };

      const id = await insertVulnerability(testVuln);
      expect(id).toBeGreaterThan(0);

      const vulnerabilities = await getVulnerabilities();
      expect(vulnerabilities).toHaveLength(1);
      expect(vulnerabilities[0]).toMatchObject(testVuln);
    });

    test('handles batch inserts efficiently', async () => {
      const vulnerabilities = [];
      for (let i = 1; i <= 100; i++) {
        vulnerabilities.push({
          hostname: `device-${i.toString().padStart(3, '0')}.local`,
          cve: `CVE-2024-${i.toString().padStart(4, '0')}`,
          plugin_name: `Test Plugin ${i}`,
          severity: ['Critical', 'High', 'Medium', 'Low'][i % 4],
          description: `Test vulnerability ${i}`,
          first_detected: '2024-09-01T10:00:00Z',
          last_seen: '2024-09-07T10:00:00Z',
          state: 'ACTIVE',
          vendor: 'Test'
        });
      }

      const startTime = Date.now();
      
      // Use transaction for batch insert
      await new Promise((resolve, reject) => {
        testDb.run('BEGIN TRANSACTION', (err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      for (const vuln of vulnerabilities) {
        await insertVulnerability(vuln);
      }

      await new Promise((resolve, reject) => {
        testDb.run('COMMIT', (err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      const insertTime = Date.now() - startTime;
      
      const storedVulns = await getVulnerabilities();
      expect(storedVulns).toHaveLength(100);
      expect(insertTime).toBeLessThan(1000); // Should insert 100 records in < 1 second
    });
  });

  describe('Complete Import Workflow', () => {
    const simulateCompleteImport = async (csvPath) => {
      // 1. Parse CSV
      const csvContent = fs.readFileSync(csvPath, 'utf8');
      const parseResult = Papa.parse(csvContent, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (header) => header.trim()
      });

      if (parseResult.errors.length > 0) {
        throw new Error('CSV parsing failed');
      }

      // 2. Process and deduplicate
      const dedupMap = new Map();
      parseResult.data.forEach(row => {
        const key = `${row.hostname?.split('.')[0]?.toLowerCase() || ''}|${row.cve || row.plugin_name || 'unknown'}`;
        dedupMap.set(key, row);
      });

      // 3. Insert into database
      await new Promise((resolve, reject) => {
        testDb.run('BEGIN TRANSACTION', (err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      try {
        for (const vuln of dedupMap.values()) {
          await insertVulnerability({
            hostname: vuln.hostname || '',
            cve: vuln.cve || '',
            plugin_name: vuln.plugin_name || '',
            severity: vuln.severity || 'Unknown',
            description: vuln.description || '',
            first_detected: vuln.first_detected || new Date().toISOString(),
            last_seen: vuln.last_seen || new Date().toISOString(),
            state: vuln.state || 'ACTIVE',
            vendor: vuln.vendor || 'Unknown'
          });
        }

        await new Promise((resolve, reject) => {
          testDb.run('COMMIT', (err) => {
            if (err) reject(err);
            else resolve();
          });
        });

        return dedupMap.size;
      } catch (error) {
        await new Promise((resolve) => {
          testDb.run('ROLLBACK', resolve);
        });
        throw error;
      }
    };

    const insertVulnerability = (vuln) => {
      return new Promise((resolve, reject) => {
        const stmt = testDb.prepare(`INSERT INTO vulnerabilities_current 
          (hostname, cve, plugin_name, severity, description, first_detected, last_seen, state, vendor)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`);
        
        stmt.run([
          vuln.hostname, vuln.cve, vuln.plugin_name, vuln.severity,
          vuln.description, vuln.first_detected, vuln.last_seen, vuln.state, vuln.vendor
        ], function(err) {
          stmt.finalize();
          if (err) reject(err);
          else resolve(this.lastID);
        });
      });
    };

    test('processes basic CSV import end-to-end', async () => {
      const csvPath = path.join(__dirname, '../fixtures/test-vulnerabilities-basic.csv');
      const importedCount = await simulateCompleteImport(csvPath);
      
      expect(importedCount).toBe(4);
      
      const stored = await new Promise((resolve, reject) => {
        testDb.all('SELECT COUNT(*) as count FROM vulnerabilities_current', (err, rows) => {
          if (err) reject(err);
          else resolve(rows[0].count);
        });
      });
      
      expect(stored).toBe(4);
    });

    test('processes edge cases CSV import correctly', async () => {
      const csvPath = path.join(__dirname, '../fixtures/test-vulnerabilities-edge-cases.csv');
      const importedCount = await simulateCompleteImport(csvPath);
      
      // Should have 6 unique records (one duplicate CVE-2024-1004)
      expect(importedCount).toBe(6);
      
      const stored = await new Promise((resolve, reject) => {
        testDb.all('SELECT COUNT(*) as count FROM vulnerabilities_current', (err, rows) => {
          if (err) reject(err);
          else resolve(rows[0].count);
        });
      });
      
      expect(stored).toBe(6);
    });

    test('handles large dataset import within performance limits', async () => {
      const csvPath = path.join(__dirname, '../fixtures/test-vulnerabilities-large-dataset.csv');
      const startTime = Date.now();
      const importedCount = await simulateCompleteImport(csvPath);
      const totalTime = Date.now() - startTime;
      
      expect(importedCount).toBe(1000);
      expect(totalTime).toBeLessThan(5000); // Should process 1000 records in < 5 seconds
      
      const stored = await new Promise((resolve, reject) => {
        testDb.all('SELECT COUNT(*) as count FROM vulnerabilities_current', (err, rows) => {
          if (err) reject(err);
          else resolve(rows[0].count);
        });
      });
      
      expect(stored).toBe(1000);
    });
  });
});