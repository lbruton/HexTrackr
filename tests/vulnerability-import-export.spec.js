const { test, expect: _expect } = require("@playwright/test");
const _path = require("path");

test.describe("HexTrackr Vulnerability Import/Export Pipeline", () => {
    test.beforeEach(async ({ page }) => {
        // Navigate to the vulnerabilities page
        await page.goto("http://localhost:8080/vulnerabilities.html");
        await page.waitForLoadState("networkidle");
    });

    test("should import Cisco vulnerabilities CSV correctly", async ({ page }) => {
        // Step 1: Clear existing data (if needed)
        // Note: In a real test, we'd want a clean database state
        
        // Step 2: Import Cisco CSV
        const fileInput = page.locator("input[type=\"file\"]");
        await fileInput.setInputFiles("sample-data/vulnerabilities-cisco.csv");
        
        // Wait for import to complete
        await page.waitForSelector(".toast", { timeout: 10000 });
        
        // Step 3: Verify import success message
        const toast = page.locator(".toast");
        await expect(toast).toContainText("Import completed successfully");
        
        // Step 4: Check table data
        await page.waitForSelector(".ag-grid-wrapper", { timeout: 5000 });
        
        // Verify we have data rows
        const rows = page.locator(".ag-row");
        await expect(rows.first()).toBeVisible();
        
        // Step 5: Verify field mapping is correct
        const firstRow = rows.first();
        
        // Check Vulnerability column shows CVE ID (not full description)
        const vulnColumn = firstRow.locator("[col-id=\"cve\"]");
        const vulnText = await vulnColumn.textContent();
        expect(vulnText).toMatch(/^CVE-\d{4}-\d+|cisco-sa-|Plugin \d+/);
        
        // Check Description column shows full text (not CVE ID)
        const descColumn = firstRow.locator("[col-id=\"plugin_name\"]");
        const descText = await descColumn.textContent();
        expect(descText.length).toBeGreaterThan(20); // Full description should be longer
        expect(descText).not.toMatch(/^CVE-\d{4}-\d+$/); // Should not be just a CVE ID
        
        // Step 6: Verify hostname normalization
        const hostnameColumn = firstRow.locator("[col-id=\"hostname\"]");
        const hostnameText = await hostnameColumn.textContent();
        expect(hostnameText).not.toContain("."); // Should be normalized (no domain)
        
        // Step 7: Verify vendor grouping
        const vendorColumn = firstRow.locator("[col-id=\"vendor\"]");
        const vendorText = await vendorColumn.textContent();
        expect(["CISCO", "Palo Alto", "Other"]).toContain(vendorText);
    });

    test("should aggregate all affected devices in vulnerability modal", async ({ page }) => {
        // Step 1: Import test data first
        const fileInput = page.locator("input[type=\"file\"]");
        await fileInput.setInputFiles("sample-data/vulnerabilities-cisco.csv");
        await page.waitForSelector(".toast", { timeout: 10000 });
        
        // Step 2: Click on a vulnerability description to open modal
        const descCell = page.locator("[col-id=\"plugin_name\"]").first();
        await descCell.click();
        
        // Step 3: Wait for modal to open
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        // Step 4: Check that modal shows multiple affected devices
        const modalGrid = page.locator("#vuln-affected-assets-grid");
        await expect(modalGrid).toBeVisible();
        
        // Step 5: Count affected assets - should be more than 1 if multiple devices have same vulnerability
        const assetRows = modalGrid.locator(".ag-row");
        const rowCount = await assetRows.count();
        
        // Step 6: Verify the count matches what we expect from the data
        // Note: This would need to be adjusted based on actual test data
        expect(rowCount).toBeGreaterThan(0);
        
        // Step 7: Verify modal displays correct information
        const vulnId = page.locator("#vulnInfo .fw-bold").first();
        await expect(vulnId).toBeVisible();
        
        // Step 8: Verify Plugin Name vs Description are different in modal
        const pluginName = page.locator("#vulnInfo").getByText("Plugin Name:").locator("..").locator(".fw-bold");
        const description = page.locator("#vulnInfo").getByText("Description:").locator("..").locator("small");
        
        const pluginText = await pluginName.textContent();
        const descText = await description.textContent();
        
        // Plugin name should be short (CVE/Cisco SA), description should be long
        expect(pluginText.length).toBeLessThan(descText.length);
    });

    test("should handle different CSV formats correctly", async ({ page }) => {
        const testFiles = [
            "test-scenario-1-without-cve.csv",
            "test-scenario-2-with-cve.csv",
            "sample-data/vulnerabilities-cisco.csv"
        ];
        
        for (const fileName of testFiles) {
            // Import each file
            const fileInput = page.locator("input[type=\"file\"]");
            await fileInput.setInputFiles(fileName);
            
            // Wait for import
            await page.waitForSelector(".toast", { timeout: 10000 });
            
            // Verify no errors
            const toast = page.locator(".toast");
            const toastText = await toast.textContent();
            expect(toastText).not.toContain("Error");
            expect(toastText).not.toContain("Failed");
        }
    });

    test("should preserve state tracking from CSV", async ({ page }) => {
        // Import CSV with state data
        const fileInput = page.locator("input[type=\"file\"]");
        await fileInput.setInputFiles("sample-data/vulnerabilities-cisco.csv");
        await page.waitForSelector(".toast", { timeout: 10000 });
        
        // Check that state information is preserved
        // This would need backend API call to verify states are correctly stored
        const response = await page.request.get("http://localhost:8080/api/vulnerabilities");
        const data = await response.json();
        
        expect(data.vulnerabilities).toBeDefined();
        expect(data.vulnerabilities.length).toBeGreaterThan(0);
        
        // Verify states are properly set
        const states = data.vulnerabilities.map(v => v.state || v.lifecycle_state);
        expect(states).toContain("ACTIVE");
    });

    test("should export vulnerabilities correctly", async ({ page }) => {
        // Step 1: Import data first
        const fileInput = page.locator("input[type=\"file\"]");
        await fileInput.setInputFiles("sample-data/vulnerabilities-cisco.csv");
        await page.waitForSelector(".toast", { timeout: 10000 });
        
        // Step 2: Click export button
        const exportBtn = page.locator("button:has-text(\"Export\")");
        await exportBtn.click();
        
        // Step 3: Wait for download
        const downloadPromise = page.waitForEvent("download");
        const download = await downloadPromise;
        
        // Step 4: Verify download
        expect(download.suggestedFilename()).toContain(".csv");
        
        // Step 5: Save and verify file content
        const path = await download.path();
        expect(path).toBeTruthy();
    });

    test("should handle cards view correctly after import", async ({ page }) => {
        // Import data
        const fileInput = page.locator("input[type=\"file\"]");
        await fileInput.setInputFiles("sample-data/vulnerabilities-cisco.csv");
        await page.waitForSelector(".toast", { timeout: 10000 });
        
        // Switch to cards view
        const cardsBtn = page.locator("button:has-text(\"Vulnerabilities\")");
        await cardsBtn.click();
        
        // Wait for cards to load
        await page.waitForSelector(".vulnerability-card", { timeout: 5000 });
        
        // Verify cards are grouped properly
        const cards = page.locator(".vulnerability-card");
        const cardCount = await cards.count();
        expect(cardCount).toBeGreaterThan(0);
        
        // Click on a card and verify modal opens with multiple devices
        await cards.first().click();
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        const assetGrid = page.locator("#vuln-affected-assets-grid");
        await expect(assetGrid).toBeVisible();
    });
});