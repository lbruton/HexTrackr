/**
 * @fileoverview Contract tests for vulnerability trends API
 * @description Tests the API contract for vulnerability trend data retrieval
 * These tests should FAIL initially as implementation doesn't exist yet
 */

/* global describe, it, expect, beforeAll, afterAll */

const request = require("supertest");
const app = require("../../app/public/server");

describe("Vulnerability Trends API Contract", () => {
    let server;

    beforeAll(() => {
        server = app.listen(0); // Random port for testing
    });

    afterAll((done) => {
        server.close(done);
    });

    describe("GET /api/vulnerabilities/trends", () => {
        it("should return trend data with default parameters", async () => {
            const response = await request(server)
                .get("/api/vulnerabilities/trends")
                .expect(200);

            expect(response.body).toHaveProperty("success", true);
            expect(response.body).toHaveProperty("data");
            expect(Array.isArray(response.body.data)).toBe(true);

            // Validate data structure
            if (response.body.data.length > 0) {
                const dataPoint = response.body.data[0];
                expect(dataPoint).toHaveProperty("timestamp");
                expect(dataPoint).toHaveProperty("critical");
                expect(dataPoint).toHaveProperty("high");
                expect(dataPoint).toHaveProperty("medium");
                expect(dataPoint).toHaveProperty("low");

                // Validate data types
                expect(typeof dataPoint.timestamp).toBe("string");
                expect(typeof dataPoint.critical).toBe("number");
                expect(typeof dataPoint.high).toBe("number");
                expect(typeof dataPoint.medium).toBe("number");
                expect(typeof dataPoint.low).toBe("number");

                // Validate non-negative values
                expect(dataPoint.critical).toBeGreaterThanOrEqual(0);
                expect(dataPoint.high).toBeGreaterThanOrEqual(0);
                expect(dataPoint.medium).toBeGreaterThanOrEqual(0);
                expect(dataPoint.low).toBeGreaterThanOrEqual(0);
            }
        });

        it("should accept valid range parameter", async () => {
            const validRanges = ["7d", "30d", "90d", "1y", "all"];

            for (const range of validRanges) {
                const response = await request(server)
                    .get(`/api/vulnerabilities/trends?range=${range}`)
                    .expect(200);

                expect(response.body.success).toBe(true);
                expect(response.body.data).toBeDefined();
            }
        });

        it("should accept valid groupBy parameter", async () => {
            const validGroupings = ["day", "week", "month"];

            for (const groupBy of validGroupings) {
                const response = await request(server)
                    .get(`/api/vulnerabilities/trends?groupBy=${groupBy}`)
                    .expect(200);

                expect(response.body.success).toBe(true);
                expect(response.body.data).toBeDefined();
            }
        });

        it("should return 400 for invalid range parameter", async () => {
            const response = await request(server)
                .get("/api/vulnerabilities/trends?range=invalid")
                .expect(400);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBeDefined();
        });

        it("should return 400 for invalid groupBy parameter", async () => {
            const response = await request(server)
                .get("/api/vulnerabilities/trends?groupBy=invalid")
                .expect(400);

            expect(response.body.success).toBe(false);
            expect(response.body.error).toBeDefined();
        });

        it("should include VPR sum fields when available", async () => {
            const response = await request(server)
                .get("/api/vulnerabilities/trends")
                .expect(200);

            if (response.body.data.length > 0) {
                const dataPoint = response.body.data[0];

                // VPR fields are optional but if present must be numbers
                if (dataPoint.criticalVpr !== undefined) {
                    expect(typeof dataPoint.criticalVpr).toBe("number");
                    expect(dataPoint.criticalVpr).toBeGreaterThanOrEqual(0);
                }
                if (dataPoint.highVpr !== undefined) {
                    expect(typeof dataPoint.highVpr).toBe("number");
                    expect(dataPoint.highVpr).toBeGreaterThanOrEqual(0);
                }
                if (dataPoint.mediumVpr !== undefined) {
                    expect(typeof dataPoint.mediumVpr).toBe("number");
                    expect(dataPoint.mediumVpr).toBeGreaterThanOrEqual(0);
                }
                if (dataPoint.lowVpr !== undefined) {
                    expect(typeof dataPoint.lowVpr).toBe("number");
                    expect(dataPoint.lowVpr).toBeGreaterThanOrEqual(0);
                }
            }
        });

        it("should return chronologically ordered data", async () => {
            const response = await request(server)
                .get("/api/vulnerabilities/trends")
                .expect(200);

            const { data } = response.body;

            if (data.length > 1) {
                for (let i = 1; i < data.length; i++) {
                    const prevDate = new Date(data[i - 1].timestamp);
                    const currDate = new Date(data[i].timestamp);
                    expect(currDate.getTime()).toBeGreaterThan(prevDate.getTime());
                }
            }
        });
    });
});