const { test, expect } = require("@playwright/test");

test.describe("Vulnerability Accessibility - WCAG Compliance", () => {
    test.beforeEach(async ({ page }) => {
        await page.goto("http://localhost:8989/vulnerabilities.html");
    });

    /**
     * Calculate contrast ratio between two RGB colors
     * Based on WCAG 2.1 formula
     */
    function getContrastRatio(rgb1, rgb2) {
        // Parse RGB values
        const parseRgb = (rgb) => {
            const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                return {
                    r: parseInt(match[1]),
                    g: parseInt(match[2]),
                    b: parseInt(match[3])
                };
            }
            return null;
        };

        const color1 = parseRgb(rgb1);
        const color2 = parseRgb(rgb2);

        if (!color1 || !color2) {return 0;}

        // Calculate relative luminance
        const getLuminance = (color) => {
            const sRGB = [color.r / 255, color.g / 255, color.b / 255];
            const linear = sRGB.map(val => {
                if (val <= 0.03928) {
                    return val / 12.92;
                } else {
                    return Math.pow((val + 0.055) / 1.055, 2.4);
                }
            });
            return 0.2126 * linear[0] + 0.7152 * linear[1] + 0.0722 * linear[2];
        };

        const lum1 = getLuminance(color1);
        const lum2 = getLuminance(color2);

        // Calculate contrast ratio
        const lighter = Math.max(lum1, lum2);
        const darker = Math.min(lum1, lum2);
        return (lighter + 0.05) / (darker + 0.05);
    }

    test("Light mode text meets WCAG AA contrast requirements", async ({ page }) => {
        // Set to light mode
        await page.evaluate(() => {
            document.body.setAttribute("data-theme", "light");
        });
        await page.waitForTimeout(100);

        // Test each severity color against white background
        const contrastTests = await page.evaluate(() => {
            const getElementColors = (selector) => {
                const element = document.querySelector(selector);
                if (!element) {return null;}

                const textColor = window.getComputedStyle(element).color;
                const bgColor = window.getComputedStyle(element.closest(".card")).backgroundColor;
                return { text: textColor, bg: bgColor };
            };

            return {
                critical: getElementColors(".card:has-text('Critical') .text-vpr-critical"),
                high: getElementColors(".card:has-text('High') .text-vpr-high"),
                medium: getElementColors(".card:has-text('Medium') .text-vpr-medium"),
                low: getElementColors(".card:has-text('Low') .text-vpr-low")
            };
        });

        // Check contrast ratios (WCAG AA requires 4.5:1 for normal text)
        const WCAG_AA_NORMAL = 4.5;

        for (const [severity, colors] of Object.entries(contrastTests)) {
            if (colors) {
                const ratio = getContrastRatio(colors.text, colors.bg);
                console.log(`${severity} contrast ratio:`, ratio);

                // All text should meet WCAG AA standard
                expect(ratio).toBeGreaterThanOrEqual(WCAG_AA_NORMAL);
            }
        }
    });

    test("Dark mode text meets WCAG AA contrast requirements", async ({ page }) => {
        // Set to dark mode
        await page.evaluate(() => {
            document.body.setAttribute("data-theme", "dark");
        });
        await page.waitForTimeout(100);

        // Test each severity color against dark background
        const contrastTests = await page.evaluate(() => {
            const getElementColors = (selector) => {
                const element = document.querySelector(selector);
                if (!element) {return null;}

                const textColor = window.getComputedStyle(element).color;
                const bgColor = window.getComputedStyle(element.closest(".card")).backgroundColor;
                return { text: textColor, bg: bgColor };
            };

            return {
                critical: getElementColors(".card:has-text('Critical') .text-vpr-critical"),
                high: getElementColors(".card:has-text('High') .text-vpr-high"),
                medium: getElementColors(".card:has-text('Medium') .text-vpr-medium"),
                low: getElementColors(".card:has-text('Low') .text-vpr-low")
            };
        });

        // Check contrast ratios
        const WCAG_AA_NORMAL = 4.5;

        for (const [severity, colors] of Object.entries(contrastTests)) {
            if (colors) {
                const ratio = getContrastRatio(colors.text, colors.bg);
                console.log(`${severity} dark mode contrast ratio:`, ratio);

                // All text should meet WCAG AA standard
                expect(ratio).toBeGreaterThanOrEqual(WCAG_AA_NORMAL);
            }
        }
    });

    test("Large text meets WCAG AA requirements", async ({ page }) => {
        // Large text (18pt or 14pt bold) only needs 3:1 contrast ratio
        const WCAG_AA_LARGE = 3.0;

        // Check stat card numbers (which are large text)
        const largeTextContrast = await page.evaluate(() => {
            const getElementColors = (selector) => {
                const element = document.querySelector(selector);
                if (!element) {return null;}

                const textColor = window.getComputedStyle(element).color;
                const bgColor = window.getComputedStyle(element.closest(".card")).backgroundColor;
                const fontSize = window.getComputedStyle(element).fontSize;
                return { text: textColor, bg: bgColor, size: fontSize };
            };

            // Get the large count numbers in stat cards
            return {
                critical: getElementColors(".card:has-text('Critical') .h1"),
                high: getElementColors(".card:has-text('High') .h1"),
                medium: getElementColors(".card:has-text('Medium') .h1"),
                low: getElementColors(".card:has-text('Low') .h1")
            };
        });

        for (const [severity, colors] of Object.entries(largeTextContrast)) {
            if (colors) {
                const ratio = getContrastRatio(colors.text, colors.bg);
                console.log(`${severity} large text contrast ratio:`, ratio, `(size: ${colors.size})`);

                // Large text should meet WCAG AA standard (3:1)
                expect(ratio).toBeGreaterThanOrEqual(WCAG_AA_LARGE);
            }
        }
    });

    test("Icons have sufficient contrast", async ({ page }) => {
        // Icons and graphical objects need 3:1 contrast ratio
        const WCAG_AA_GRAPHICS = 3.0;

        // Test icon colors
        const iconContrast = await page.evaluate(() => {
            const getElementColors = (selector) => {
                const element = document.querySelector(selector);
                if (!element) {return null;}

                const iconColor = window.getComputedStyle(element).color;
                const bgColor = window.getComputedStyle(element.closest(".card")).backgroundColor;
                return { icon: iconColor, bg: bgColor };
            };

            return {
                critical: getElementColors(".card:has-text('Critical') .ti"),
                high: getElementColors(".card:has-text('High') .ti"),
                medium: getElementColors(".card:has-text('Medium') .ti"),
                low: getElementColors(".card:has-text('Low') .ti")
            };
        });

        for (const [severity, colors] of Object.entries(iconContrast)) {
            if (colors) {
                const ratio = getContrastRatio(colors.icon, colors.bg);
                console.log(`${severity} icon contrast ratio:`, ratio);

                // Icons should meet WCAG AA standard (3:1)
                expect(ratio).toBeGreaterThanOrEqual(WCAG_AA_GRAPHICS);
            }
        }
    });

    test("Orange color specifically meets WCAG requirements", async ({ page }) => {
        // Orange is the most problematic color for contrast
        // Test the adjusted orange color (#d97706) specifically

        await page.evaluate(() => {
            document.body.setAttribute("data-theme", "light");
        });
        await page.waitForTimeout(100);

        const orangeContrast = await page.evaluate(() => {
            const style = getComputedStyle(document.documentElement);
            const orangeColor = style.getPropertyValue("--vpr-high").trim();

            // Check against white background
            const testElement = document.createElement("div");
            testElement.style.color = orangeColor;
            testElement.style.backgroundColor = "#ffffff";
            document.body.appendChild(testElement);

            const computed = {
                text: window.getComputedStyle(testElement).color,
                bg: window.getComputedStyle(testElement).backgroundColor,
                cssVar: orangeColor
            };

            document.body.removeChild(testElement);
            return computed;
        });

        // Verify the orange color is the adjusted one for WCAG
        expect(orangeContrast.cssVar).toBe("#d97706");

        // Check contrast ratio
        const ratio = getContrastRatio(orangeContrast.text, orangeContrast.bg);
        console.log("Orange (#d97706) contrast against white:", ratio);

        // Should meet WCAG AA (4.5:1)
        expect(ratio).toBeGreaterThanOrEqual(4.5);
    });

    test("Color is not the only differentiator", async ({ page }) => {
        // Verify that elements have additional indicators beyond color

        const indicators = await page.evaluate(() => {
            const checkCard = (selector) => {
                const card = document.querySelector(selector);
                if (!card) {return null;}

                // Check for text labels
                const hasText = card.textContent.includes("Critical") ||
                    card.textContent.includes("High") ||
                    card.textContent.includes("Medium") ||
                    card.textContent.includes("Low");

                // Check for icons
                const hasIcon = card.querySelector(".ti") !== null;

                // Check for VPR score numbers
                const hasNumbers = card.querySelector(".h1") !== null;

                return {
                    hasText,
                    hasIcon,
                    hasNumbers
                };
            };

            return {
                critical: checkCard(".card:has-text('Critical')"),
                high: checkCard(".card:has-text('High')"),
                medium: checkCard(".card:has-text('Medium')"),
                low: checkCard(".card:has-text('Low')")
            };
        });

        // All cards should have multiple indicators
        for (const [severity, indicator] of Object.entries(indicators)) {
            if (indicator) {
                expect(indicator.hasText).toBeTruthy();
                expect(indicator.hasIcon).toBeTruthy();
                expect(indicator.hasNumbers).toBeTruthy();
            }
        }
    });

    test("Focus indicators are visible", async ({ page }) => {
        // Tab through interactive elements
        await page.keyboard.press("Tab");
        await page.keyboard.press("Tab");

        // Check if focus indicator is visible
        const focusVisible = await page.evaluate(() => {
            const activeElement = document.activeElement;
            if (!activeElement) {return false;}

            const outline = window.getComputedStyle(activeElement).outline;
            const boxShadow = window.getComputedStyle(activeElement).boxShadow;

            return outline !== "none" || boxShadow !== "none";
        });

        expect(focusVisible).toBeTruthy();
    });
});