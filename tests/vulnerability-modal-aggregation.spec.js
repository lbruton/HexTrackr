const { test, expect: _expect } = require("@playwright/test");

test.describe("HexTrackr Vulnerability Modal Aggregation Tests", () => {
    test.beforeEach(async ({ page }) => {
        // Navigate to the vulnerabilities page
        await page.goto("http://localhost:8080/vulnerabilities.html");
        await page.waitForLoadState("networkidle");
        
        // Wait for vulnerability data to load (either AG Grid or HTML table)
        await page.waitForSelector("table tbody tr, .ag-row", { timeout: 10000 });
    });

    test("should show multiple affected devices in vulnerability modal from table view", async ({ page }) => {
        // Wait for table data to load (HTML table fallback)
        await page.waitForSelector("table tbody tr", { timeout: 5000 });
        
        // Click on a vulnerability description to open modal (HTML table version)
        const descriptionCell = page.locator("table tbody tr td:nth-child(8) a").first();
        await descriptionCell.waitFor();
        await descriptionCell.click();
        
        // Wait for modal to open
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        // Check that modal shows affected assets grid (will be HTML table in modal)
        const modalGrid = page.locator("#vuln-affected-assets-grid");
        await expect(modalGrid).toBeVisible();
        
        // Verify we have rows in the affected assets grid (AG Grid should work in modal)
        const assetRows = modalGrid.locator(".ag-row, table tbody tr");
        await expect(assetRows.first()).toBeVisible();
        
        // Get the count of affected assets
        const rowCount = await assetRows.count();
        console.log(`Affected assets count: ${rowCount}`);
        
        // Verify the count display matches actual rows
        const countDisplay = page.locator("#affectedAssetsCount");
        const displayedCount = await countDisplay.textContent();
        expect(parseInt(displayedCount)).toBe(rowCount);
        
        // Verify we have more than one device if this is a shared vulnerability
        // (This test will pass with 1 or more, but logs the count for analysis)
        expect(rowCount).toBeGreaterThan(0);
        
        console.log(`Modal shows ${rowCount} affected assets`);
    });

    test("should show Plugin Name as CVE/Cisco ID, not full description", async ({ page }) => {
        // Wait for table data and open modal
        await page.waitForSelector(".ag-row", { timeout: 5000 });
        const descriptionCell = page.locator("[col-id=\"plugin_name\"] a").first();
        await descriptionCell.click();
        
        // Wait for modal to open
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        // Get Plugin Name field value
        const pluginNameValue = page.locator("#vulnInfo").getByText("Plugin Name:").locator("..").locator(".fw-bold");
        const pluginText = await pluginNameValue.textContent();
        
        // Get Description field value for comparison
        const descriptionValue = page.locator("#vulnInfo").getByText("Description:").locator("..").locator("small");
        const descText = await descriptionValue.textContent();
        
        console.log(`Plugin Name: "${pluginText}"`);
        console.log(`Description: "${descText}"`);
        
        // Plugin Name should be short (CVE, Cisco SA, or Plugin ID)
        expect(pluginText.length).toBeLessThan(descText.length);
        
        // Plugin Name should match expected patterns
        const isValidPluginName = 
            pluginText.startsWith("CVE-") || 
            pluginText.startsWith("cisco-sa-") || 
            pluginText.startsWith("Plugin ");
            
        expect(isValidPluginName).toBe(true);
    });

    test("should show correct aggregation from cards view", async ({ page }) => {
        // Switch to cards view
        const cardsButton = page.locator("button:has-text(\"Vulnerabilities\")");
        await cardsButton.click();
        
        // Wait for cards to load
        await page.waitForSelector(".vulnerability-card", { timeout: 5000 });
        
        // Click on first vulnerability card
        const firstCard = page.locator(".vulnerability-card").first();
        await firstCard.click();
        
        // Wait for modal to open
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        // Check affected assets grid
        const modalGrid = page.locator("#vuln-affected-assets-grid");
        await expect(modalGrid).toBeVisible();
        
        // Verify assets are listed
        const assetRows = modalGrid.locator(".ag-row");
        const rowCount = await assetRows.count();
        
        expect(rowCount).toBeGreaterThan(0);
        console.log(`Cards view modal shows ${rowCount} affected assets`);
    });

    test("should handle vulnerabilities with different matching keys", async ({ page }) => {
        // Test multiple different vulnerability types
        await page.waitForSelector(".ag-row", { timeout: 5000 });
        
        // Get all vulnerability description cells
        const descCells = page.locator("[col-id=\"plugin_name\"] a");
        const cellCount = await descCells.count();
        
        // Test first 3 vulnerabilities (or all if less than 3)
        const testCount = Math.min(cellCount, 3);
        
        for (let i = 0; i < testCount; i++) {
            console.log(`Testing vulnerability ${i + 1}`);
            
            // Click on vulnerability
            await descCells.nth(i).click();
            
            // Wait for modal
            await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
            
            // Check that we have affected assets
            const assetRows = page.locator("#vuln-affected-assets-grid .ag-row");
            const rowCount = await assetRows.count();
            
            expect(rowCount).toBeGreaterThan(0);
            
            // Verify Plugin Name is properly formatted
            const pluginNameValue = page.locator("#vulnInfo").getByText("Plugin Name:").locator("..").locator(".fw-bold");
            const pluginText = await pluginNameValue.textContent();
            
            console.log(`  Vulnerability ${i + 1}: Plugin Name = "${pluginText}", Assets = ${rowCount}`);
            
            // Close modal before next iteration
            const closeButton = page.locator("#vulnDetailsModal .btn-close");
            await closeButton.click();
            await page.waitForSelector("#vulnDetailsModal", { state: "hidden" });
        }
    });

    test("should show different devices than the launching row", async ({ page }) => {
        // This test verifies that the modal shows aggregated data, not just the launching device
        await page.waitForSelector(".ag-row", { timeout: 5000 });
        
        // Get hostname from first row
        const firstRow = page.locator(".ag-row").first();
        const firstRowHostname = await firstRow.locator("[col-id=\"hostname\"]").textContent();
        
        console.log(`Launching device: ${firstRowHostname}`);
        
        // Click on vulnerability description
        const descCell = firstRow.locator("[col-id=\"plugin_name\"] a");
        await descCell.click();
        
        // Wait for modal
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        // Get all hostnames in the modal
        const modalHostnames = page.locator("#vuln-affected-assets-grid [col-id=\"hostname\"]");
        const modalHostnameTexts = await modalHostnames.allTextContents();
        
        console.log(`Modal shows devices: ${modalHostnameTexts.join(", ")}`);
        
        // Verify the launching device is in the list
        expect(modalHostnameTexts).toContain(firstRowHostname);
        
        // If there are multiple devices, verify aggregation is working
        if (modalHostnameTexts.length > 1) {
            console.log(`✓ Proper aggregation: ${modalHostnameTexts.length} devices shown`);
            expect(modalHostnameTexts.length).toBeGreaterThan(1);
        } else {
            console.log(`ℹ Single device vulnerability: ${modalHostnameTexts.length} device`);
        }
    });

    test("should maintain consistency between device count and table rows", async ({ page }) => {
        await page.waitForSelector(".ag-row", { timeout: 5000 });
        
        // Open modal
        const descCell = page.locator("[col-id=\"plugin_name\"] a").first();
        await descCell.click();
        await page.waitForSelector("#vulnDetailsModal", { state: "visible" });
        
        // Get device count from summary card
        const deviceCountText = await page.locator(".card-body .h3").nth(1).textContent();
        const deviceCount = parseInt(deviceCountText);
        
        // Get actual rows in affected assets table
        const assetRows = page.locator("#vuln-affected-assets-grid .ag-row");
        const actualRowCount = await assetRows.count();
        
        console.log(`Summary card shows: ${deviceCount} devices`);
        console.log(`Assets grid shows: ${actualRowCount} rows`);
        
        // Counts should match
        expect(deviceCount).toBe(actualRowCount);
    });
});