<!-- Fragment template for documentation content injected by docs-tabler.js -->
<section class="doc-fragment">
    <h1>Testing Strategy and Playwright Integration</h1>
<p>HexTrackr uses a comprehensive testing strategy that emphasizes browser automation and user workflow validation. This guide covers the testing infrastructure and methodologies used to ensure application reliability and user experience.</p>
<h2>Testing Philosophy</h2>
<p>HexTrackr follows a <strong>test-first development philosophy</strong> where functionality is validated both before and after changes to prevent regression bugs and ensure consistent behavior:</p>
<ol>
<li><strong>Before Making Changes</strong>: Write Playwright test capturing current behavior</li>
<li><strong>Plan the Change</strong>: Write test for expected behavior after changes  </li>
<li><strong>Implement Changes</strong>: Make minimal changes to pass the new test</li>
<li><strong>Verify Both Tests Pass</strong>: Ensure original test still passes (no regressions)</li>
</ol>
<h2>Playwright Browser Automation</h2>
<h3>Core Testing Infrastructure</h3>
<p>HexTrackr uses Playwright for comprehensive browser automation testing, providing real-time validation of user workflows and UI functionality.</p>
<p><strong>Prerequisites</strong>:</p>
<ul>
<li>Docker container must be restarted before running tests: <code>docker-compose restart</code></li>
<li>Tests expect <code>http://localhost:8080</code> and clean container state</li>
<li>All tests designed to be idempotent and handle existing data gracefully</li>
</ul>
<p><strong>Running Tests</strong>:</p>
<pre><code class="language-bash">
# From inside or outside container

npx playwright test
</code></pre>
<h3>Modal Workflow Testing</h3>
<p>The modal system receives extensive testing to ensure proper aggregation and user experience:</p>
<h4>Vulnerability Modal Testing</h4>
<pre><code class="language-javascript">// Test vulnerability modal aggregation
test(&#39;vulnerability modal shows all affected devices&#39;, async ({ page }) =&gt; {
  // Navigate to vulnerability view
  await page.click(&#39;[data-test=&quot;vulnerabilities-view&quot;]&#39;);
  
  // Click on vulnerability (e.g., CVE-2017-3881)
  await page.click(&#39;.vulnerability-description&#39;);
  
  // Verify all 24 devices are shown
  const devices = await page.locator(&#39;.affected-assets-grid tr&#39;).count();
  expect(devices).toBe(24);
});
</code></pre>
<h4>Device Modal Testing</h4>
<pre><code class="language-javascript">// Test device modal aggregation  
test(&#39;device modal shows all vulnerabilities for device&#39;, async ({ page }) =&gt; {
  // Navigate to devices view
  await page.click(&#39;[data-test=&quot;devices-view&quot;]&#39;);
  
  // Click on device details (e.g., grimesnswan03)
  await page.click(&#39;[data-test=&quot;view-device-details&quot;]&#39;);
  
  // Verify all 12 vulnerabilities are shown
  const vulnerabilities = await page.locator(&#39;.device-vulnerabilities-grid tr&#39;).count();
  expect(vulnerabilities).toBe(12);
});
</code></pre>
<h4>Modal Layering Testing</h4>
<pre><code class="language-javascript">// Test proper modal transitions
test(&#39;modal layering works correctly&#39;, async ({ page }) =&gt; {
  // Open vulnerability modal
  await page.click(&#39;.vulnerability-description&#39;);
  
  // Click hostname link within vulnerability modal
  await page.click(&#39;.hostname-link&#39;);
  
  // Verify device modal opens and vulnerability modal closes
  await expect(page.locator(&#39;[data-modal=&quot;device&quot;]&#39;)).toBeVisible();
  await expect(page.locator(&#39;[data-modal=&quot;vulnerability&quot;]&#39;)).not.toBeVisible();
});
</code></pre>
<h3>Data Import/Export Testing</h3>
<p>Comprehensive testing of the CSV import pipeline and export functionality:</p>
<h4>Large Dataset Performance Testing</h4>
<pre><code class="language-javascript">// Test import performance with 10,000+ records
test(&#39;handles large CSV imports efficiently&#39;, async ({ page }) =&gt; {
  // Upload large CSV file
  await page.setInputFiles(&#39;input[type=&quot;file&quot;]&#39;, &#39;test-data/large-dataset-10k.csv&#39;);
  
  // Monitor processing progress
  await page.waitForSelector(&#39;.import-progress&#39;, { timeout: 60000 });
  
  // Verify successful completion
  await expect(page.locator(&#39;.import-success&#39;)).toBeVisible();
});
</code></pre>
<h4>CSV Format Validation</h4>
<pre><code class="language-javascript">// Test multiple CSV format support
test(&#39;processes different CSV formats correctly&#39;, async ({ page }) =&gt; {
  const formats = [&#39;cisco-legacy.csv&#39;, &#39;cisco-standard.csv&#39;, &#39;tenable-full.csv&#39;];
  
  for (const format of formats) {
    await page.setInputFiles(&#39;input[type=&quot;file&quot;]&#39;, `test-data/${format}`);
    await expect(page.locator(&#39;.import-success&#39;)).toBeVisible();
  }
});
</code></pre>
<h3>Responsive Design Testing</h3>
<p>Validation of UI behavior across different viewport sizes:</p>
<h4>Mobile Responsiveness</h4>
<pre><code class="language-javascript">// Test modal behavior on mobile devices
test(&#39;modals work correctly on mobile&#39;, async ({ page }) =&gt; {
  // Set mobile viewport
  await page.setViewportSize({ width: 375, height: 667 });
  
  // Test vulnerability modal
  await page.click(&#39;.vulnerability-description&#39;);
  
  // Verify modal displays properly
  await expect(page.locator(&#39;.modal&#39;)).toBeVisible();
  await expect(page.locator(&#39;.modal&#39;)).toHaveCSS(&#39;width&#39;, &#39;100%&#39;);
});
</code></pre>
<h4>Tablet and Desktop Testing</h4>
<pre><code class="language-javascript">// Test across different screen sizes
test(&#39;UI adapts to different screen sizes&#39;, async ({ page }) =&gt; {
  const viewports = [
    { width: 768, height: 1024 },  // Tablet
    { width: 1920, height: 1080 }, // Desktop
  ];
  
  for (const viewport of viewports) {
    await page.setViewportSize(viewport);
    // Verify layout adjustments
    await expect(page.locator(&#39;.dashboard-container&#39;)).toBeVisible();
  }
});
</code></pre>
<h3>Performance and Accessibility Testing</h3>
<h4>Console Error Monitoring</h4>
<pre><code class="language-javascript">// Monitor for JavaScript errors
test(&#39;application runs without console errors&#39;, async ({ page }) =&gt; {
  const errors = [];
  page.on(&#39;console&#39;, msg =&gt; {
    if (msg.type() === &#39;error&#39;) errors.push(msg.text());
  });
  
  // Perform typical user workflow
  await page.click(&#39;.vulnerability-view&#39;);
  await page.click(&#39;.device-view&#39;);
  
  // Verify no errors occurred
  expect(errors).toHaveLength(0);
});
</code></pre>
<h4>Network Request Validation</h4>
<pre><code class="language-javascript">// Test API endpoint responses
test(&#39;API endpoints respond correctly&#39;, async ({ page }) =&gt; {
  // Monitor network requests
  const responses = [];
  page.on(&#39;response&#39;, response =&gt; {
    if (response.url().includes(&#39;/api/&#39;)) {
      responses.push(response);
    }
  });
  
  // Trigger API calls
  await page.click(&#39;[data-test=&quot;refresh-data&quot;]&#39;);
  
  // Verify successful responses
  expect(responses.every(r =&gt; r.status() &lt; 400)).toBeTruthy();
});
</code></pre>
<h4>Accessibility Testing</h4>
<pre><code class="language-javascript">// Test accessibility compliance
test(&#39;application meets accessibility standards&#39;, async ({ page }) =&gt; {
  // Use Playwright&#39;s accessibility features
  const snapshot = await page.accessibility.snapshot();
  
  // Verify accessible elements exist
  expect(snapshot).toHaveProperty(&#39;role&#39;);
  expect(snapshot.children).toBeDefined();
});
</code></pre>
<h2>Testing Data Management</h2>
<h3>Test Data Organization</h3>
<p><strong>Test Data Location</strong>: <code>/test-data/</code></p>
<ul>
<li><code>large-dataset-10k.csv</code> - Performance testing dataset</li>
<li><code>cisco-legacy.csv</code> - Legacy format validation</li>
<li><code>cisco-standard.csv</code> - Standard format validation  </li>
<li><code>tenable-full.csv</code> - Comprehensive format validation</li>
</ul>
<h3>Screenshot and Visual Evidence</h3>
<p><strong>Screenshot Management</strong>: <code>.playwright-mcp/</code></p>
<ul>
<li>Automated screenshot capture for test validation</li>
<li>Before/after comparison images for UI changes</li>
<li>Mobile/tablet/desktop responsive testing evidence</li>
<li>Modal workflow visual verification</li>
</ul>
<h3>Database State Management</h3>
<pre><code class="language-javascript">// Reset database state between tests
test.beforeEach(async ({ page }) =&gt; {
  // Clear any existing modals
  await page.evaluate(() =&gt; {
    document.querySelectorAll(&#39;.modal&#39;).forEach(modal =&gt; {
      if (modal.classList.contains(&#39;show&#39;)) {
        bootstrap.Modal.getInstance(modal)?.hide();
      }
    });
  });
});
</code></pre>
<h2>Modal Architecture Testing Patterns</h2>
<h3>Universal Aggregation Key Testing</h3>
<p>The modal system uses description field as the universal aggregation key. Tests validate this pattern:</p>
<pre><code class="language-javascript">// Test description-based aggregation
test(&#39;modal aggregation uses description field consistently&#39;, async ({ page }) =&gt; {
  // Get vulnerability description from table
  const description = await page.locator(&#39;.vulnerability-description&#39;).first().textContent();
  
  // Open modal
  await page.click(&#39;.vulnerability-description&#39;);
  
  // Verify all devices with same description are shown
  const modalDescription = await page.locator(&#39;.modal-vulnerability-description&#39;).textContent();
  expect(modalDescription).toBe(description);
  
  // Count should match aggregated total
  const deviceCount = await page.locator(&#39;.affected-device-row&#39;).count();
  expect(deviceCount).toBeGreaterThan(1); // Should be aggregated
});
</code></pre>
<h3>Bootstrap Modal Instance Testing</h3>
<p>Validation of proper modal state management:</p>
<pre><code class="language-javascript">// Test Bootstrap modal instance management
test(&#39;modal transitions use proper Bootstrap integration&#39;, async ({ page }) =&gt; {
  // Inject modal state monitoring
  await page.addInitScript(() =&gt; {
    window.modalTransitions = [];
    const originalGetInstance = bootstrap.Modal.getInstance;
    bootstrap.Modal.getInstance = function(element) {
      window.modalTransitions.push({
        action: &#39;getInstance&#39;,
        element: element.id || element.className,
        timestamp: Date.now()
      });
      return originalGetInstance(element);
    };
  });
  
  // Perform modal transition
  await page.click(&#39;.vulnerability-description&#39;);
  await page.click(&#39;.hostname-link&#39;);
  
  // Verify proper modal management occurred
  const transitions = await page.evaluate(() =&gt; window.modalTransitions);
  expect(transitions.length).toBeGreaterThan(0);
});
</code></pre>
<h2>Integration with Development Workflow</h2>
<h3>Pre-commit Testing</h3>
<p>Tests run automatically as part of the development workflow:</p>
<pre><code class="language-bash">
# Run all tests before commits

npm run test

# Run specific test suites

npx playwright test --grep &quot;modal&quot;
npx playwright test --grep &quot;import&quot;
npx playwright test --grep &quot;responsive&quot;
</code></pre>
<h3>Continuous Integration</h3>
<p><strong>Docker Integration</strong>:</p>
<ul>
<li>All tests run in Docker containers for consistency</li>
<li>Container restart required before test runs</li>
<li>Clean state guaranteed for reproducible results</li>
</ul>
<p><strong>Test Reporting</strong>:</p>
<ul>
<li>HTML test reports generated in <code>test-results/</code></li>
<li>Screenshot evidence for failed tests</li>
<li>Console output captured for debugging</li>
</ul>
<h2>Best Practices</h2>
<h3>Test Organization</h3>
<ol>
<li><strong>Group by Feature</strong>: Organize tests by major application features (modals, imports, exports)</li>
<li><strong>Descriptive Names</strong>: Use clear, descriptive test names that explain expected behavior</li>
<li><strong>Idempotent Design</strong>: Tests should work regardless of existing data state</li>
<li><strong>Isolation</strong>: Each test should be independent and not rely on others</li>
</ol>
<h3>Debugging Failed Tests</h3>
<ol>
<li><strong>Screenshot Evidence</strong>: Playwright automatically captures screenshots on failure</li>
<li><strong>Console Logs</strong>: Monitor browser console for JavaScript errors</li>
<li><strong>Network Monitoring</strong>: Track API calls and responses during test execution</li>
<li><strong>Step-by-Step Traces</strong>: Use Playwright&#39;s trace recording for detailed debugging</li>
</ol>
<h3>Performance Considerations</h3>
<ol>
<li><strong>Parallel Execution</strong>: Run tests in parallel when possible</li>
<li><strong>Resource Cleanup</strong>: Clean up test data and browser state between tests</li>
<li><strong>Timeout Management</strong>: Set appropriate timeouts for different types of operations</li>
<li><strong>Memory Management</strong>: Monitor memory usage during large dataset tests</li>
</ol>
<h2>Future Testing Enhancements</h2>
<h3>Planned Improvements</h3>
<ul>
<li><strong>API Testing</strong>: Direct endpoint testing without browser overhead</li>
<li><strong>Load Testing</strong>: Stress testing with thousands of concurrent users</li>
<li><strong>Cross-Browser Testing</strong>: Firefox, Safari, and Chrome compatibility</li>
<li><strong>Visual Regression Testing</strong>: Automated UI change detection</li>
</ul>
<h3>Integration Opportunities</h3>
<ul>
<li><strong>CI/CD Pipeline</strong>: Automated testing on code commits</li>
<li><strong>Performance Monitoring</strong>: Real-time performance metrics during tests</li>
<li><strong>Security Testing</strong>: Automated vulnerability scanning of test environments</li>
</ul>
<hr>
<p><em>This testing strategy ensures HexTrackr maintains high quality and reliability while supporting rapid development and feature enhancement.</em></p>

    <!-- Note: This file is intentionally minimal. The full page scaffold, header, footer, and scripts
             are provided by docs-html/index.html. Content generated using this template will be
             fetched and injected into #content-container by docs-html/js/docs-portal-v2.js. -->
</section>
