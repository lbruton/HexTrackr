<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulnerability Core Bug Test Cases</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ddd; }
        .pass { background-color: #d4edda; border-color: #c3e6cb; }
        .fail { background-color: #f8d7da; border-color: #f5c6cb; }
        .test-title { font-weight: bold; margin-bottom: 10px; }
        .test-result { margin-top: 10px; font-style: italic; }
        button { margin: 5px; padding: 10px; }
    </style>
</head>
<body>
    <h1>Vulnerability Core Bug Test Cases</h1>

    <div id="test-results"></div>

    <script type="module">
        // Mock classes for testing - simulate missing imports
        class MockVulnerabilityDataManager {
            constructor(apiBase) {
                this.apiBase = apiBase;
                this.vulnerabilities = [];
                this.listeners = new Map();
            }
            async loadData() { return true; }
            on(event, callback) {
                if (!this.listeners.has(event)) this.listeners.set(event, []);
                this.listeners.get(event).push(callback);
            }
            getStatistics() { return { critical: 0, high: 0, medium: 0, low: 0 }; }
            getDevices() { return []; }
            getAllVulnerabilities() { return []; }
        }

        class MockVulnerabilityStatisticsManager {
            constructor(dataManager) {
                this.dataManager = dataManager;
            }
            updateStatisticsDisplay() { return true; }
            flipStatCards() { return true; }
        }

        class MockVulnerabilitySearchManager {
            constructor(apiBase, dataManager, parentContext) {
                this.apiBase = apiBase;
                this.dataManager = dataManager;
                this.parentContext = parentContext;
            }
            async lookupVulnerability(vulnId, pluginName) { return true; }
        }

        class MockVulnerabilityCardsManager {
            constructor(dataManager, devicePagination, vulnerabilityPagination, parentContext) {
                this.dataManager = dataManager;
            }
            updateForCurrentView(view) { return true; }
        }

        class MockVulnerabilityChartManager {
            constructor(containerId, statsManager, dataManager) {
                this.containerId = containerId;
            }
            initialize() { return true; }
            update() { return true; }
            hasThemeSupport() { return true; }
            updateTheme(theme) { return true; }
        }

        class MockVulnerabilityGridManager {
            constructor(dataManager, parentContext) {
                this.dataManager = dataManager;
            }
            initializeGrid() { return true; }
            updateForCurrentView(view) { return true; }
            hasThemeSupport() { return true; }
            updateTheme(theme) { return true; }
        }

        class MockPaginationController {
            constructor(pageSize, pageSizeOptions) {
                this.pageSize = pageSize;
                this.pageSizeOptions = pageSizeOptions;
            }
        }

        class MockWebSocketClient {
            async connect() {
                return new Promise(resolve => setTimeout(resolve, 100));
            }
            isSocketConnected() { return true; }
            disconnect() { return true; }
        }

        class MockProgressModal {
            constructor(websocketClient) {
                this.websocketClient = websocketClient;
            }
            show(options) { return true; }
            showError(message) { return true; }
        }

        // Mock global objects
        window.bootstrap = {
            Modal: class {
                constructor(element) {
                    this.element = element;
                }
                show() { return true; }
                hide() { return true; }
                static getInstance(element) {
                    return new window.bootstrap.Modal(element);
                }
            }
        };

        window.WebSocketClient = MockWebSocketClient;
        window.ProgressModal = MockProgressModal;
        window.PaginationController = MockPaginationController;
        window.toastManager = {
            showToast: (message, type) => console.log(`Toast: ${message} (${type})`),
            showLoading: (message) => console.log(`Loading: ${message}`),
            hideLoading: () => console.log('Loading hidden')
        };

        // Define the test module inline to simulate the fixed imports
        class VulnerabilityCoreOrchestrator {
            constructor() {
                this.apiBase = "/api";
                this.currentView = "table";

                // Module managers will be injected
                this.dataManager = null;
                this.statisticsManager = null;
                this.chartManager = null;
                this.searchManager = null;
                this.gridManager = null;
                this.cardsManager = null;

                // Initialize pagination controllers
                this.devicePagination = new MockPaginationController(6, [6, 12, 24, 48, 64, 96]);
                this.vulnerabilityPagination = new MockPaginationController(6, [6, 12, 24, 48, 64, 96]);

                // Initialize WebSocket and progress modal
                this.websocketClient = null;
                this.progressModal = null;

                // File import state
                this.pendingFile = null;
            }

            async initializeAllModules(parentContext) {
                // Create all modules (single creation point) - FIXED: Using mock classes
                this.dataManager = new MockVulnerabilityDataManager("/api");
                this.statisticsManager = new MockVulnerabilityStatisticsManager(this.dataManager);
                this.chartManager = new MockVulnerabilityChartManager("vulnerability-chart", this.statisticsManager, this.dataManager);
                this.searchManager = new MockVulnerabilitySearchManager("/api", this.dataManager, parentContext);
                this.gridManager = new MockVulnerabilityGridManager(this.dataManager, parentContext);
                this.cardsManager = new MockVulnerabilityCardsManager(this.dataManager, this.devicePagination, this.vulnerabilityPagination, parentContext);

                // Initialize WebSocket and progress modal
                await this.initializeWebSocketAndProgressModal();

                // Setup cross-module event coordination
                this.setupDataManagerListeners();
                this.setupEventListeners();

                // Initialize modules in proper order (single initialization point)
                this.gridManager.initializeGrid();
                this.chartManager.initialize();

                // Load initial data (single data load)
                await this.loadData();
            }

            // FIXED: WebSocket initialization with timeout
            async initializeWebSocketAndProgressModal() {
                try {
                    // Initialize WebSocket client if available
                    if (typeof WebSocketClient !== "undefined") {
                        this.websocketClient = new WebSocketClient();

                        // Add connection timeout to prevent hanging
                        const connectionPromise = this.websocketClient.connect();
                        const timeoutPromise = new Promise((_, reject) =>
                            setTimeout(() => reject(new Error("WebSocket connection timeout")), 5000)
                        );

                        try {
                            await Promise.race([connectionPromise, timeoutPromise]);
                            console.log("WebSocket client connected for progress tracking");
                        } catch (wsError) {
                            console.warn("WebSocket connection failed:", wsError.message);
                            this.websocketClient = null; // Reset to null on failure
                        }
                    } else {
                        console.warn("WebSocket client not available - progress modal will work in manual mode");
                    }

                    // Initialize progress modal if available (works with or without WebSocket)
                    if (typeof ProgressModal !== "undefined") {
                        this.progressModal = new ProgressModal(this.websocketClient);
                        console.log("Progress modal initialized");
                    } else {
                        console.warn("Progress modal not available - falling back to traditional loading indicators");
                    }
                } catch (error) {
                    console.error("Error initializing WebSocket/Progress modal:", error);
                    // Ensure websocketClient is null on any error
                    this.websocketClient = null;
                }
            }

            setupDataManagerListeners() {
                // Listen to data manager events
                this.dataManager.on("dataLoaded", (_data) => {
                    this.updateChart();
                    this.updateCurrentView();
                });

                this.dataManager.on("dataFiltered", (_data) => {
                    this.updateCurrentView();
                });

                this.dataManager.on("statisticsLoaded", (_data) => {
                    this.updateStatisticsDisplay();
                });

                this.dataManager.on("error", (data) => {
                    this.showToast(data.message, "danger");
                });
            }

            // FIXED: DOM element null checks
            setupEventListeners() {
                // Import CSV - Show date picker modal
                const importCsvBtn = document.getElementById("importCsvBtn");
                if (importCsvBtn) {
                    importCsvBtn.addEventListener("click", () => {
                        const csvFileInput = document.getElementById("csvFileInput");
                        if (csvFileInput) {
                            csvFileInput.click();
                        }
                    });
                }

                const csvFileInput = document.getElementById("csvFileInput");
                if (csvFileInput) {
                    csvFileInput.addEventListener("change", (e) => {
                        this.showScanDateModal(e);
                    });
                }

                // Confirm scan date and proceed with import
                const confirmScanDate = document.getElementById("confirmScanDate");
                if (confirmScanDate) {
                    confirmScanDate.addEventListener("click", () => {
                        this.proceedWithImport();
                    });
                }

                // View switcher for Tabler.io button group
                document.querySelectorAll("[data-view]").forEach(btn => {
                    btn.addEventListener("click", (e) => {
                        const view = e.target.dataset.view || e.target.closest("[data-view]").dataset.view;
                        if (view) {
                            this.switchView(view);
                        }
                    });
                });

                // Export button
                const exportBtn = document.getElementById("exportBtn");
                if (exportBtn) {
                    exportBtn.addEventListener("click", () => {
                        this.exportData();
                    });
                }

                // Refresh button - Check if exists before adding listener
                const refreshBtn = document.getElementById("refreshBtn");
                if (refreshBtn) {
                    refreshBtn.addEventListener("click", () => {
                        this.dataManager.refreshData();
                    });
                }

                // Save vulnerability edit
                const saveVulnEdit = document.getElementById("saveVulnEdit");
                if (saveVulnEdit) {
                    saveVulnEdit.addEventListener("click", () => {
                        this.saveVulnerabilityChanges();
                    });
                }
            }

            async loadData() {
                await this.dataManager.loadData();
            }

            updateChart() {
                this.chartManager.update();
            }

            updateStatisticsDisplay() {
                if (this.statisticsManager) {
                    this.statisticsManager.updateStatisticsDisplay();
                } else {
                    console.warn("StatisticsManager not available for display update");
                }
            }

            updateCurrentView() {
                switch (this.currentView) {
                    case "table":
                        this.gridManager.updateForCurrentView(this.currentView);
                        break;
                    case "devices":
                        this.cardsManager.updateForCurrentView(this.currentView);
                        break;
                    case "vulnerabilities":
                        this.cardsManager.updateForCurrentView(this.currentView);
                        break;
                }
            }

            // FIXED: DOM element validation
            showScanDateModal(event) {
                this.pendingFile = event.target.files[0];
                if (!this.pendingFile) {return;}

                const scanDateInput = document.getElementById("scanDateInput");
                const scanDateModal = document.getElementById("scanDateModal");

                if (!scanDateInput || !scanDateModal) {
                    console.error("Required modal elements not found");
                    this.showToast("Modal elements not available", "danger");
                    return;
                }

                const today = new Date().toISOString().split("T")[0];
                scanDateInput.value = today;

                const modal = new bootstrap.Modal(scanDateModal);
                modal.show();
            }

            // FIXED: More DOM element validation
            async proceedWithImport() {
                const scanDateInput = document.getElementById("scanDateInput");
                const scanDateModal = document.getElementById("scanDateModal");
                const csvFileInput = document.getElementById("csvFileInput");

                if (!scanDateInput || !scanDateModal) {
                    console.error("Required modal elements not found");
                    this.showToast("Modal elements not available", "danger");
                    return;
                }

                const scanDate = scanDateInput.value;
                if (!scanDate) {
                    this.showToast("Please select a scan date", "danger");
                    return;
                }

                const modal = bootstrap.Modal.getInstance(scanDateModal);
                if (modal) {
                    modal.hide();
                }

                await this.handleCsvImportWithDate(this.pendingFile, scanDate);

                this.pendingFile = null;
                if (csvFileInput) {
                    csvFileInput.value = "";
                }
            }

            async handleCsvImportWithDate(file, scanDate) {
                if (!file) {return;}

                // FIXED: Better WebSocket connection check
                const useProgressModal = this.progressModal &&
                    this.websocketClient &&
                    typeof this.websocketClient.isSocketConnected === 'function' &&
                    this.websocketClient.isSocketConnected();

                console.log("Simulated CSV import with progress modal:", useProgressModal);
                return true; // Simulate success
            }

            showToast(message, type = "info") {
                if (window.toastManager) {
                    return window.toastManager.showToast(message, type);
                }
                console.log(`Toast [${type}]: ${message}`);
            }

            // FIXED: Added cleanup method
            destroy() {
                try {
                    // Close WebSocket connection
                    if (this.websocketClient && typeof this.websocketClient.disconnect === 'function') {
                        this.websocketClient.disconnect();
                    }

                    // Clean up data manager listeners
                    if (this.dataManager && typeof this.dataManager.removeAllListeners === 'function') {
                        this.dataManager.removeAllListeners();
                    }

                    // Clear references
                    this.websocketClient = null;
                    this.progressModal = null;
                    this.dataManager = null;
                    this.statisticsManager = null;
                    this.chartManager = null;
                    this.searchManager = null;
                    this.gridManager = null;
                    this.cardsManager = null;

                    console.log("VulnerabilityCoreOrchestrator cleanup completed");
                    return true;
                } catch (error) {
                    console.error("Error during cleanup:", error);
                    return false;
                }
            }
        }

        // Test cases
        const tests = [
            {
                name: "Test 1: Missing Import Dependencies Fixed",
                description: "Test that all required classes can be instantiated",
                test: async () => {
                    try {
                        const orchestrator = new VulnerabilityCoreOrchestrator();
                        await orchestrator.initializeAllModules({});

                        // Check that all managers were created
                        if (!orchestrator.dataManager) throw new Error("DataManager not created");
                        if (!orchestrator.statisticsManager) throw new Error("StatisticsManager not created");
                        if (!orchestrator.chartManager) throw new Error("ChartManager not created");
                        if (!orchestrator.searchManager) throw new Error("SearchManager not created");
                        if (!orchestrator.gridManager) throw new Error("GridManager not created");
                        if (!orchestrator.cardsManager) throw new Error("CardsManager not created");

                        return { pass: true, message: "All managers initialized successfully" };
                    } catch (error) {
                        return { pass: false, message: error.message };
                    }
                }
            },
            {
                name: "Test 2: DOM Element Null Checks",
                description: "Test that missing DOM elements don't cause crashes",
                test: async () => {
                    try {
                        const orchestrator = new VulnerabilityCoreOrchestrator();

                        // Call setupEventListeners with missing DOM elements
                        orchestrator.setupEventListeners();

                        // Test showScanDateModal with missing elements
                        const mockEvent = { target: { files: [new File(["test"], "test.csv")] } };
                        orchestrator.showScanDateModal(mockEvent);

                        // Test proceedWithImport with missing elements
                        await orchestrator.proceedWithImport();

                        return { pass: true, message: "No crashes with missing DOM elements" };
                    } catch (error) {
                        return { pass: false, message: error.message };
                    }
                }
            },
            {
                name: "Test 3: WebSocket Connection Timeout",
                description: "Test WebSocket connection with timeout handling",
                test: async () => {
                    try {
                        // Mock a slow WebSocket connection
                        class SlowWebSocketClient {
                            async connect() {
                                return new Promise(resolve => setTimeout(resolve, 6000)); // 6 seconds > 5 second timeout
                            }
                        }

                        window.WebSocketClient = SlowWebSocketClient;

                        const orchestrator = new VulnerabilityCoreOrchestrator();
                        await orchestrator.initializeWebSocketAndProgressModal();

                        // Should have null websocketClient due to timeout
                        if (orchestrator.websocketClient === null) {
                            return { pass: true, message: "WebSocket timeout handled correctly" };
                        } else {
                            return { pass: false, message: "WebSocket timeout not handled" };
                        }
                    } catch (error) {
                        return { pass: false, message: error.message };
                    }
                }
            },
            {
                name: "Test 4: Proper WebSocket Connection Check",
                description: "Test improved WebSocket connection validation",
                test: async () => {
                    try {
                        const orchestrator = new VulnerabilityCoreOrchestrator();
                        orchestrator.progressModal = new MockProgressModal(null);

                        // Test with null websocketClient
                        orchestrator.websocketClient = null;
                        const result1 = await orchestrator.handleCsvImportWithDate(new File(["test"], "test.csv"), "2025-01-01");

                        // Test with websocketClient without isSocketConnected method
                        orchestrator.websocketClient = {};
                        const result2 = await orchestrator.handleCsvImportWithDate(new File(["test"], "test.csv"), "2025-01-01");

                        // Test with proper websocketClient
                        orchestrator.websocketClient = new MockWebSocketClient();
                        const result3 = await orchestrator.handleCsvImportWithDate(new File(["test"], "test.csv"), "2025-01-01");

                        return { pass: true, message: "WebSocket connection checks work correctly" };
                    } catch (error) {
                        return { pass: false, message: error.message };
                    }
                }
            },
            {
                name: "Test 5: Memory Leak Prevention",
                description: "Test cleanup method prevents memory leaks",
                test: async () => {
                    try {
                        const orchestrator = new VulnerabilityCoreOrchestrator();
                        await orchestrator.initializeAllModules({});

                        // Verify managers are set
                        if (!orchestrator.dataManager) throw new Error("DataManager not initialized");

                        // Call destroy method
                        const cleanupResult = orchestrator.destroy();

                        // Verify cleanup
                        if (orchestrator.dataManager !== null) throw new Error("DataManager not cleaned up");
                        if (orchestrator.websocketClient !== null) throw new Error("WebSocketClient not cleaned up");
                        if (orchestrator.progressModal !== null) throw new Error("ProgressModal not cleaned up");

                        return { pass: true, message: "Cleanup method works correctly" };
                    } catch (error) {
                        return { pass: false, message: error.message };
                    }
                }
            }
        ];

        // Run tests
        async function runTests() {
            const resultsContainer = document.getElementById('test-results');

            for (const testCase of tests) {
                const result = await testCase.test();

                const testDiv = document.createElement('div');
                testDiv.className = `test-case ${result.pass ? 'pass' : 'fail'}`;
                testDiv.innerHTML = `
                    <div class="test-title">${testCase.name}</div>
                    <div>${testCase.description}</div>
                    <div class="test-result">
                        Result: ${result.pass ? 'PASS' : 'FAIL'} - ${result.message}
                    </div>
                `;

                resultsContainer.appendChild(testDiv);
            }
        }

        // Add some test DOM elements
        const testElements = `
            <input type="file" id="csvFileInput" style="display: none;">
            <button id="importCsvBtn">Import CSV</button>
            <button id="exportBtn">Export</button>
            <button id="refreshBtn">Refresh</button>
            <button id="confirmScanDate">Confirm Date</button>
            <button id="saveVulnEdit">Save Edit</button>
            <input type="date" id="scanDateInput">
            <div id="scanDateModal" class="modal">
                <div class="modal-content">Modal Content</div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', testElements);

        // Run the tests
        runTests();
    </script>
</body>
</html>