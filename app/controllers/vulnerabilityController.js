/**
 * Vulnerability Controller
 * Extracted from server.js lines: 1996-2016, 2019-2092, 2095-2156, 2159-2218, 2221-2283, 2337-2399, 2403-2514, 2517-2531, 3304-3317, 3501-3565
 *
 * This is the largest and most complex controller in HexTrackr, handling:
 * - Statistics and analytics endpoints with complex VPR calculations
 * - Core vulnerability CRUD operations with lifecycle management
 * - CSV import operations (standard and staging-based for performance)
 * - Data management and clearing operations
 * - Export functionality for backup/analysis
 *
 * Delegates business logic to:
 * - vulnerabilityService: Core CRUD, import processing, data management
 * - vulnerabilityStatsService: Statistics, trends, analytics calculations
 *
 * T053 INTEGRATION CHECKLIST:
 * 1. Import this controller in server.js: const vulnerabilityController = require("./app/controllers/vulnerabilityController");
 * 2. Initialize after database connection: vulnerabilityController.initialize(db, progressTracker);
 * 3. Register routes: app.use("/api/vulnerabilities", require("./app/routes/vulnerabilities"));
 * 4. Remove duplicate routes from server.js (see routes file for line numbers)
 * 5. Handle import/backup route conflicts as noted in routes file
 * 6. Ensure utility functions (mapVulnerabilityRow, extractScanDateFromFilename) remain in server.js
 */

const VulnerabilityService = require("../services/vulnerabilityService");
const VulnerabilityStatsService = require("../services/vulnerabilityStatsService");
const CacheService = require("../services/cacheService");
const { shouldBypassCache, sendBypassResponse } = require("../utils/httpHelpers");

// Get singleton instance explicitly (prevents race conditions)
const cacheService = CacheService.getInstance();

// HEX-156: Vendor validation helper
const VALID_VENDORS = ["CISCO", "Palo Alto", "Other"];

/**
 * Validate vendor parameter against whitelist
 * @param {string|undefined} vendor - Vendor name from query parameter
 * @returns {string|null} - Validated vendor name or null for "All Vendors"
 * @throws {Error} - If vendor is invalid
 */
function validateVendor(vendor) {
    if (!vendor) {return null;} // Empty = "All Vendors"
    if (!VALID_VENDORS.includes(vendor)) {
        throw new Error(`Invalid vendor. Must be one of: ${VALID_VENDORS.join(", ")}`);
    }
    return vendor;
}

// HEX-346: Cache-busting helpers moved to app/utils/httpHelpers.js
// - shouldBypassCache(req): Check if cache should be bypassed via query params (_t or bustCache)
// - sendBypassResponse(res, payload): Send JSON response with cache bypass headers

class VulnerabilityController {
    constructor() {
        this.vulnerabilityService = new VulnerabilityService();
        this.vulnerabilityStatsService = new VulnerabilityStatsService();
        this.progressTracker = null; // Will be injected during initialization
    }

    /**
     * Initialize controller with database connection and progress tracker
     * Called from server.js during setup
     */
    static initialize(database, progressTracker) {
        if (!VulnerabilityController.instance) {
            VulnerabilityController.instance = new VulnerabilityController();
        }
        VulnerabilityController.instance.vulnerabilityService.initialize(database);
        VulnerabilityController.instance.vulnerabilityStatsService.initialize(database);
        VulnerabilityController.instance.progressTracker = progressTracker;
        return VulnerabilityController.instance;
    }

    /**
     * Get singleton instance (for use in routes)
     */
    static getInstance() {
        if (!VulnerabilityController.instance) {
            throw new Error("VulnerabilityController not initialized. Call initialize() first.");
        }
        return VulnerabilityController.instance;
    }

    /**
     * Get vulnerability statistics with VPR totals.
     *
     * Legacy behaviour (mirrors server.js) returns an object keyed by lowercase
     * severity rather than the raw array produced by the stats service. The
     * frontend's dashboard cards expect this shape, so we rebuild it here.
     *
     * HEX-156: Added optional vendor filtering
     * Extracted from server.js lines 1996-2016.
     */
    static async getStats(req, res) {
        try {
            const bypassCache = shouldBypassCache(req);
            const controller = VulnerabilityController.getInstance();
            const vendor = validateVendor(req.query.vendor); // HEX-156: Validate vendor parameter

            if (bypassCache) {
                const statsArray = await controller.vulnerabilityStatsService.getStats(vendor);
                const stats = {};
                statsArray.forEach(row => {
                    if (!row || !row.severity) {return;}
                    const severityKey = row.severity.toLowerCase();
                    stats[severityKey] = {
                        count: row.count || 0,
                        total_vpr: row.total_vpr || 0,
                        avg_vpr: row.avg_vpr || 0,
                        earliest: row.earliest || null,
                        latest: row.latest || null
                    };
                });
                return sendBypassResponse(res, stats);
            }

            // Generate NAMESPACED vendor-specific cache key
            // Namespace pattern: vendor:stats:CISCO prevents collisions with other cache keys
            // Self-documenting: "vendor" domain, "stats" type, "CISCO" identifier
            const cacheKey = vendor ? `vendor:stats:${vendor}` : "vendor:stats:all";

            // Server cache: 5min (300s), Browser cache: 1min (60s)
            await cacheService.withCaching(res, "stats", cacheKey, 90, async () => {
                const statsArray = await controller.vulnerabilityStatsService.getStats(vendor);

                // Mirror legacy server.js behaviour: return object keyed by lowercase severity
                const stats = {};
                statsArray.forEach(row => {
                    if (!row || !row.severity) {return;}
                    const severityKey = row.severity.toLowerCase();
                    stats[severityKey] = {
                        count: row.count || 0,
                        total_vpr: row.total_vpr || 0,
                        avg_vpr: row.avg_vpr || 0,
                        earliest: row.earliest || null,
                        latest: row.latest || null
                    };
                });

                return stats;
            }, 30);
        } catch (error) {
            if (global.logger?.error) {
                global.logger.error("backend", "vulnerability", "Error fetching vulnerability stats", { error: error.message, vendor: req.query.vendor });
            } else {
                console.error("Error fetching vulnerability stats:", error);
            }

            // HEX-156: Return 400 for invalid vendor, 500 for other errors
            if (error.message.includes("Invalid vendor")) {
                res.status(400).json({
                    success: false,
                    error: error.message
                });
            } else {
                res.status(500).json({
                    success: false,
                    error: "Failed to fetch vulnerability statistics",
                    details: error.message
                });
            }
        }
    }

    /**
     * Get recent vulnerability statistics with trend comparison (for dashboard cards)
     * Extracted from server.js lines 2019-2092
     */
    static async getRecentTrends(req, res) {
        try {
            if (shouldBypassCache(req)) {
                const controller = VulnerabilityController.getInstance();
                const result = await controller.vulnerabilityStatsService.getRecentTrends();
                return sendBypassResponse(res, result);
            }

            const controller = VulnerabilityController.getInstance();

            // Server cache: 10min (600s), Browser cache: 1min (60s)
            await cacheService.withCaching(res, "trends", "vulnerability-recent-trends", 90, async () => {
                return await controller.vulnerabilityStatsService.getRecentTrends();
            }, 30);
        } catch (error) {
            console.error("Error fetching recent trends:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch recent trends",
                details: error.message
            });
        }
    }

    /**
     * Get the most recent CSV import date
     * Used by settings modal Tenable card to display last import date (HEX-240)
     */
    static async getLastImport(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const result = await controller.vulnerabilityStatsService.getLastImportDate();
            res.json(result);
        } catch (error) {
            console.error("Error fetching last import date:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch last import date",
                details: error.message
            });
        }
    }

    /**
     * Get historical trending data with optional date range
     * HEX-156: Added optional vendor filtering
     * Extracted from server.js lines 2095-2156
     */
    static async getTrends(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const { startDate, endDate } = req.query;
            const vendor = validateVendor(req.query.vendor); // HEX-156: Validate vendor parameter

            if (shouldBypassCache(req)) {
                const result = await controller.vulnerabilityStatsService.getTrends(startDate, endDate, vendor);
                return sendBypassResponse(res, result);
            }

            // Generate NAMESPACED vendor-specific cache key
            // Namespace pattern: vendor:trends:CISCO prevents collisions
            const cacheKey = vendor ? `vendor:trends:${vendor}` : "vendor:trends:all";

            // Server cache: 90s, Browser cache default
            await cacheService.withCaching(res, "trends", cacheKey, 90, async () => {
                return await controller.vulnerabilityStatsService.getTrends(startDate, endDate, vendor);
            }, 30);
        } catch (error) {
            console.error("Error fetching trends:", error);

            // HEX-156: Return 400 for invalid vendor, 500 for other errors
            if (error.message.includes("Invalid vendor")) {
                res.status(400).json({
                    success: false,
                    error: error.message
                });
            } else {
                res.status(500).json({
                    success: false,
                    error: "Failed to fetch historical trends",
                    details: error.message
                });
            }
        }
    }

    /**
     * Get vulnerabilities with pagination and filtering
     * Extracted from server.js lines 2159-2218
     * HEX-101: Added cache bypass for large queries (limit > 10000)
     */
    static async getVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const page = parseInt(req.query.page, 10) || 1;
            const limit = parseInt(req.query.limit, 10) || 50;
            const search = req.query.search || "";
            const severity = req.query.severity || "";
            const vendor = req.query.vendor || ""; // HEX-101: Added vendor parameter
            const isKev = req.query.kev === "true"; // HEX-117: Added KEV filter (standardized 'kev' param)

            // Cache Strategy for Large Queries (limit > 10000):
            // These "load all" queries are used for page navigation and should be aggressively cached
            // since vulnerability data only changes on CSV uploads (which clear the cache).
            // This enables instant page switching (Vulnerabilities â†” Tickets) without reloading.
            if (limit > 10000) {
                const largeCacheKey = `vulnerabilities:full:${limit}:${search}:${severity}:${vendor}:${isKev}`;

                // Server cache: 30min (1800s) - vulnerabilities only change on CSV upload
                // Browser cache: 10min (600s) - enables instant tab switching
                // Cache is cleared automatically by importService on CSV upload
                await cacheService.withCaching(res, "vulnerabilities", largeCacheKey, 1800, async () => {
                    return await controller.vulnerabilityService.getVulnerabilities({
                        page,
                        limit,
                        search,
                        severity,
                        vendor,
                        isKev
                    });
                }, 600);

                return;  // withCaching handles the response
            }

            // Standard cache path for smaller, paginated queries
            // HEX-117: Create cache key including all query parameters (including kev)
            const cacheKey = `vulnerabilities:${page}:${limit}:${search}:${severity}:${vendor}:${isKev}`;

            // Server cache: 30min (1800s), Browser cache: 10min (600s)
            // Data only changes on CSV imports (which clear cache), so long TTL is safe
            // Uses dedicated 'vulnerabilities' cache (not 'stats') for semantic clarity
            await cacheService.withCaching(res, "vulnerabilities", cacheKey, 1800, async () => {
                return await controller.vulnerabilityService.getVulnerabilities({
                    page,
                    limit,
                    search,
                    severity,
                    vendor, // HEX-101: Pass vendor to service
                    isKev // HEX-117: Pass KEV filter to service
                });
            }, 600);
        } catch (error) {
            console.error("Error fetching vulnerabilities:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch vulnerabilities",
                details: error.message
            });
        }
    }

    /**
     * Get individual vulnerability by ID - GET /api/vulnerabilities/:id
     * Retrieves complete vulnerability data for a specific vulnerability record
     * Used by modal views and detail pages to display full vulnerability information
     * HEX-112 Phase 2: Required for modal views and detail fetching
     *
     * @async
     * @param {Object} req - Express request object
     * @param {Object} req.params - Route parameters
     * @param {string} req.params.id - Vulnerability ID (primary key)
     * @param {Object} res - Express response object
     * @returns {Promise<void>} Sends JSON response:
     *   - 200: {success: true, data: Object} - Vulnerability record with all fields
     *   - 400: {success: false, error: "Vulnerability ID is required"} - Missing ID
     *   - 404: {success: false, error: "Vulnerability not found"} - Invalid ID
     *   - 500: {success: false, error: "Failed to fetch vulnerability", details: string}
     * @throws {Error} Caught and returned as 500 response if VulnerabilityService.getVulnerabilityById fails
     * @route GET /api/vulnerabilities/:id
     * @example
     * // GET /api/vulnerabilities/42
     * // Returns: {success: true, data: {id: 42, cveId: "CVE-2024-1234", ...}}
     */
    static async getVulnerabilityById(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const { id } = req.params;

            if (!id) {
                return res.status(400).json({
                    success: false,
                    error: "Vulnerability ID is required"
                });
            }

            const vulnerability = await controller.vulnerabilityService.getVulnerabilityById(id);

            if (!vulnerability) {
                return res.status(404).json({
                    success: false,
                    error: "Vulnerability not found"
                });
            }

            res.json({
                success: true,
                data: vulnerability
            });
        } catch (error) {
            console.error("Error fetching vulnerability by ID:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch vulnerability",
                details: error.message
            });
        }
    }

    /**
     * Get resolved/fixed vulnerabilities (for troubleshooting and historical analysis)
     * Retrieves vulnerabilities that were marked as resolved/fixed when they disappeared from scans
     * Supports pagination and search filtering for historical analysis
     * Extracted from server.js lines 2221-2283
     *
     * @async
     * @param {Object} req - Express request object
     * @param {Object} req.query - Query parameters
     * @param {number} [req.query.page=1] - Page number for pagination (default: 1)
     * @param {number} [req.query.limit=50] - Results per page (default: 50)
     * @param {string} [req.query.search=""] - Search term to filter vulnerabilities
     * @param {Object} res - Express response object
     * @returns {Promise<void>} Sends JSON response with structure:
     *   - 200: {success: boolean, data: Array, total: number, page: number, limit: number, note: string}
     *   - 500: {success: false, error: "Failed to fetch resolved vulnerabilities", details: string}
     * @throws {Error} Caught and returned as 500 response if VulnerabilityService.getResolvedVulnerabilities fails
     * @route GET /api/vulnerabilities/resolved
     * @example
     * // GET /api/vulnerabilities/resolved?page=1&limit=50&search=CVE-2024
     * // Returns: {
     * //   success: true,
     * //   data: [...],
     * //   total: 150,
     * //   page: 1,
     * //   limit: 50,
     * //   note: "These vulnerabilities were marked as resolved/fixed when they disappeared from scans"
     * // }
     */
    static async getResolvedVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const page = parseInt(req.query.page, 10) || 1;
            const limit = parseInt(req.query.limit, 10) || 50;
            const search = req.query.search || "";

            const result = await controller.vulnerabilityService.getResolvedVulnerabilities({
                page,
                limit,
                search
            });

            res.json({
                ...result,
                note: "These vulnerabilities were marked as resolved/fixed when they disappeared from scans"
            });
        } catch (error) {
            console.error("Error fetching resolved vulnerabilities:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch resolved vulnerabilities",
                details: error.message
            });
        }
    }

    /**
     * Import CSV vulnerabilities (standard processing)
     * Extracted from server.js lines 2337-2399
     */
    static async importCSV(req, res) {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: "No file uploaded"
            });
        }

        try {
            const controller = VulnerabilityController.getInstance();
            const startTime = Date.now();
            const filename = req.file.originalname;
            const vendor = req.body.vendor || "unknown";
            const scanDate = req.body.scanDate || null; // Let service handle date extraction

            const result = await controller.vulnerabilityService.importCSV({
                filePath: req.file.path,
                filename,
                vendor,
                scanDate,
                fileSize: req.file.size,
                startTime
            });

            // Clear all caches after successful import
            cacheService.clearAll();

            res.json({
                success: true,
                data: result,
                message: `Import completed in ${Date.now() - startTime}ms`
            });
        } catch (error) {
            console.error("CSV import failed:", error);
            res.status(500).json({
                success: false,
                error: "CSV import failed",
                details: error.message
            });
        }
    }

    /**
     * High-performance CSV import using staging table
     * Extracted from server.js lines 2403-2514
     */
    static async importCsvStaging(req, res) {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: "No file uploaded"
            });
        }

        try {
            const controller = VulnerabilityController.getInstance();
            const startTime = Date.now();
            const filename = req.file.originalname;
            const vendor = req.body.vendor || "unknown";
            const scanDate = req.body.scanDate || null; // Let service handle date extraction
            const frontendSessionId = req.body.sessionId;

            // Create or use existing session for progress tracking
            let sessionId;
            if (frontendSessionId && controller.progressTracker) {
                sessionId = controller.progressTracker.createSessionWithId(frontendSessionId, {
                    operation: "csv-import",
                    filename: filename,
                    vendor: vendor,
                    scanDate: scanDate,
                    totalSteps: 3,
                    currentStep: 0
                });
            } else if (controller.progressTracker) {
                sessionId = controller.progressTracker.createSession({
                    operation: "csv-import",
                    filename: filename,
                    vendor: vendor,
                    scanDate: scanDate,
                    totalSteps: 3,
                    currentStep: 0
                });
            }

            // Immediately return session ID to client
            res.json({
                success: true,
                sessionId: sessionId,
                message: "CSV import started",
                filename: filename,
                vendor: vendor,
                scanDate: scanDate
            });

            // Process import asynchronously
            controller.vulnerabilityService.importCSVStaging({
                filePath: req.file.path,
                filename,
                vendor,
                scanDate,
                fileSize: req.file.size,
                startTime,
                sessionId,
                progressTracker: controller.progressTracker
            }).catch(error => {
                console.error("Staging import failed:", error);
                if (controller.progressTracker && sessionId) {
                    controller.progressTracker.errorSession(sessionId, "Import failed: " + error.message, { error });
                }
            });

        } catch (error) {
            console.error("Staging import initialization failed:", error);
            res.status(500).json({
                success: false,
                error: "Failed to initialize staging import",
                details: error.message
            });
        }
    }

    /**
     * Clear all vulnerability data
     * Extracted from server.js lines 2517-2531
     */
    static async clearAllData(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            await controller.vulnerabilityService.clearAllData();

            // Clear all caches after clearing data
            cacheService.clearAll();

            res.json({
                success: true,
                message: "All vulnerability data cleared from rollover architecture"
            });
        } catch (error) {
            console.error("Error clearing vulnerability data:", error);
            res.status(500).json({
                success: false,
                error: "Failed to clear vulnerability data",
                details: error.message
            });
        }
    }

    /**
     * Import vulnerabilities from web-based JSON data
     * Extracted from server.js lines 3501-3565
     * NOTE: This should be handled by import system, but included for completeness
     */
    static async importVulnerabilitiesWeb(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const csvData = req.body.data || [];

            if (!Array.isArray(csvData) || csvData.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: "No data provided"
                });
            }

            const result = await controller.vulnerabilityService.importVulnerabilitiesWeb(csvData);
            res.json({
                success: true,
                imported: result.imported,
                total: csvData.length,
                errors: result.errors.length > 0 ? result.errors : undefined
            });
        } catch (error) {
            console.error("Web import failed:", error);
            res.status(500).json({
                success: false,
                error: "Web import failed",
                details: error.message
            });
        }
    }

    /**
     * Get device statistics with aggregated vulnerability data
     * HEX-101 Blocking Issue #2: Server-side device aggregation endpoint
     *
     * Replaces client-side processDevices() which required loading all 30k vulnerabilities.
     * Provides pre-calculated device statistics for efficient device card rendering.
     *
     * @param {Object} req - Express request object
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     * @since v1.0.42
     * @module VulnerabilityController
     *
     * @example
     * GET /api/devices/stats
     * // Returns: { success: true, devices: [...] }
     */
    static async getDeviceStatistics(req, res) {
        try {
            if (shouldBypassCache(req)) {
                const controller = VulnerabilityController.getInstance();
                const devices = await controller.vulnerabilityService.getDeviceStatistics();
                return sendBypassResponse(res, {
                    success: true,
                    devices,
                    count: devices.length
                });
            }

            const controller = VulnerabilityController.getInstance();

            // Use caching for device statistics (5 minute TTL, same as vulnerability stats)
            const cacheKey = "device_statistics";
            await cacheService.withCaching(res, "stats", cacheKey, 90, async () => {
                const devices = await controller.vulnerabilityService.getDeviceStatistics();
                return {
                    success: true,
                    devices,
                    count: devices.length
                };
            }, 30);
        } catch (error) {
            console.error("Error fetching device statistics:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch device statistics",
                details: error.message
            });
        }
    }

    /**
     * Get top affected devices by vulnerability count
     * HEX-112 Phase 2: Required for dashboard charts
     * @param {Object} req - Express request with optional limit query param
     * @param {Object} res - Express response
     */
    static async getTopDevices(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const limit = parseInt(req.query.limit, 10) || 10;

            if (shouldBypassCache(req)) {
                const devices = await controller.vulnerabilityService.getTopAffectedDevices(limit);
                return sendBypassResponse(res, {
                    success: true,
                    data: devices,
                    limit
                });
            }

            // Cache key includes limit parameter
            const cacheKey = `top-devices:${limit}`;

            await cacheService.withCaching(res, "stats", cacheKey, 90, async () => {
                const devices = await controller.vulnerabilityService.getTopAffectedDevices(limit);
                return {
                    success: true,
                    data: devices,
                    limit
                };
            }, 30);
        } catch (error) {
            console.error("Error fetching top devices:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch top affected devices",
                details: error.message
            });
        }
    }

    /**
     * Get CVSS score distribution
     * HEX-112 Phase 2: Required for dashboard charts
     * @param {Object} req - Express request
     * @param {Object} res - Express response
     */
    static async getCvssDistribution(req, res) {
        try {
            if (shouldBypassCache(req)) {
                const controller = VulnerabilityController.getInstance();
                const distribution = await controller.vulnerabilityService.getCvssDistribution();
                return sendBypassResponse(res, {
                    success: true,
                    data: distribution
                });
            }

            const controller = VulnerabilityController.getInstance();

            await cacheService.withCaching(res, "stats", "cvss-distribution", 90, async () => {
                const distribution = await controller.vulnerabilityService.getCvssDistribution();
                return {
                    success: true,
                    data: distribution
                };
            }, 30);
        } catch (error) {
            console.error("Error fetching CVSS distribution:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch CVSS distribution",
                details: error.message
            });
        }
    }

    /**
     * Get severity distribution counts
     * HEX-112 Phase 2: Required for dashboard charts
     * @param {Object} req - Express request
     * @param {Object} res - Express response
     */
    static async getSeverityDistribution(req, res) {
        try {
            if (shouldBypassCache(req)) {
                const controller = VulnerabilityController.getInstance();
                const distribution = await controller.vulnerabilityService.getSeverityDistribution();
                return sendBypassResponse(res, {
                    success: true,
                    data: distribution
                });
            }

            const controller = VulnerabilityController.getInstance();

            await cacheService.withCaching(res, "stats", "severity-distribution", 90, async () => {
                const distribution = await controller.vulnerabilityService.getSeverityDistribution();
                return {
                    success: true,
                    data: distribution
                };
            }, 30);
        } catch (error) {
            console.error("Error fetching severity distribution:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch severity distribution",
                details: error.message
            });
        }
    }

    /**
     * Get recent vulnerabilities
     * HEX-112 Phase 2: Required for recent activity feed
     * @param {Object} req - Express request with optional limit query param
     * @param {Object} res - Express response
     */
    static async getRecentVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const limit = parseInt(req.query.limit, 10) || 10;

            if (shouldBypassCache(req)) {
                const vulnerabilities = await controller.vulnerabilityService.getRecentVulnerabilities(limit);
                return sendBypassResponse(res, {
                    success: true,
                    data: vulnerabilities,
                    limit
                });
            }

            const cacheKey = `recent-vulnerabilities:${limit}`;

            // Server cache: 30min (1800s), Browser cache: 10min (600s)
            // Recent vulnerabilities only change on CSV imports (which clear cache)
            await cacheService.withCaching(res, "vulnerabilities", cacheKey, 1800, async () => {
                const vulnerabilities = await controller.vulnerabilityService.getRecentVulnerabilities(limit);
                return {
                    success: true,
                    data: vulnerabilities,
                    limit
                };
            }, 600);
        } catch (error) {
            console.error("Error fetching recent vulnerabilities:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch recent vulnerabilities",
                details: error.message
            });
        }
    }

    /**
     * Export vulnerabilities with streaming for large datasets
     * HEX-112 Phase 2: Critical for handling large exports without memory issues
     * @param {Object} req - Express request with format and filter params
     * @param {Object} res - Express response (streaming)
     */
    static async exportVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const format = req.query.format || "csv";
            const filters = {
                severity: req.query.severity || "",
                vendor: req.query.vendor || "",
                search: req.query.search || "",
                isKev: req.query.kev === "true"
            };

            // Set appropriate headers for download
            res.setHeader("Content-Type", format === "csv" ? "text/csv" : "application/json");
            res.setHeader("Content-Disposition", `attachment; filename="vulnerabilities-export-${Date.now()}.${format}"`);
            res.setHeader("X-Content-Type-Options", "nosniff");

            // Stream the export data
            await controller.vulnerabilityService.streamExport(res, format, filters);
        } catch (error) {
            console.error("Error exporting vulnerabilities:", error);
            // If headers not sent, send error response
            if (!res.headersSent) {
                res.status(500).json({
                    success: false,
                    error: "Failed to export vulnerabilities",
                    details: error.message
                });
            }
        }
    }

    /**
     * Bulk delete vulnerabilities by IDs
     * HEX-112: Phase 2 endpoint for pagination migration
     * @param {Request} req - Express request with body.ids array
     * @param {Response} res - Express response
     */
    static async bulkDelete(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const { ids } = req.body;

            if (!ids || !Array.isArray(ids)) {
                return res.status(400).json({
                    success: false,
                    error: "Invalid request: 'ids' must be an array"
                });
            }

            if (ids.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: "Invalid request: 'ids' array cannot be empty"
                });
            }

            // Limit bulk operations for safety
            const MAX_BULK_SIZE = 1000;
            if (ids.length > MAX_BULK_SIZE) {
                return res.status(400).json({
                    success: false,
                    error: `Bulk delete limited to ${MAX_BULK_SIZE} items at once. Requested: ${ids.length}`
                });
            }

            const result = await controller.vulnerabilityService.bulkDelete(ids);

            res.json({
                success: true,
                message: result.message,
                data: {
                    requestedCount: result.requestedCount,
                    processedCount: result.processedCount,
                    deletedCount: result.totalDeleted,
                    details: result.deletedCounts
                }
            });
        } catch (error) {
            console.error("Bulk delete error:", error);
            res.status(500).json({
                success: false,
                error: "Failed to delete vulnerabilities",
                details: error.message
            });
        }
    }

    /**
     * Get vulnerability count with filters
     * HEX-112: Phase 2 endpoint for pagination migration
     * @param {Request} req - Express request with query parameters
     * @param {Response} res - Express response
     */
    static async getCount(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();

            // Parse filters from query params
            const filters = {
                severity: req.query.severity || "",
                vendor: req.query.vendor || "",
                search: req.query.search || "",
                isKev: req.query.kev === "true"
            };

            const result = await controller.vulnerabilityService.getCount(filters);

            res.json({
                success: true,
                data: result
            });
        } catch (error) {
            console.error("Count endpoint error:", error);
            res.status(500).json({
                success: false,
                error: "Failed to get vulnerability count",
                details: error.message
            });
        }
    }

    /**
     * Get KEV-specific statistics
     * HEX-112: Phase 2 endpoint for pagination migration
     * @param {Request} req - Express request
     * @param {Response} res - Express response
     */
    static async getKevStats(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const result = await controller.vulnerabilityService.getKevStats();

            res.json({
                success: true,
                data: result
            });
        } catch (error) {
            console.error("KEV stats error:", error);
            res.status(500).json({
                success: false,
                error: "Failed to get KEV statistics",
                details: error.message
            });
        }
    }

    /**
     * Get vendor distribution statistics
     * HEX-112: Phase 2 endpoint for pagination migration
     * @param {Request} req - Express request
     * @param {Response} res - Express response
     */
    static async getVendorStats(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const result = await controller.vulnerabilityService.getVendorStats();

            res.json({
                success: true,
                data: result
            });
        } catch (error) {
            console.error("Vendor stats error:", error);
            res.status(500).json({
                success: false,
                error: "Failed to get vendor statistics",
                details: error.message
            });
        }
    }
}

module.exports = VulnerabilityController;
