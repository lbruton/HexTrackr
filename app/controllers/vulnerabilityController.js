/**
 * Vulnerability Controller
 * Extracted from server.js lines: 1996-2016, 2019-2092, 2095-2156, 2159-2218, 2221-2283, 2337-2399, 2403-2514, 2517-2531, 3304-3317, 3501-3565
 *
 * This is the largest and most complex controller in HexTrackr, handling:
 * - Statistics and analytics endpoints with complex VPR calculations
 * - Core vulnerability CRUD operations with lifecycle management
 * - CSV import operations (standard and staging-based for performance)
 * - Data management and clearing operations
 * - Export functionality for backup/analysis
 *
 * Delegates business logic to:
 * - vulnerabilityService: Core CRUD, import processing, data management
 * - vulnerabilityStatsService: Statistics, trends, analytics calculations
 *
 * T053 INTEGRATION CHECKLIST:
 * 1. Import this controller in server.js: const vulnerabilityController = require("./app/controllers/vulnerabilityController");
 * 2. Initialize after database connection: vulnerabilityController.initialize(db, progressTracker);
 * 3. Register routes: app.use("/api/vulnerabilities", require("./app/routes/vulnerabilities"));
 * 4. Remove duplicate routes from server.js (see routes file for line numbers)
 * 5. Handle import/backup route conflicts as noted in routes file
 * 6. Ensure utility functions (mapVulnerabilityRow, extractScanDateFromFilename) remain in server.js
 */

const VulnerabilityService = require("../services/vulnerabilityService");
const VulnerabilityStatsService = require("../services/vulnerabilityStatsService");

class VulnerabilityController {
    constructor() {
        this.vulnerabilityService = new VulnerabilityService();
        this.vulnerabilityStatsService = new VulnerabilityStatsService();
        this.progressTracker = null; // Will be injected during initialization
    }

    /**
     * Initialize controller with database connection and progress tracker
     * Called from server.js during setup
     */
    static initialize(database, progressTracker) {
        if (!VulnerabilityController.instance) {
            VulnerabilityController.instance = new VulnerabilityController();
        }
        VulnerabilityController.instance.vulnerabilityService.initialize(database);
        VulnerabilityController.instance.vulnerabilityStatsService.initialize(database);
        VulnerabilityController.instance.progressTracker = progressTracker;
        return VulnerabilityController.instance;
    }

    /**
     * Get singleton instance (for use in routes)
     */
    static getInstance() {
        if (!VulnerabilityController.instance) {
            throw new Error("VulnerabilityController not initialized. Call initialize() first.");
        }
        return VulnerabilityController.instance;
    }

    /**
     * Get vulnerability statistics with VPR totals.
     *
     * Legacy behaviour (mirrors server.js) returns an object keyed by lowercase
     * severity rather than the raw array produced by the stats service. The
     * frontendâ€™s dashboard cards expect this shape, so we rebuild it here.
     *
     * Extracted from server.js lines 1996-2016.
     */
    static async getStats(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const statsArray = await controller.vulnerabilityStatsService.getStats();

            // Mirror legacy server.js behaviour: return object keyed by lowercase severity
            const stats = {};
            statsArray.forEach(row => {
                if (!row || !row.severity) {return;}
                const severityKey = row.severity.toLowerCase();
                stats[severityKey] = {
                    count: row.count || 0,
                    total_vpr: row.total_vpr || 0,
                    avg_vpr: row.avg_vpr || 0,
                    earliest: row.earliest || null,
                    latest: row.latest || null
                };
            });

            res.json(stats);
        } catch (error) {
            console.error("Error fetching vulnerability stats:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch vulnerability statistics",
                details: error.message
            });
        }
    }

    /**
     * Get recent vulnerability statistics with trend comparison (for dashboard cards)
     * Extracted from server.js lines 2019-2092
     */
    static async getRecentTrends(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const trends = await controller.vulnerabilityStatsService.getRecentTrends();
            res.json(trends);
        } catch (error) {
            console.error("Error fetching recent trends:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch recent trends",
                details: error.message
            });
        }
    }

    /**
     * Get historical trending data with optional date range
     * Extracted from server.js lines 2095-2156
     */
    static async getTrends(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const { startDate, endDate } = req.query;
            const trends = await controller.vulnerabilityStatsService.getTrends(startDate, endDate);
            res.json(trends);
        } catch (error) {
            console.error("Error fetching trends:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch historical trends",
                details: error.message
            });
        }
    }

    /**
     * Get vulnerabilities with pagination and filtering
     * Extracted from server.js lines 2159-2218
     */
    static async getVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const page = parseInt(req.query.page, 10) || 1;
            const limit = parseInt(req.query.limit, 10) || 50;
            const search = req.query.search || "";
            const severity = req.query.severity || "";

            const result = await controller.vulnerabilityService.getVulnerabilities({
                page,
                limit,
                search,
                severity
            });

            res.json(result);
        } catch (error) {
            console.error("Error fetching vulnerabilities:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch vulnerabilities",
                details: error.message
            });
        }
    }

    /**
     * Get resolved/fixed vulnerabilities (for troubleshooting and historical analysis)
     * Extracted from server.js lines 2221-2283
     */
    static async getResolvedVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const page = parseInt(req.query.page, 10) || 1;
            const limit = parseInt(req.query.limit, 10) || 50;
            const search = req.query.search || "";

            const result = await controller.vulnerabilityService.getResolvedVulnerabilities({
                page,
                limit,
                search
            });

            res.json({
                ...result,
                note: "These vulnerabilities were marked as resolved/fixed when they disappeared from scans"
            });
        } catch (error) {
            console.error("Error fetching resolved vulnerabilities:", error);
            res.status(500).json({
                success: false,
                error: "Failed to fetch resolved vulnerabilities",
                details: error.message
            });
        }
    }

    /**
     * Import CSV vulnerabilities (standard processing)
     * Extracted from server.js lines 2337-2399
     */
    static async importCSV(req, res) {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: "No file uploaded"
            });
        }

        try {
            const controller = VulnerabilityController.getInstance();
            const startTime = Date.now();
            const filename = req.file.originalname;
            const vendor = req.body.vendor || "unknown";
            const scanDate = req.body.scanDate || null; // Let service handle date extraction

            const result = await controller.vulnerabilityService.importCSV({
                filePath: req.file.path,
                filename,
                vendor,
                scanDate,
                fileSize: req.file.size,
                startTime
            });

            res.json({
                success: true,
                data: result,
                message: `Import completed in ${Date.now() - startTime}ms`
            });
        } catch (error) {
            console.error("CSV import failed:", error);
            res.status(500).json({
                success: false,
                error: "CSV import failed",
                details: error.message
            });
        }
    }

    /**
     * High-performance CSV import using staging table
     * Extracted from server.js lines 2403-2514
     */
    static async importCsvStaging(req, res) {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: "No file uploaded"
            });
        }

        try {
            const controller = VulnerabilityController.getInstance();
            const startTime = Date.now();
            const filename = req.file.originalname;
            const vendor = req.body.vendor || "unknown";
            const scanDate = req.body.scanDate || null; // Let service handle date extraction
            const frontendSessionId = req.body.sessionId;

            // Create or use existing session for progress tracking
            let sessionId;
            if (frontendSessionId && controller.progressTracker) {
                sessionId = controller.progressTracker.createSessionWithId(frontendSessionId, {
                    operation: "csv-import",
                    filename: filename,
                    vendor: vendor,
                    scanDate: scanDate,
                    totalSteps: 3,
                    currentStep: 0
                });
            } else if (controller.progressTracker) {
                sessionId = controller.progressTracker.createSession({
                    operation: "csv-import",
                    filename: filename,
                    vendor: vendor,
                    scanDate: scanDate,
                    totalSteps: 3,
                    currentStep: 0
                });
            }

            console.log("ðŸš€ STAGING IMPORT: Starting high-performance CSV import");
            console.log(`ðŸ“Š File: ${filename}, Vendor: ${vendor}, Scan Date: ${scanDate}`);
            console.log(`ðŸ”„ Progress Session: ${sessionId}`);

            // Immediately return session ID to client
            res.json({
                success: true,
                sessionId: sessionId,
                message: "CSV import started",
                filename: filename,
                vendor: vendor,
                scanDate: scanDate
            });

            // Process import asynchronously
            controller.vulnerabilityService.importCSVStaging({
                filePath: req.file.path,
                filename,
                vendor,
                scanDate,
                fileSize: req.file.size,
                startTime,
                sessionId,
                progressTracker: controller.progressTracker
            }).catch(error => {
                console.error("Staging import failed:", error);
                if (controller.progressTracker && sessionId) {
                    controller.progressTracker.errorSession(sessionId, "Import failed: " + error.message, { error });
                }
            });

        } catch (error) {
            console.error("Staging import initialization failed:", error);
            res.status(500).json({
                success: false,
                error: "Failed to initialize staging import",
                details: error.message
            });
        }
    }

    /**
     * Clear all vulnerability data
     * Extracted from server.js lines 2517-2531
     */
    static async clearAllData(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            await controller.vulnerabilityService.clearAllData();
            res.json({
                success: true,
                message: "All vulnerability data cleared from rollover architecture"
            });
        } catch (error) {
            console.error("Error clearing vulnerability data:", error);
            res.status(500).json({
                success: false,
                error: "Failed to clear vulnerability data",
                details: error.message
            });
        }
    }

    /**
     * Export vulnerability data for backup
     * Extracted from server.js lines 3304-3317
     * NOTE: This should be handled by backup system, but included for completeness
     */
    static async exportVulnerabilities(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const exportData = await controller.vulnerabilityService.exportVulnerabilities();
            res.json(exportData);
        } catch (error) {
            console.error("Error exporting vulnerabilities:", error);
            res.status(500).json({
                success: false,
                error: "Export failed",
                details: error.message
            });
        }
    }

    /**
     * Import vulnerabilities from web-based JSON data
     * Extracted from server.js lines 3501-3565
     * NOTE: This should be handled by import system, but included for completeness
     */
    static async importVulnerabilitiesWeb(req, res) {
        try {
            const controller = VulnerabilityController.getInstance();
            const csvData = req.body.data || [];

            if (!Array.isArray(csvData) || csvData.length === 0) {
                return res.status(400).json({
                    success: false,
                    error: "No data provided"
                });
            }

            const result = await controller.vulnerabilityService.importVulnerabilitiesWeb(csvData);
            res.json({
                success: true,
                imported: result.imported,
                total: csvData.length,
                errors: result.errors.length > 0 ? result.errors : undefined
            });
        } catch (error) {
            console.error("Web import failed:", error);
            res.status(500).json({
                success: false,
                error: "Web import failed",
                details: error.message
            });
        }
    }
}

module.exports = VulnerabilityController;
