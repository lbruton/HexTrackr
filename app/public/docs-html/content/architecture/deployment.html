<!-- Fragment template for documentation content injected by docs-tabler.js -->
<section class="doc-fragment">
    <div class="alert alert-info d-flex align-items-center mb-4" role="alert">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon me-2 text-info" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <path d="M12 9v4"/>
        <path d="M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z"/>
        <path d="M12 16h.01"/>
    </svg>
    <div>
        <strong>Active Specification:</strong> 004
        <small class="d-block text-muted">This documentation is being actively updated as part of the current specification development.</small>
    </div>
</div>
    <h1>Deployment Architecture</h1>
<p>This document describes how HexTrackr is packaged and deployed. The current deployment target is a single Docker container that serves:</p>
<ul>
<li>The Node.js/Express API (<code>server.js</code>)</li>
<li>Static frontend pages (<code>tickets.html</code>, <code>vulnerabilities.html</code> and related assets)</li>
<li>The generated documentation portal (<code>/docs-html</code>)</li>
</ul>
<blockquote>
<p>Scope: Operational packaging, runtime topology, environment configuration, persistence, and production hardening considerations.</p>
</blockquote>
<hr>
<h2>Container Topology</h2>
<p>HexTrackr runs as a single process inside one container (monolith pattern). No sidecars or auxiliary services are required (SQLite is an embedded file, not a network service).</p>
<pre><code class="language-text">┌────────────────────────────────────────────┐
│ HexTrackr Container                        │
│  • Node.js (Express)                       │
│  • SQLite file DB (data/hextrackr.db)      │
│  • Static assets + docs portal             │
└────────────────────────────────────────────┘
</code></pre>
<h3>Characteristics</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>Base Image</td>
<td>Official Node Alpine (see <code>Dockerfile.node</code>)</td>
</tr>
<tr>
<td>Process Model</td>
<td>Single node process started via <code>node server.js</code></td>
</tr>
<tr>
<td>Persistence</td>
<td>Bind-mounted <code>data/</code> directory for the SQLite file</td>
</tr>
<tr>
<td>Health Probe</td>
<td><code>GET /health</code> (returns JSON with status, version, uptime)</td>
</tr>
<tr>
<td>Port</td>
<td>8080 (container &amp; host)</td>
</tr>
<tr>
<td>Logging</td>
<td>Stdout/stderr (structured JSON not yet implemented)</td>
</tr>
</tbody></table>
<hr>
<h2>Docker Compose Layer</h2>
<p><code>docker-compose.yml</code> orchestrates the lone service:</p>
<table>
<thead>
<tr>
<th>Service</th>
<th>Purpose</th>
<th>Key Config</th>
</tr>
</thead>
<tbody><tr>
<td><code>hextrackr</code></td>
<td>Runs the monolithic app</td>
<td>Port 8080, bind mounts for code &amp; DB</td>
</tr>
</tbody></table>
<h3>Notable Compose Settings</h3>
<ul>
<li><code>volumes</code>:<ul>
<li><code>.:/app</code> (live‑reload style development inside container)</li>
<li><code>./data:/app/data</code> (persists SQLite across restarts)</li>
</ul>
</li>
<li><code>environment</code>:<ul>
<li><code>NODE_ENV=development</code> (current default; production overrides recommended)</li>
</ul>
</li>
<li><code>restart: unless-stopped</code> ensures resilience to host reboots.</li>
</ul>
<hr>
<h2>Image Build (Dockerfile.node)</h2>
<p>Responsibilities:</p>
<ol>
<li>Set up Node runtime</li>
<li>Copy <code>package.json</code> / install dependencies</li>
<li>Copy application source (including docs, scripts, styles)</li>
<li>Expose port 8080</li>
<li>Define default command (<code>node server.js</code>)</li>
</ol>
<h3>Build Context Notes</h3>
<ul>
<li><code>.dockerignore</code> (not yet present) should be added in future to trim build context (node_modules, logs, backups).</li>
<li>Dev workflows mount the repo; production builds should use multi‑stage with a slimmer final image.</li>
</ul>
<hr>
<h2>Persistence Strategy</h2>
<table>
<thead>
<tr>
<th>Data</th>
<th>Location</th>
<th>Retention</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>SQLite DB</td>
<td><code>data/hextrackr.db</code></td>
<td>Persistent via bind mount</td>
<td>Contains tickets, vulnerability rollover tables, imports, snapshots, daily totals</td>
</tr>
<tr>
<td>Upload Temp Files</td>
<td><code>uploads/</code></td>
<td>Ephemeral</td>
<td>CSV uploads removed post‑processing via <code>PathValidator.safeUnlinkSync</code></td>
</tr>
<tr>
<td>Generated Docs</td>
<td><code>docs-html/</code></td>
<td>Rebuilt on demand</td>
<td>Static assets baked into image or served from mounted source</td>
</tr>
<tr>
<td>Backups</td>
<td><code>backups/</code></td>
<td>Manual snapshots</td>
<td>Folder contains timestamped HTML/DB backups</td>
</tr>
</tbody></table>
<hr>
<h2>Environment Variables</h2>
<p>Current minimal set (implicit defaults):</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Default</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>PORT</code></td>
<td>8080</td>
<td>External listening port</td>
</tr>
<tr>
<td><code>NODE_ENV</code></td>
<td>development</td>
<td>Influences Express behavior/perf hints</td>
</tr>
</tbody></table>
<p>Planned / Recommended additions (future hardening):</p>
<ul>
<li><code>HEXTRACKR_MAX_UPLOAD_MB</code> (override CSV limit)</li>
<li><code>HEXTRACKR_DB_PATH</code> (custom database path for clustered storage)</li>
<li><code>LOG_LEVEL</code> (structured logging control)</li>
</ul>
<hr>
<h2>Security &amp; Hardening</h2>
<table>
<thead>
<tr>
<th>Area</th>
<th>Current State</th>
<th>Improvement Opportunities</th>
</tr>
</thead>
<tbody><tr>
<td>File System Access</td>
<td>Guarded by in‑process <code>PathValidator</code></td>
<td>Add central audit logging for rejected paths</td>
</tr>
<tr>
<td>Network Surface</td>
<td>Single HTTP port</td>
<td>Optional reverse proxy (Nginx / Traefik) for TLS + rate limiting</td>
</tr>
<tr>
<td>TLS</td>
<td>Terminated externally (not bundled)</td>
<td>Provide sample compose with Caddy / nginx TLS termination</td>
</tr>
<tr>
<td>Dependency Risk</td>
<td>Managed via <code>package.json</code></td>
<td>Add CI vulnerability scanning (Trivy, npm audit)</td>
</tr>
<tr>
<td>Resource Limits</td>
<td>Not specified</td>
<td>Add CPU &amp; memory limits in compose / k8s spec</td>
</tr>
</tbody></table>
<hr>
<h2>Health &amp; Monitoring</h2>
<ul>
<li>Liveness/readiness: <code>GET /health</code> (returns <code>{ status, version, db, uptime }</code>).</li>
<li>Suggested production enhancements:<ul>
<li>Add metric endpoint (Prometheus format) for import counts &amp; query timing.</li>
<li>Add structured log lines (JSON) with request timing.</li>
</ul>
</li>
</ul>
<hr>
<h2>Deployment Workflow (Current)</h2>
<ol>
<li>Clone repository</li>
<li>Run <code>docker compose up --build</code></li>
<li>Access app at <code>http://localhost:8080</code></li>
<li>Load tickets (<code>/tickets.html</code>) or vulnerabilities (<code>/vulnerabilities.html</code>)</li>
<li>Import CSV via UI or API (<code>POST /api/vulnerabilities/import</code>)</li>
</ol>
<h3>Future Production Path (Planned)</h3>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td>Build</td>
<td>CI builds image, runs lint/tests, embeds version metadata</td>
</tr>
<tr>
<td>Scan</td>
<td>Security scan (Trivy) gating push</td>
</tr>
<tr>
<td>Push</td>
<td>Publish to registry (e.g., GHCR)</td>
</tr>
<tr>
<td>Deploy</td>
<td>Pull pinned digest into orchestrator (k8s / ECS / Nomad)</td>
</tr>
<tr>
<td>Observe</td>
<td>Metrics + logs + health checks</td>
</tr>
</tbody></table>
<hr>
<h2>Scaling Considerations</h2>
<p>While single‑node is sufficient now, future scale paths:</p>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Option</th>
</tr>
</thead>
<tbody><tr>
<td>Concurrent Imports</td>
<td>Serialize (already sequential); queue via lightweight worker if needed</td>
</tr>
<tr>
<td>Read Throughput</td>
<td>Add SQLite WAL mode &amp; connection pooling (read replicas not supported natively)</td>
</tr>
<tr>
<td>HA</td>
<td>Migrate to PostgreSQL and split services (import worker vs API)</td>
</tr>
<tr>
<td>Static Assets</td>
<td>CDN offload for docs &amp; JS bundles</td>
</tr>
</tbody></table>
<hr>
<h2>Backup &amp; Recovery</h2>
<table>
<thead>
<tr>
<th>Action</th>
<th>Method</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>On‑Demand Export</td>
<td><code>GET /api/backup/all</code></td>
<td>JSON payload of tickets &amp; legacy vulnerabilities</td>
</tr>
<tr>
<td>Rollover Tables</td>
<td>Reconstructed via re‑imports</td>
<td>Preserve original CSV archives externally</td>
</tr>
<tr>
<td>Point‑in‑Time</td>
<td>Copy <code>data/hextrackr.db</code></td>
<td>Quiesce writes during copy for integrity</td>
</tr>
</tbody></table>
<p>Add a cron (external) to snapshot <code>data/</code> daily.</p>
<hr>
<h2>Known Gaps (Tracked for v1.0.5)</h2>
<ul>
<li>No <code>.dockerignore</code> (inflated build context)</li>
<li>No production multi‑stage image</li>
<li>No automated vulnerability scan in pipeline</li>
<li>No TLS termination example</li>
<li>No environment variable schema validation</li>
</ul>
<hr>
<h2>Summary</h2>
<p>HexTrackr’s deployment is intentionally simple: one container, embedded database, fast startup. This keeps operational overhead low while the product matures. The outlined enhancements chart a clear path toward production hardening without premature complexity.</p>

    <!-- Note: This file is intentionally minimal. The full page scaffold, header, footer, and scripts
             are provided by docs-html/index.html. Content generated using this template will be
             fetched and injected into #content-container by docs-html/js/docs-portal-v2.js. -->
</section>
