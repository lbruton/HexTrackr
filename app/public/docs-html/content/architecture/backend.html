<!-- Fragment template for documentation content injected by docs-tabler.js -->
<section class="doc-fragment">
    <h1>Backend Architecture</h1>
<p>The backend is a Node.js/Express monolith providing REST endpoints, rollover ingestion, documentation delivery, and SQLite persistence. It serves the static frontend pages (<code>tickets.html</code>, <code>vulnerabilities.html</code>) and the generated documentation portal (<code>/docs-html</code>).</p>
<hr>
<h2>Key Characteristics</h2>
<ul>
<li><strong>Monolithic File</strong>: <code>server.js</code> (≈1,700+ lines) – routes, DB init, rollover logic, backups, static serving.</li>
<li><strong>Unified Delivery</strong>: API + static assets + docs from one process.</li>
<li><strong>Embedded DB</strong>: Single SQLite file (<code>data/hextrackr.db</code>). No external service dependency.</li>
<li><strong>Security Utilities</strong>: In‑process <code>PathValidator</code> for safe file operations + security headers.</li>
</ul>
<hr>
<h2>Core Components</h2>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>server.js</code></td>
<td>Main application runtime (all routes + logic)</td>
</tr>
<tr>
<td><code>scripts/init-database.js</code></td>
<td>Bootstrap base schema &amp; indexes (legacy + foundational tables)</td>
</tr>
<tr>
<td>Rollover Functions</td>
<td>Sequential import processing &amp; aggregation (<code>processVulnerabilityRowsWithRollover</code>)</td>
</tr>
<tr>
<td><code>PathValidator</code></td>
<td>Normalizes &amp; validates file paths (defense-in-depth)</td>
</tr>
<tr>
<td>Docs Portal Logic</td>
<td>Dynamic redirect + stats endpoint (<code>/api/docs/stats</code>)</td>
</tr>
</tbody></table>
<hr>
<h2>Middleware &amp; Infrastructure</h2>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>CORS</td>
<td><code>cors()</code> (open by default)</td>
</tr>
<tr>
<td>Compression</td>
<td><code>compression()</code></td>
</tr>
<tr>
<td>Parsing</td>
<td><code>express.json</code> &amp; <code>express.urlencoded</code> (100MB limit)</td>
</tr>
<tr>
<td>Uploads</td>
<td><code>multer</code> (CSV import; 100MB cap)</td>
</tr>
<tr>
<td>Security Headers</td>
<td><code>X-Content-Type-Options</code>, <code>X-Frame-Options</code>, <code>X-XSS-Protection</code></td>
</tr>
<tr>
<td>Static Assets</td>
<td><code>express.static</code> (root + <code>docs-html/</code>)</td>
</tr>
</tbody></table>
<hr>
<h2>Persistence &amp; Schema Evolution</h2>
<ul>
<li><strong>Initialization</strong>: If DB missing, runs <code>scripts/init-database.js</code>.</li>
<li><strong>Runtime Evolution</strong>: Idempotent <code>ALTER TABLE</code> adds new columns (<code>vendor</code>, <code>vulnerability_date</code>, <code>state</code>, <code>import_date</code>, etc.) to legacy tables for backward compatibility.</li>
<li><strong>Rollover Tables</strong>: Created on startup if absent (<code>vulnerability_snapshots</code>, <code>vulnerabilities_current</code>, <code>vulnerability_daily_totals</code>).</li>
</ul>
<p>See: <a href="#data-model">Data Model</a> for exhaustive schema &amp; index inventory.</p>
<hr>
<h2>Vulnerability Rollover Workflow</h2>
<p>Purpose: Maintain real‑time deduplicated active set + full historical timeline + fast daily aggregates.</p>
<h3>CSV Import (Rollover Path)</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant API as server.js
    participant DB as SQLite

    User-&gt;&gt;API: POST /api/vulnerabilities/import (multipart/form-data + scanDate)
    API-&gt;&gt;API: Parse CSV (PapaParse, filter empty rows)
    API-&gt;&gt;DB: INSERT vulnerability_imports
    API-&gt;&gt;DB: UPDATE vulnerabilities_current (mark potentially stale)
    loop Each row (sequential to prevent race conditions)
        API-&gt;&gt;API: Map + generate unique_key
        API-&gt;&gt;DB: INSERT vulnerability_snapshots
        API-&gt;&gt;DB: INSERT or UPDATE vulnerabilities_current
    end
    API-&gt;&gt;DB: DELETE stale rows (not seen in this scan)
    API-&gt;&gt;DB: INSERT OR REPLACE vulnerability_daily_totals
    API--&gt;&gt;User: { importId, insertCount, updateCount, removedStale, scanDate }
</code></pre>
<h3>Key Safeguards</h3>
<table>
<thead>
<tr>
<th>Risk</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody><tr>
<td>Row duplication in batch</td>
<td>In‑memory <code>Set</code> of processed unique_keys</td>
</tr>
<tr>
<td>Race conditions</td>
<td>Explicit sequential loop instead of <code>forEach</code> callbacks</td>
</tr>
<tr>
<td>Data drift</td>
<td>Historical record preserved in snapshots before updates</td>
</tr>
<tr>
<td>Performance</td>
<td>Indexes on <code>unique_key</code>, <code>scan_date</code>, severities</td>
</tr>
</tbody></table>
<hr>
<h2>API Surface (High-Level)</h2>
<table>
<thead>
<tr>
<th>Domain</th>
<th>Endpoints (Examples)</th>
</tr>
</thead>
<tbody><tr>
<td>Health</td>
<td><code>GET /health</code></td>
</tr>
<tr>
<td>Vulnerabilities (Current)</td>
<td><code>GET /api/vulnerabilities</code>, <code>/stats</code>, <code>/recent-trends</code>, <code>/trends</code></td>
</tr>
<tr>
<td>Vulnerability Import</td>
<td><code>POST /api/vulnerabilities/import</code> (rollover), <code>POST /api/import/vulnerabilities</code> (legacy)</td>
</tr>
<tr>
<td>Tickets</td>
<td><code>GET/POST/PUT/DELETE /api/tickets</code>, <code>POST /api/tickets/migrate</code>, <code>POST /api/import/tickets</code></td>
</tr>
<tr>
<td>Reference</td>
<td><code>GET /api/sites</code>, <code>GET /api/locations</code></td>
</tr>
<tr>
<td>Backup/Restore</td>
<td><code>GET /api/backup/stats</code>, <code>GET /api/backup/all</code>, <code>POST /api/restore</code>, clear endpoints</td>
</tr>
<tr>
<td>Documentation</td>
<td><code>GET /api/docs/stats</code>, <code>/docs-html</code> SPA shell &amp; hash routing</td>
</tr>
</tbody></table>
<hr>
<h2>Real-time Communication (WebSocket)</h2>
<p>In addition to the REST API, HexTrackr utilizes a WebSocket server for real-time communication with clients.</p>
<ul>
<li><strong>Port</strong>: 8080</li>
<li><strong>Library</strong>: Socket.io</li>
</ul>
<p>The WebSocket server is primarily used to provide real-time feedback on long-running processes, such as data imports. It emits events to the client to indicate progress, completion, or errors.</p>
<p>For more details, see the <a href="#api-reference/websocket-api">WebSocket API documentation</a>.</p>
<hr>
<h2>Pagination Flow (Current Vulnerabilities)</h2>
<pre><code class="language-mermaid">sequenceDiagram
    participant UI
    participant API as server.js
    participant DB as SQLite
    UI-&gt;&gt;API: GET /api/vulnerabilities?page=1&amp;limit=50
    API-&gt;&gt;DB: SELECT filtered rows FROM vulnerabilities_current LIMIT/OFFSET
    DB--&gt;&gt;API: Row batch
    API-&gt;&gt;DB: SELECT COUNT(*) (same filters)
    DB--&gt;&gt;API: Total
    API--&gt;&gt;UI: { data, pagination }
</code></pre>
<hr>
<h2>Legacy vs Rollover Paths</h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Legacy <code>vulnerabilities</code></th>
<th>Rollover Tables</th>
</tr>
</thead>
<tbody><tr>
<td>Purpose</td>
<td>Early ingestion &amp; export</td>
<td>Current production analytics</td>
</tr>
<tr>
<td>Dedupe</td>
<td>Unique per (hostname, cve, import_date) index</td>
<td>Algorithmic unique_key with hostname normalization</td>
</tr>
<tr>
<td>History</td>
<td>Implicit (one row per scan)</td>
<td>Explicit snapshots + daily aggregates</td>
</tr>
<tr>
<td>Future</td>
<td>To be deprecated</td>
<td>Strategic direction</td>
</tr>
</tbody></table>
<hr>
<h2>Utility Endpoints</h2>
<ul>
<li><strong><code>GET /health</code></strong>: <code>{ status, version, db, uptime }</code></li>
<li><strong><code>GET /api/docs/stats</code></strong>: Counts routes + approximates function definitions.</li>
<li><strong>Backup</strong>: Returns structured JSON (vulnerabilities legacy + tickets) or combined.</li>
</ul>
<hr>
<h2>Security &amp; Hardening</h2>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Current</th>
<th>Planned</th>
</tr>
</thead>
<tbody><tr>
<td>File access</td>
<td><code>PathValidator</code></td>
<td>Central audit logging of rejections</td>
</tr>
<tr>
<td>Upload size</td>
<td>100MB cap</td>
<td>Configurable env var (<code>HEXTRACKR_MAX_UPLOAD_MB</code>)</td>
</tr>
<tr>
<td>TLS</td>
<td>External termination</td>
<td>Compose example with Caddy / nginx</td>
</tr>
<tr>
<td>Input validation</td>
<td>Minimal (mapping layer)</td>
<td>JSON schema (Ajv) enforcement</td>
</tr>
<tr>
<td>Logging</td>
<td>Console + stderr</td>
<td>Structured JSON + request IDs</td>
</tr>
</tbody></table>
<hr>
<h2>Planned Enhancements</h2>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
</tr>
</thead>
<tbody><tr>
<td>Observability</td>
<td>Prometheus metrics (import latency, row counts)</td>
</tr>
<tr>
<td>Modularization</td>
<td>Extract rollover &amp; backup modules</td>
</tr>
<tr>
<td>Validation</td>
<td>Enforce severity enumeration + CVE format checks</td>
</tr>
<tr>
<td>Migration</td>
<td>Retire legacy vulnerabilities pathway</td>
</tr>
<tr>
<td>Testing</td>
<td>Playwright + API contract tests for import &amp; pagination</td>
</tr>
</tbody></table>
<hr>
<h2>Summary</h2>
<p>The backend favors simplicity (single process, embedded DB) while implementing a robust rollover pipeline for vulnerability lifecycle tracking. Incremental improvements will focus on modularity, observability, and deprecating legacy ingestion paths.</p>

    <!-- Note: This file is intentionally minimal. The full page scaffold, header, footer, and scripts
             are provided by docs-html/index.html. Content generated using this template will be
             fetched and injected into #content-container by docs-html/js/docs-portal-v2.js. -->
</section>
