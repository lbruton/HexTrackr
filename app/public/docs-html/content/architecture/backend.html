<!-- Fragment template for documentation content injected by docs-tabler.js -->
<section class="doc-fragment">
    <h1>Backend Architecture</h1>
<p>The backend is a modular Node.js/Express application providing REST endpoints, rollover ingestion, documentation delivery, and SQLite persistence. It serves the static frontend pages (<code>tickets.html</code>, <code>vulnerabilities.html</code>) and the generated documentation portal (<code>/docs-html</code>).</p>
<hr>
<h2>Key Characteristics</h2>
<ul>
<li><strong>Modular Architecture</strong>: <code>server.js</code> (~205 lines) orchestrates modular components across multiple directories.</li>
<li><strong>Separation of Concerns</strong>: Controllers, services, routes, and configuration are cleanly separated.</li>
<li><strong>Unified Delivery</strong>: API + static assets + docs from one process.</li>
<li><strong>Embedded DB</strong>: Single SQLite file (<code>data/hextrackr.db</code>). No external service dependency.</li>
<li><strong>Security Utilities</strong>: Extracted <code>PathValidator</code> class for safe file operations + security headers.</li>
</ul>
<hr>
<h2>Core Components</h2>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
<th>Location</th>
</tr>
</thead>
<tbody><tr>
<td><code>server.js</code></td>
<td>Main application runtime (orchestration + initialization)</td>
<td><code>/app/public/</code></td>
</tr>
<tr>
<td><strong>Controllers</strong></td>
<td>Business logic with singleton pattern</td>
<td><code>/app/controllers/</code></td>
</tr>
<tr>
<td><strong>Services</strong></td>
<td>Data access and business services</td>
<td><code>/app/services/</code></td>
</tr>
<tr>
<td><strong>Routes</strong></td>
<td>Express route definitions</td>
<td><code>/app/routes/</code></td>
</tr>
<tr>
<td><strong>Configuration</strong></td>
<td>Database, middleware, websocket configs</td>
<td><code>/app/config/</code></td>
</tr>
<tr>
<td><strong>Utilities</strong></td>
<td>PathValidator, ProgressTracker, helpers</td>
<td><code>/app/utils/</code></td>
</tr>
<tr>
<td><code>init-database.js</code></td>
<td>Bootstrap base schema &amp; indexes</td>
<td><code>/app/public/scripts/</code></td>
</tr>
<tr>
<td>Rate Limiting</td>
<td>IP-based request throttling (100 req/15min)</td>
<td>Express middleware</td>
</tr>
</tbody></table>
<h3>Module Organization</h3>
<table>
<thead>
<tr>
<th>Directory</th>
<th>Contents</th>
</tr>
</thead>
<tbody><tr>
<td><code>/app/controllers/</code></td>
<td><code>vulnerabilityController.js</code>, <code>ticketController.js</code>, <code>backupController.js</code>, <code>importController.js</code>, <code>docsController.js</code></td>
</tr>
<tr>
<td><code>/app/services/</code></td>
<td><code>databaseService.js</code>, <code>vulnerabilityService.js</code>, <code>vulnerabilityStatsService.js</code>, <code>ticketService.js</code></td>
</tr>
<tr>
<td><code>/app/routes/</code></td>
<td><code>vulnerabilities.js</code>, <code>tickets.js</code>, <code>backup.js</code>, <code>imports.js</code>, <code>docs.js</code></td>
</tr>
<tr>
<td><code>/app/config/</code></td>
<td><code>database.js</code>, <code>middleware.js</code>, <code>websocket.js</code></td>
</tr>
<tr>
<td><code>/app/utils/</code></td>
<td><code>PathValidator.js</code>, <code>ProgressTracker.js</code>, <code>helpers.js</code></td>
</tr>
</tbody></table>
<h3>PathValidator Security Class</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PathValidator</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">validatePath</span>(<span class="hljs-params">filePath</span>) {
    <span class="hljs-comment">// Path normalization</span>
    <span class="hljs-keyword">const</span> normalizedPath = path.<span class="hljs-title function_">normalize</span>(filePath);

    <span class="hljs-comment">// Traversal attack prevention</span>
    <span class="hljs-keyword">if</span> (normalizedPath.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;../&quot;</span>) || normalizedPath.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;..\\&quot;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Path traversal detected&quot;</span>);
    }

    <span class="hljs-comment">// Component validation</span>
    <span class="hljs-keyword">const</span> pathComponents = normalizedPath.<span class="hljs-title function_">split</span>(path.<span class="hljs-property">sep</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> component <span class="hljs-keyword">of</span> pathComponents) {
      <span class="hljs-keyword">if</span> (component === <span class="hljs-string">&quot;..&quot;</span> || (component === <span class="hljs-string">&quot;.&quot;</span> &amp;&amp; pathComponents.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid path component&quot;</span>);
      }
    }

    <span class="hljs-keyword">return</span> normalizedPath;
  }
}</code></pre><p><strong>Security Features</strong>:</p>
<ul>
<li>Path normalization before validation</li>
<li>Directory traversal attack prevention</li>
<li>Component-level validation</li>
<li>Safe file operation wrappers</li>
<li>Exception-based error handling</li>
</ul>
<hr>
<h2>Middleware &amp; Infrastructure</h2>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>CORS</td>
<td><code>cors()</code> (open by default)</td>
</tr>
<tr>
<td>Compression</td>
<td><code>compression()</code></td>
</tr>
<tr>
<td>Parsing</td>
<td><code>express.json</code> &amp; <code>express.urlencoded</code> (100MB limit)</td>
</tr>
<tr>
<td>Uploads</td>
<td><code>multer</code> (CSV import; 100 MB cap)</td>
</tr>
<tr>
<td>Security Headers</td>
<td><code>X-Content-Type-Options</code>, <code>X-Frame-Options</code>, <code>X-XSS-Protection</code></td>
</tr>
<tr>
<td>Static Assets</td>
<td><code>express.static</code> (root + <code>docs-html/</code>)</td>
</tr>
</tbody></table>
<hr>
<h2>Persistence &amp; Schema Evolution</h2>
<ul>
<li><strong>Initialization</strong>: If DB missing, runs <code>scripts/init-database.js</code>.</li>
<li><strong>Runtime Evolution</strong>: Idempotent <code>ALTER TABLE</code> adds new columns (<code>vendor</code>, <code>vulnerability_date</code>, <code>state</code>, <code>import_date</code>, etc.) to legacy tables for backward compatibility.</li>
<li><strong>Rollover Tables</strong>: Created on startup if absent (<code>vulnerability_snapshots</code>, <code>vulnerabilities_current</code>, <code>vulnerability_daily_totals</code>).</li>
</ul>
<p>See: <a href="#architecture/data-model">Data Model</a> for exhaustive schema &amp; index inventory.</p>
<hr>
<h2>Vulnerability Rollover Workflow</h2>
<p>Purpose: Maintain real-time deduplicated active set + full historical timeline + fast daily aggregates.</p>
<h3>CSV Import (Rollover Path)</h3>
<div class="mermaid">sequenceDiagram
    participant User
    participant API as server.js
    participant DB as SQLite

    User-&gt;&gt;API: POST /api/vulnerabilities/import (multipart/form-data + optional scanDate)
    API-&gt;&gt;API: Parse CSV (PapaParse, filter empty rows)
    API-&gt;&gt;DB: INSERT vulnerability_imports
    API-&gt;&gt;DB: UPDATE vulnerabilities_current (mark potentially stale)
    loop Each row (sequential to prevent race conditions)
        API-&gt;&gt;API: Map + generate unique_key
        API-&gt;&gt;DB: INSERT vulnerability_snapshots
        API-&gt;&gt;DB: INSERT or UPDATE vulnerabilities_current
    end
    API-&gt;&gt;DB: DELETE stale rows (not seen in this scan)
    API-&gt;&gt;DB: INSERT OR REPLACE vulnerability_daily_totals
    API--&gt;&gt;User: { importId, insertCount, updateCount, removedStale, scanDate, performanceMetrics }</div><blockquote>
<p><strong>Staging importer</strong>: <code>POST /api/vulnerabilities/import-staging</code> follows the same steps but first bulk loads data into <code>vulnerability_staging</code> and streams <code>ProgressTracker</code> events (<code>progress-update</code>, <code>progress-complete</code>, <code>progress-error</code>).</p>
</blockquote>
<h3>Enhanced Deduplication System</h3>
<p>HexTrackr implements a sophisticated 4-tier unique key generation strategy:</p>
<p><strong>Tier 1: Asset ID + Plugin ID</strong> (Highest Reliability)</p>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (mapped.<span class="hljs-property">assetId</span> &amp;&amp; mapped.<span class="hljs-property">pluginId</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`asset:<span class="hljs-subst">${mapped.assetId}</span>|plugin:<span class="hljs-subst">${mapped.pluginId}</span>`</span>;
}</code></pre><p><strong>Tier 2: CVE + Hostname/IP</strong> (CVE-based)</p>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (mapped.<span class="hljs-property">cve</span> &amp;&amp; mapped.<span class="hljs-property">cve</span>.<span class="hljs-title function_">trim</span>()) {
  <span class="hljs-keyword">const</span> hostIdentifier = normalizedIP || normalizedHostname;
  <span class="hljs-keyword">return</span> <span class="hljs-string">`cve:<span class="hljs-subst">${mapped.cve.trim()}</span>|host:<span class="hljs-subst">${hostIdentifier}</span>`</span>;
}</code></pre><p><strong>Tier 3: Plugin ID + Hostname/IP + Vendor</strong> (User-requested approach)</p>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (mapped.<span class="hljs-property">pluginId</span> &amp;&amp; mapped.<span class="hljs-property">pluginId</span>.<span class="hljs-title function_">trim</span>()) {
  <span class="hljs-keyword">const</span> hostIdentifier = normalizedIP || normalizedHostname;
  <span class="hljs-keyword">const</span> vendor = mapped.<span class="hljs-property">vendor</span> || <span class="hljs-string">&quot;unknown&quot;</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">`plugin:<span class="hljs-subst">${mapped.pluginId.trim()}</span>|host:<span class="hljs-subst">${hostIdentifier}</span>|vendor:<span class="hljs-subst">${vendor}</span>`</span>;
}</code></pre><p><strong>Tier 4: Description Hash + Hostname/IP</strong> (Fallback)</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> descriptionHash = <span class="hljs-title function_">createDescriptionHash</span>(mapped.<span class="hljs-property">description</span>);
<span class="hljs-keyword">const</span> hostIdentifier = normalizedIP || normalizedHostname;
<span class="hljs-keyword">return</span> <span class="hljs-string">`desc:<span class="hljs-subst">${descriptionHash}</span>|host:<span class="hljs-subst">${hostIdentifier}</span>`</span>;</code></pre><h3>Key Safeguards</h3>
<table>
<thead>
<tr>
<th>Risk</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody><tr>
<td>Row duplication in batch</td>
<td>In-memory <code>Set</code> of processed unique_keys</td>
</tr>
<tr>
<td>Race conditions</td>
<td>Explicit sequential loop with <code>processNextRow(index)</code> pattern</td>
</tr>
<tr>
<td>Data drift</td>
<td>Historical record preserved in snapshots before updates</td>
</tr>
<tr>
<td>Performance</td>
<td>Indexes on <code>unique_key</code>, <code>scan_date</code>, severities</td>
</tr>
<tr>
<td><strong>Key conflicts</strong></td>
<td><strong>4-tier unique key generation with reliability scoring</strong></td>
</tr>
<tr>
<td><strong>Memory leaks</strong></td>
<td><strong>Session-based processing with automatic cleanup</strong></td>
</tr>
<tr>
<td><strong>Hostname variations</strong></td>
<td><strong>Hostname normalization (domain stripping, case insensitive)</strong></td>
</tr>
<tr>
<td><strong>IP address formats</strong></td>
<td><strong>IP normalization and validation</strong></td>
</tr>
</tbody></table>
<hr>
<h2>API Surface (High-Level)</h2>
<table>
<thead>
<tr>
<th>Domain</th>
<th>Endpoints (Examples)</th>
</tr>
</thead>
<tbody><tr>
<td>Health</td>
<td><code>GET /health</code></td>
</tr>
<tr>
<td>Vulnerabilities (Current)</td>
<td><code>GET /api/vulnerabilities</code>, <code>/stats</code>, <code>/recent-trends</code>, <code>/trends</code></td>
</tr>
<tr>
<td>Vulnerability Import</td>
<td><code>POST /api/vulnerabilities/import</code> (rollover), <code>POST /api/vulnerabilities/import-staging</code> (staged), <code>POST /api/import/vulnerabilities</code> (JSON)</td>
</tr>
<tr>
<td>Tickets</td>
<td><code>GET/POST/PUT/DELETE /api/tickets</code>, <code>POST /api/tickets/migrate</code>, <code>POST /api/import/tickets</code></td>
</tr>
<tr>
<td>Reference</td>
<td><code>GET /api/sites</code>, <code>GET /api/locations</code></td>
</tr>
<tr>
<td>Backup/Restore</td>
<td><code>GET /api/backup/stats</code>, <code>GET /api/backup/all</code>, <code>POST /api/restore</code>, clear endpoints</td>
</tr>
<tr>
<td>Documentation</td>
<td><code>GET /api/docs/stats</code>, <code>/docs-html</code> SPA shell &amp; hash routing</td>
</tr>
</tbody></table>
<hr>
<h2>Real-time Communication (WebSocket)</h2>
<h3>ProgressTracker Architecture</h3>
<p>HexTrackr implements a sophisticated WebSocket-based progress tracking system through the <code>ProgressTracker</code> class:</p>
<ul>
<li><strong>Port</strong>: 8988 (separate from REST API)</li>
<li><strong>Library</strong>: Socket.io with enhanced session management</li>
<li><strong>Session Management</strong>: UUID-based sessions with metadata tracking</li>
<li><strong>Throttling</strong>: 100ms minimum interval between progress events</li>
<li><strong>Auto-cleanup</strong>: 30-minute session timeout with automatic garbage collection</li>
</ul>
<h3>ProgressTracker Features</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgressTracker</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">io</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sessions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventThrottle</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">THROTTLE_INTERVAL</span> = <span class="hljs-number">100</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">SESSION_CLEANUP_INTERVAL</span> = <span class="hljs-number">30</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
  }
}</code></pre><p><strong>Key Capabilities</strong>:</p>
<ul>
<li>Session-based progress tracking with unique identifiers</li>
<li>Throttled event emission to prevent client overload</li>
<li>Metadata persistence for operation context</li>
<li>Automatic session cleanup for memory management</li>
<li>Error handling with graceful degradation</li>
</ul>
<h3>WebSocket Events</h3>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Purpose</th>
<th>Throttled</th>
</tr>
</thead>
<tbody><tr>
<td><code>import_progress</code></td>
<td>CSV import progress updates</td>
<td>Yes (100ms)</td>
</tr>
<tr>
<td><code>import_complete</code></td>
<td>Import operation completion</td>
<td>No</td>
</tr>
<tr>
<td><code>import_error</code></td>
<td>Import operation errors</td>
<td>No</td>
</tr>
<tr>
<td><code>session_created</code></td>
<td>New session establishment</td>
<td>No</td>
</tr>
<tr>
<td><code>session_cleanup</code></td>
<td>Session removal notification</td>
<td>No</td>
</tr>
</tbody></table>
<h3>Session Lifecycle</h3>
<div class="mermaid">sequenceDiagram
    participant Client
    participant ProgressTracker
    participant Import as Import Process

    Client-&gt;&gt;ProgressTracker: Connect to WebSocket
    ProgressTracker-&gt;&gt;ProgressTracker: createSession(metadata)
    ProgressTracker--&gt;&gt;Client: session_created event

    Import-&gt;&gt;ProgressTracker: updateProgress(sessionId, progress)
    ProgressTracker-&gt;&gt;ProgressTracker: throttleCheck()
    alt Progress not throttled
        ProgressTracker--&gt;&gt;Client: import_progress event
    end

    Import-&gt;&gt;ProgressTracker: completeSession(sessionId)
    ProgressTracker--&gt;&gt;Client: import_complete event
    ProgressTracker-&gt;&gt;ProgressTracker: cleanup(sessionId)</div><p>For more details, see the <a href="#api-reference/websocket-api">WebSocket API documentation</a>.</p>
<hr>
<h2>Pagination Flow (Current Vulnerabilities)</h2>
<div class="mermaid">sequenceDiagram
    participant UI
    participant API as server.js
    participant DB as SQLite
    UI-&gt;&gt;API: GET /api/vulnerabilities?page=1&limit=50
    API-&gt;&gt;DB: SELECT filtered rows FROM vulnerabilities_current LIMIT/OFFSET
    DB--&gt;&gt;API: Row batch
    API-&gt;&gt;DB: SELECT COUNT(*) (same filters)
    DB--&gt;&gt;API: Total
    API--&gt;&gt;UI: { data, pagination }</div><hr>
<h2>Legacy vs Rollover Paths</h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Legacy <code>vulnerabilities</code></th>
<th>Rollover Tables</th>
</tr>
</thead>
<tbody><tr>
<td>Purpose</td>
<td>Early ingestion &amp; export</td>
<td>Current production analytics</td>
</tr>
<tr>
<td>Dedupe</td>
<td>Unique per (hostname, cve, import_date) index</td>
<td>Algorithmic unique_key with hostname normalization</td>
</tr>
<tr>
<td>History</td>
<td>Implicit (one row per scan)</td>
<td>Explicit snapshots + daily aggregates</td>
</tr>
<tr>
<td>Future</td>
<td>To be deprecated</td>
<td>Strategic direction</td>
</tr>
</tbody></table>
<hr>
<h2>Utility Endpoints</h2>
<ul>
<li><strong><code>GET /health</code></strong>: <code>{ status, version, db, uptime }</code></li>
<li><strong><code>GET /api/docs/stats</code></strong>: Counts routes + approximates function definitions.</li>
<li><strong>Backup</strong>: Returns structured JSON (vulnerabilities legacy + tickets) or combined.</li>
</ul>
<hr>
<h2>Security &amp; Hardening</h2>
<h3>Current Security Implementations</h3>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Implementation</th>
<th>Details</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Path Traversal</strong></td>
<td><code>PathValidator</code> class</td>
<td>Comprehensive path validation and safe file operations</td>
</tr>
<tr>
<td><strong>Rate Limiting</strong></td>
<td>Express rate limit middleware</td>
<td>100 requests per 15-minute window per IP</td>
</tr>
<tr>
<td><strong>Upload Security</strong></td>
<td>Multer with size limits</td>
<td>50MB cap with file type validation</td>
</tr>
<tr>
<td><strong>XSS Prevention</strong></td>
<td>Security headers</td>
<td><code>X-Content-Type-Options</code>, <code>X-Frame-Options</code>, <code>X-XSS-Protection</code></td>
</tr>
<tr>
<td><strong>SQL Injection</strong></td>
<td>Parameterized queries</td>
<td>All database operations use prepared statements</td>
</tr>
<tr>
<td><strong>CORS Protection</strong></td>
<td>Configurable CORS</td>
<td>Default: all origins (configurable for production)</td>
</tr>
<tr>
<td><strong>Input Sanitization</strong></td>
<td>DOMPurify integration</td>
<td>Client-side XSS prevention</td>
</tr>
</tbody></table>
<h3>PathValidator Security Features</h3>
<pre><code class="language-javascript"><span class="hljs-comment">// Safe file operations with built-in validation</span>
<span class="hljs-title class_">PathValidator</span>.<span class="hljs-title function_">safeReadFileSync</span>(filePath, options)
<span class="hljs-title class_">PathValidator</span>.<span class="hljs-title function_">safeWriteFileSync</span>(filePath, data, options)
<span class="hljs-title class_">PathValidator</span>.<span class="hljs-title function_">safeReaddirSync</span>(dirPath, options)
<span class="hljs-title class_">PathValidator</span>.<span class="hljs-title function_">safeStatSync</span>(filePath)
<span class="hljs-title class_">PathValidator</span>.<span class="hljs-title function_">safeExistsSync</span>(filePath)
<span class="hljs-title class_">PathValidator</span>.<span class="hljs-title function_">safeUnlinkSync</span>(filePath)</code></pre><p><strong>Protection Mechanisms</strong>:</p>
<ul>
<li>Path normalization before validation</li>
<li>Directory traversal detection (<code>../</code>, <code>..\\</code>)</li>
<li>Component-level path validation</li>
<li>Exception-based error handling</li>
<li>Graceful fallbacks for invalid paths</li>
</ul>
<h3>Rate Limiting Configuration</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> limiter = <span class="hljs-title function_">rateLimit</span>({
  <span class="hljs-attr">windowMs</span>: <span class="hljs-number">15</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 15 minutes</span>
  <span class="hljs-attr">max</span>: <span class="hljs-number">100</span>, <span class="hljs-comment">// Limit each IP to 100 requests per windowMs</span>
  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Too many requests from this IP&#x27;</span>,
  <span class="hljs-attr">standardHeaders</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">legacyHeaders</span>: <span class="hljs-literal">false</span>
});</code></pre><h3>Future Security Enhancements</h3>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Planned</th>
</tr>
</thead>
<tbody><tr>
<td>Authentication</td>
<td>JWT-based authentication with role-based access control</td>
</tr>
<tr>
<td>API Security</td>
<td>API key authentication for external integrations</td>
</tr>
<tr>
<td>Audit Logging</td>
<td>Central audit logging of security events and rejections</td>
</tr>
<tr>
<td>TLS</td>
<td>Built-in HTTPS support with automatic certificate management</td>
</tr>
<tr>
<td>Input Validation</td>
<td>JSON schema (Ajv) enforcement for all API endpoints</td>
</tr>
<tr>
<td>Structured Logging</td>
<td>Structured JSON logging with request IDs and correlation</td>
</tr>
<tr>
<td>Vulnerability Scanning</td>
<td>Automated dependency vulnerability scanning</td>
</tr>
<tr>
<td>Secret Management</td>
<td>Environment-based secret management with rotation</td>
</tr>
</tbody></table>
<hr>
<h2>Planned Enhancements</h2>
<h3>Observability &amp; Monitoring</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Metrics</strong></td>
<td>Prometheus metrics (import latency, row counts, session tracking)</td>
<td>High</td>
</tr>
<tr>
<td><strong>Tracing</strong></td>
<td>OpenTelemetry integration for distributed tracing</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Health Checks</strong></td>
<td>Enhanced health endpoints with dependency checking</td>
<td>High</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>APM integration for bottleneck identification</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Architecture &amp; Modularity</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Modularization</strong></td>
<td>Extract ProgressTracker, PathValidator, and rollover modules</td>
<td>High</td>
</tr>
<tr>
<td><strong>Microservices</strong></td>
<td>Split WebSocket server into separate service</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Database</strong></td>
<td>PostgreSQL migration for scalability</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>Redis integration for session and data caching</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Data Quality &amp; Validation</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Schema Validation</strong></td>
<td>JSON schema (Ajv) enforcement for all API endpoints</td>
<td>High</td>
</tr>
<tr>
<td><strong>CVE Validation</strong></td>
<td>Real-time CVE format and existence validation</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Severity Normalization</strong></td>
<td>Automatic severity enumeration mapping</td>
<td>High</td>
</tr>
<tr>
<td><strong>Data Quality Scoring</strong></td>
<td>Automated data quality metrics and reporting</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Legacy Migration</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Legacy Deprecation</strong></td>
<td>Retire legacy vulnerabilities table and endpoints</td>
<td>High</td>
</tr>
<tr>
<td><strong>Data Migration</strong></td>
<td>Automated migration from legacy to rollover architecture</td>
<td>High</td>
</tr>
<tr>
<td><strong>API Versioning</strong></td>
<td>Implement API versioning for backward compatibility</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Testing &amp; Quality Assurance</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>E2E Testing</strong></td>
<td>Playwright integration tests for all major workflows</td>
<td>High</td>
</tr>
<tr>
<td><strong>API Contract Testing</strong></td>
<td>OpenAPI-based contract validation</td>
<td>High</td>
</tr>
<tr>
<td><strong>Load Testing</strong></td>
<td>Automated performance testing with realistic data volumes</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Security Testing</strong></td>
<td>Automated security scanning and penetration testing</td>
<td>High</td>
</tr>
</tbody></table>
<hr>
<h2>Summary</h2>
<p>The backend favors simplicity (single process, embedded DB) while implementing a robust rollover pipeline for vulnerability lifecycle tracking. Incremental improvements will focus on modularity, observability, and deprecating legacy ingestion paths.</p>

    <!-- Note: This file is intentionally minimal. The full page scaffold, header, footer, and scripts
             are provided by docs-html/index.html. Content generated using this template will be
             fetched and injected into #content-container by docs-html/js/docs-portal-v2.js. -->
</section>
