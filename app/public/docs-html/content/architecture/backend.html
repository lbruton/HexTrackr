<!-- Fragment template for documentation content injected by docs-tabler.js -->
<section class="doc-fragment">
    <h1>Backend Architecture</h1>
<p>The backend is a Node.js/Express monolith providing REST endpoints, rollover ingestion, documentation delivery, and SQLite persistence. It serves the static frontend pages (<code>tickets.html</code>, <code>vulnerabilities.html</code>) and the generated documentation portal (<code>/docs-html</code>).</p>
<hr>
<h2>Key Characteristics</h2>
<ul>
<li><strong>Monolithic File</strong>: <code>server.js</code> (≈1,700+ lines) – routes, DB init, rollover logic, backups, static serving.</li>
<li><strong>Unified Delivery</strong>: API + static assets + docs from one process.</li>
<li><strong>Embedded DB</strong>: Single SQLite file (<code>data/hextrackr.db</code>). No external service dependency.</li>
<li><strong>Security Utilities</strong>: In‑process <code>PathValidator</code> for safe file operations + security headers.</li>
</ul>
<hr>
<h2>Core Components</h2>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
<th>Location</th>
</tr>
</thead>
<tbody><tr>
<td><code>server.js</code></td>
<td>Main application runtime (all routes + logic)</td>
<td>Root level</td>
</tr>
<tr>
<td><code>scripts/init-database.js</code></td>
<td>Bootstrap base schema &amp; indexes (legacy + foundational tables)</td>
<td><code>/scripts/</code></td>
</tr>
<tr>
<td><strong>ProgressTracker</strong></td>
<td>WebSocket session management &amp; progress tracking</td>
<td><code>server.js:82-200</code></td>
</tr>
<tr>
<td><strong>PathValidator</strong></td>
<td>Security-hardened file operations with traversal protection</td>
<td><code>server.js:22-79</code></td>
</tr>
<tr>
<td>Rollover Functions</td>
<td>Sequential import processing &amp; enhanced deduplication</td>
<td><code>server.js:500-800</code></td>
</tr>
<tr>
<td>Rate Limiting</td>
<td>IP-based request throttling (100 req/15min)</td>
<td>Express middleware</td>
</tr>
<tr>
<td>Docs Portal Logic</td>
<td>Dynamic redirect + stats endpoint (<code>/api/docs/stats</code>)</td>
<td><code>server.js:1200+</code></td>
</tr>
</tbody></table>
<h3>PathValidator Security Class</h3>
<pre><code class="language-javascript">class PathValidator {
  static validatePath(filePath) {
    // Path normalization
    const normalizedPath = path.normalize(filePath);

    // Traversal attack prevention
    if (normalizedPath.includes(&quot;../&quot;) || normalizedPath.includes(&quot;..\\&quot;)) {
      throw new Error(&quot;Path traversal detected&quot;);
    }

    // Component validation
    const pathComponents = normalizedPath.split(path.sep);
    for (const component of pathComponents) {
      if (component === &quot;..&quot; || (component === &quot;.&quot; &amp;&amp; pathComponents.length &gt; 1)) {
        throw new Error(&quot;Invalid path component&quot;);
      }
    }

    return normalizedPath;
  }
}
</code></pre>
<p><strong>Security Features</strong>:</p>
<ul>
<li>Path normalization before validation</li>
<li>Directory traversal attack prevention</li>
<li>Component-level validation</li>
<li>Safe file operation wrappers</li>
<li>Exception-based error handling</li>
</ul>
<hr>
<h2>Middleware &amp; Infrastructure</h2>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Implementation</th>
</tr>
</thead>
<tbody><tr>
<td>CORS</td>
<td><code>cors()</code> (open by default)</td>
</tr>
<tr>
<td>Compression</td>
<td><code>compression()</code></td>
</tr>
<tr>
<td>Parsing</td>
<td><code>express.json</code> &amp; <code>express.urlencoded</code> (100MB limit)</td>
</tr>
<tr>
<td>Uploads</td>
<td><code>multer</code> (CSV import; 100MB cap)</td>
</tr>
<tr>
<td>Security Headers</td>
<td><code>X-Content-Type-Options</code>, <code>X-Frame-Options</code>, <code>X-XSS-Protection</code></td>
</tr>
<tr>
<td>Static Assets</td>
<td><code>express.static</code> (root + <code>docs-html/</code>)</td>
</tr>
</tbody></table>
<hr>
<h2>Persistence &amp; Schema Evolution</h2>
<ul>
<li><strong>Initialization</strong>: If DB missing, runs <code>scripts/init-database.js</code>.</li>
<li><strong>Runtime Evolution</strong>: Idempotent <code>ALTER TABLE</code> adds new columns (<code>vendor</code>, <code>vulnerability_date</code>, <code>state</code>, <code>import_date</code>, etc.) to legacy tables for backward compatibility.</li>
<li><strong>Rollover Tables</strong>: Created on startup if absent (<code>vulnerability_snapshots</code>, <code>vulnerabilities_current</code>, <code>vulnerability_daily_totals</code>).</li>
</ul>
<p>See: <a href="#architecture/data-model">Data Model</a> for exhaustive schema &amp; index inventory.</p>
<hr>
<h2>Vulnerability Rollover Workflow</h2>
<p>Purpose: Maintain real‑time deduplicated active set + full historical timeline + fast daily aggregates.</p>
<h3>CSV Import (Rollover Path)</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant API as server.js
    participant DB as SQLite

    User-&gt;&gt;API: POST /api/vulnerabilities/import (multipart/form-data + scanDate)
    API-&gt;&gt;API: Parse CSV (PapaParse, filter empty rows)
    API-&gt;&gt;DB: INSERT vulnerability_imports
    API-&gt;&gt;DB: UPDATE vulnerabilities_current (mark potentially stale)
    loop Each row (sequential to prevent race conditions)
        API-&gt;&gt;API: Map + generate unique_key
        API-&gt;&gt;DB: INSERT vulnerability_snapshots
        API-&gt;&gt;DB: INSERT or UPDATE vulnerabilities_current
    end
    API-&gt;&gt;DB: DELETE stale rows (not seen in this scan)
    API-&gt;&gt;DB: INSERT OR REPLACE vulnerability_daily_totals
    API--&gt;&gt;User: { importId, insertCount, updateCount, removedStale, scanDate }
</code></pre>
<h3>Enhanced Deduplication System</h3>
<p>HexTrackr implements a sophisticated 4-tier unique key generation strategy:</p>
<p><strong>Tier 1: Asset ID + Plugin ID</strong> (Highest Reliability)</p>
<pre><code class="language-javascript">if (mapped.assetId &amp;&amp; mapped.pluginId) {
  return `asset:${mapped.assetId}|plugin:${mapped.pluginId}`;
}
</code></pre>
<p><strong>Tier 2: CVE + Hostname/IP</strong> (CVE-based)</p>
<pre><code class="language-javascript">if (mapped.cve &amp;&amp; mapped.cve.trim()) {
  const hostIdentifier = normalizedIP || normalizedHostname;
  return `cve:${mapped.cve.trim()}|host:${hostIdentifier}`;
}
</code></pre>
<p><strong>Tier 3: Plugin ID + Hostname/IP + Vendor</strong> (User-requested approach)</p>
<pre><code class="language-javascript">if (mapped.pluginId &amp;&amp; mapped.pluginId.trim()) {
  const hostIdentifier = normalizedIP || normalizedHostname;
  const vendor = mapped.vendor || &quot;unknown&quot;;
  return `plugin:${mapped.pluginId.trim()}|host:${hostIdentifier}|vendor:${vendor}`;
}
</code></pre>
<p><strong>Tier 4: Description Hash + Hostname/IP</strong> (Fallback)</p>
<pre><code class="language-javascript">const descriptionHash = createDescriptionHash(mapped.description);
const hostIdentifier = normalizedIP || normalizedHostname;
return `desc:${descriptionHash}|host:${hostIdentifier}`;
</code></pre>
<h3>Key Safeguards</h3>
<table>
<thead>
<tr>
<th>Risk</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody><tr>
<td>Row duplication in batch</td>
<td>In‑memory <code>Set</code> of processed unique_keys</td>
</tr>
<tr>
<td>Race conditions</td>
<td>Explicit sequential loop with <code>processNextRow(index)</code> pattern</td>
</tr>
<tr>
<td>Data drift</td>
<td>Historical record preserved in snapshots before updates</td>
</tr>
<tr>
<td>Performance</td>
<td>Indexes on <code>unique_key</code>, <code>scan_date</code>, severities</td>
</tr>
<tr>
<td><strong>Key conflicts</strong></td>
<td><strong>4-tier unique key generation with reliability scoring</strong></td>
</tr>
<tr>
<td><strong>Memory leaks</strong></td>
<td><strong>Session-based processing with automatic cleanup</strong></td>
</tr>
<tr>
<td><strong>Hostname variations</strong></td>
<td><strong>Hostname normalization (domain stripping, case insensitive)</strong></td>
</tr>
<tr>
<td><strong>IP address formats</strong></td>
<td><strong>IP normalization and validation</strong></td>
</tr>
</tbody></table>
<hr>
<h2>API Surface (High-Level)</h2>
<table>
<thead>
<tr>
<th>Domain</th>
<th>Endpoints (Examples)</th>
</tr>
</thead>
<tbody><tr>
<td>Health</td>
<td><code>GET /health</code></td>
</tr>
<tr>
<td>Vulnerabilities (Current)</td>
<td><code>GET /api/vulnerabilities</code>, <code>/stats</code>, <code>/recent-trends</code>, <code>/trends</code></td>
</tr>
<tr>
<td>Vulnerability Import</td>
<td><code>POST /api/vulnerabilities/import</code> (rollover), <code>POST /api/import/vulnerabilities</code> (legacy)</td>
</tr>
<tr>
<td>Tickets</td>
<td><code>GET/POST/PUT/DELETE /api/tickets</code>, <code>POST /api/tickets/migrate</code>, <code>POST /api/import/tickets</code></td>
</tr>
<tr>
<td>Reference</td>
<td><code>GET /api/sites</code>, <code>GET /api/locations</code></td>
</tr>
<tr>
<td>Backup/Restore</td>
<td><code>GET /api/backup/stats</code>, <code>GET /api/backup/all</code>, <code>POST /api/restore</code>, clear endpoints</td>
</tr>
<tr>
<td>Documentation</td>
<td><code>GET /api/docs/stats</code>, <code>/docs-html</code> SPA shell &amp; hash routing</td>
</tr>
</tbody></table>
<hr>
<h2>Real-time Communication (WebSocket)</h2>
<h3>ProgressTracker Architecture</h3>
<p>HexTrackr implements a sophisticated WebSocket-based progress tracking system through the <code>ProgressTracker</code> class:</p>
<ul>
<li><strong>Port</strong>: 8988 (separate from REST API)</li>
<li><strong>Library</strong>: Socket.io with enhanced session management</li>
<li><strong>Session Management</strong>: UUID-based sessions with metadata tracking</li>
<li><strong>Throttling</strong>: 100ms minimum interval between progress events</li>
<li><strong>Auto-cleanup</strong>: 30-minute session timeout with automatic garbage collection</li>
</ul>
<h3>ProgressTracker Features</h3>
<pre><code class="language-javascript">class ProgressTracker {
  constructor(io) {
    this.sessions = new Map();
    this.eventThrottle = new Map();
    this.THROTTLE_INTERVAL = 100;
    this.SESSION_CLEANUP_INTERVAL = 30 * 60 * 1000;
  }
}
</code></pre>
<p><strong>Key Capabilities</strong>:</p>
<ul>
<li>Session-based progress tracking with unique identifiers</li>
<li>Throttled event emission to prevent client overload</li>
<li>Metadata persistence for operation context</li>
<li>Automatic session cleanup for memory management</li>
<li>Error handling with graceful degradation</li>
</ul>
<h3>WebSocket Events</h3>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Purpose</th>
<th>Throttled</th>
</tr>
</thead>
<tbody><tr>
<td><code>import_progress</code></td>
<td>CSV import progress updates</td>
<td>Yes (100ms)</td>
</tr>
<tr>
<td><code>import_complete</code></td>
<td>Import operation completion</td>
<td>No</td>
</tr>
<tr>
<td><code>import_error</code></td>
<td>Import operation errors</td>
<td>No</td>
</tr>
<tr>
<td><code>session_created</code></td>
<td>New session establishment</td>
<td>No</td>
</tr>
<tr>
<td><code>session_cleanup</code></td>
<td>Session removal notification</td>
<td>No</td>
</tr>
</tbody></table>
<h3>Session Lifecycle</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Client
    participant ProgressTracker
    participant Import as Import Process

    Client-&gt;&gt;ProgressTracker: Connect to WebSocket
    ProgressTracker-&gt;&gt;ProgressTracker: createSession(metadata)
    ProgressTracker--&gt;&gt;Client: session_created event

    Import-&gt;&gt;ProgressTracker: updateProgress(sessionId, progress)
    ProgressTracker-&gt;&gt;ProgressTracker: throttleCheck()
    alt Progress not throttled
        ProgressTracker--&gt;&gt;Client: import_progress event
    end

    Import-&gt;&gt;ProgressTracker: completeSession(sessionId)
    ProgressTracker--&gt;&gt;Client: import_complete event
    ProgressTracker-&gt;&gt;ProgressTracker: cleanup(sessionId)
</code></pre>
<p>For more details, see the <a href="#api-reference/websocket-api">WebSocket API documentation</a>.</p>
<hr>
<h2>Pagination Flow (Current Vulnerabilities)</h2>
<pre><code class="language-mermaid">sequenceDiagram
    participant UI
    participant API as server.js
    participant DB as SQLite
    UI-&gt;&gt;API: GET /api/vulnerabilities?page=1&amp;limit=50
    API-&gt;&gt;DB: SELECT filtered rows FROM vulnerabilities_current LIMIT/OFFSET
    DB--&gt;&gt;API: Row batch
    API-&gt;&gt;DB: SELECT COUNT(*) (same filters)
    DB--&gt;&gt;API: Total
    API--&gt;&gt;UI: { data, pagination }
</code></pre>
<hr>
<h2>Legacy vs Rollover Paths</h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Legacy <code>vulnerabilities</code></th>
<th>Rollover Tables</th>
</tr>
</thead>
<tbody><tr>
<td>Purpose</td>
<td>Early ingestion &amp; export</td>
<td>Current production analytics</td>
</tr>
<tr>
<td>Dedupe</td>
<td>Unique per (hostname, cve, import_date) index</td>
<td>Algorithmic unique_key with hostname normalization</td>
</tr>
<tr>
<td>History</td>
<td>Implicit (one row per scan)</td>
<td>Explicit snapshots + daily aggregates</td>
</tr>
<tr>
<td>Future</td>
<td>To be deprecated</td>
<td>Strategic direction</td>
</tr>
</tbody></table>
<hr>
<h2>Utility Endpoints</h2>
<ul>
<li><strong><code>GET /health</code></strong>: <code>{ status, version, db, uptime }</code></li>
<li><strong><code>GET /api/docs/stats</code></strong>: Counts routes + approximates function definitions.</li>
<li><strong>Backup</strong>: Returns structured JSON (vulnerabilities legacy + tickets) or combined.</li>
</ul>
<hr>
<h2>Security &amp; Hardening</h2>
<h3>Current Security Implementations</h3>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Implementation</th>
<th>Details</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Path Traversal</strong></td>
<td><code>PathValidator</code> class</td>
<td>Comprehensive path validation and safe file operations</td>
</tr>
<tr>
<td><strong>Rate Limiting</strong></td>
<td>Express rate limit middleware</td>
<td>100 requests per 15-minute window per IP</td>
</tr>
<tr>
<td><strong>Upload Security</strong></td>
<td>Multer with size limits</td>
<td>50MB cap with file type validation</td>
</tr>
<tr>
<td><strong>XSS Prevention</strong></td>
<td>Security headers</td>
<td><code>X-Content-Type-Options</code>, <code>X-Frame-Options</code>, <code>X-XSS-Protection</code></td>
</tr>
<tr>
<td><strong>SQL Injection</strong></td>
<td>Parameterized queries</td>
<td>All database operations use prepared statements</td>
</tr>
<tr>
<td><strong>CORS Protection</strong></td>
<td>Configurable CORS</td>
<td>Default: all origins (configurable for production)</td>
</tr>
<tr>
<td><strong>Input Sanitization</strong></td>
<td>DOMPurify integration</td>
<td>Client-side XSS prevention</td>
</tr>
</tbody></table>
<h3>PathValidator Security Features</h3>
<pre><code class="language-javascript">// Safe file operations with built-in validation
PathValidator.safeReadFileSync(filePath, options)
PathValidator.safeWriteFileSync(filePath, data, options)
PathValidator.safeReaddirSync(dirPath, options)
PathValidator.safeStatSync(filePath)
PathValidator.safeExistsSync(filePath)
PathValidator.safeUnlinkSync(filePath)
</code></pre>
<p><strong>Protection Mechanisms</strong>:</p>
<ul>
<li>Path normalization before validation</li>
<li>Directory traversal detection (<code>../</code>, <code>..\\</code>)</li>
<li>Component-level path validation</li>
<li>Exception-based error handling</li>
<li>Graceful fallbacks for invalid paths</li>
</ul>
<h3>Rate Limiting Configuration</h3>
<pre><code class="language-javascript">const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: &#39;Too many requests from this IP&#39;,
  standardHeaders: true,
  legacyHeaders: false
});
</code></pre>
<h3>Future Security Enhancements</h3>
<table>
<thead>
<tr>
<th>Concern</th>
<th>Planned</th>
</tr>
</thead>
<tbody><tr>
<td>Authentication</td>
<td>JWT-based authentication with role-based access control</td>
</tr>
<tr>
<td>API Security</td>
<td>API key authentication for external integrations</td>
</tr>
<tr>
<td>Audit Logging</td>
<td>Central audit logging of security events and rejections</td>
</tr>
<tr>
<td>TLS</td>
<td>Built-in HTTPS support with automatic certificate management</td>
</tr>
<tr>
<td>Input Validation</td>
<td>JSON schema (Ajv) enforcement for all API endpoints</td>
</tr>
<tr>
<td>Structured Logging</td>
<td>Structured JSON logging with request IDs and correlation</td>
</tr>
<tr>
<td>Vulnerability Scanning</td>
<td>Automated dependency vulnerability scanning</td>
</tr>
<tr>
<td>Secret Management</td>
<td>Environment-based secret management with rotation</td>
</tr>
</tbody></table>
<hr>
<h2>Planned Enhancements</h2>
<h3>Observability &amp; Monitoring</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Metrics</strong></td>
<td>Prometheus metrics (import latency, row counts, session tracking)</td>
<td>High</td>
</tr>
<tr>
<td><strong>Tracing</strong></td>
<td>OpenTelemetry integration for distributed tracing</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Health Checks</strong></td>
<td>Enhanced health endpoints with dependency checking</td>
<td>High</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>APM integration for bottleneck identification</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Architecture &amp; Modularity</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Modularization</strong></td>
<td>Extract ProgressTracker, PathValidator, and rollover modules</td>
<td>High</td>
</tr>
<tr>
<td><strong>Microservices</strong></td>
<td>Split WebSocket server into separate service</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Database</strong></td>
<td>PostgreSQL migration for scalability</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>Redis integration for session and data caching</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Data Quality &amp; Validation</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Schema Validation</strong></td>
<td>JSON schema (Ajv) enforcement for all API endpoints</td>
<td>High</td>
</tr>
<tr>
<td><strong>CVE Validation</strong></td>
<td>Real-time CVE format and existence validation</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Severity Normalization</strong></td>
<td>Automatic severity enumeration mapping</td>
<td>High</td>
</tr>
<tr>
<td><strong>Data Quality Scoring</strong></td>
<td>Automated data quality metrics and reporting</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Legacy Migration</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Legacy Deprecation</strong></td>
<td>Retire legacy vulnerabilities table and endpoints</td>
<td>High</td>
</tr>
<tr>
<td><strong>Data Migration</strong></td>
<td>Automated migration from legacy to rollover architecture</td>
<td>High</td>
</tr>
<tr>
<td><strong>API Versioning</strong></td>
<td>Implement API versioning for backward compatibility</td>
<td>Medium</td>
</tr>
</tbody></table>
<h3>Testing &amp; Quality Assurance</h3>
<table>
<thead>
<tr>
<th>Area</th>
<th>Enhancement</th>
<th>Priority</th>
</tr>
</thead>
<tbody><tr>
<td><strong>E2E Testing</strong></td>
<td>Playwright integration tests for all major workflows</td>
<td>High</td>
</tr>
<tr>
<td><strong>API Contract Testing</strong></td>
<td>OpenAPI-based contract validation</td>
<td>High</td>
</tr>
<tr>
<td><strong>Load Testing</strong></td>
<td>Automated performance testing with realistic data volumes</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Security Testing</strong></td>
<td>Automated security scanning and penetration testing</td>
<td>High</td>
</tr>
</tbody></table>
<hr>
<h2>Summary</h2>
<p>The backend favors simplicity (single process, embedded DB) while implementing a robust rollover pipeline for vulnerability lifecycle tracking. Incremental improvements will focus on modularity, observability, and deprecating legacy ingestion paths.</p>

    <!-- Note: This file is intentionally minimal. The full page scaffold, header, footer, and scripts
             are provided by docs-html/index.html. Content generated using this template will be
             fetched and injected into #content-container by docs-html/js/docs-portal-v2.js. -->
</section>
