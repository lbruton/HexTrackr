/**
 * @fileoverview Shared CVE utility functions for consistent event handling patterns
 * Provides centralized functions for parsing, validating, and creating CVE links
 * with proper event isolation to prevent the "all CVEs open" bug
 * 
 * @version 1.0.0
 * @date 2025-09-09
 * @spec 004-cve-link-system-fix
 * @task T038
 */

/* global console */

(function(global) {
    "use strict";

    /**
     * CVE format validation regex pattern
     * Matches standard CVE format: CVE-YYYY-NNNNN (4+ digits for ID)
     * @constant {RegExp}
     */
    const CVE_PATTERN = /^CVE-\d{4}-\d{4,}$/i;

    /**
     * Cisco Security Advisory pattern
     * Matches format: cisco-sa-YYYYMMDD-name
     * @constant {RegExp}
     */
    const CISCO_SA_PATTERN = /^cisco-sa-(\d{8}-[\w-]+)$/i;

    /**
     * Validates if a string is a valid CVE identifier
     * @param {string} cve - String to validate
     * @returns {boolean} True if valid CVE format
     * @example
     * validateCVE('CVE-2024-12345') // true
     * validateCVE('cve-2024-1234') // true (case-insensitive)
     * validateCVE('not-a-cve') // false
     */
    function validateCVE(cve) {
        if (!cve || typeof cve !== "string") {
            return false;
        }
        return CVE_PATTERN.test(cve.trim());
    }

    /**
     * Validates if a string is a valid Cisco Security Advisory
     * @param {string} id - String to validate
     * @returns {boolean} True if valid Cisco SA format
     */
    function validateCiscoSA(id) {
        if (!id || typeof id !== "string") {
            return false;
        }
        return CISCO_SA_PATTERN.test(id.trim());
    }

    /**
     * Parses a multi-CVE string into individual CVE IDs
     * Handles both comma and space separation, filters invalid entries
     * @param {string} cveString - String containing one or more CVEs
     * @returns {Array<string>} Array of valid, normalized CVE IDs
     * @example
     * parseCVEString('CVE-2024-1234, CVE-2024-5678') // ['CVE-2024-1234', 'CVE-2024-5678']
     * parseCVEString('CVE-2024-1234 CVE-2024-5678') // ['CVE-2024-1234', 'CVE-2024-5678']
     * parseCVEString('CVE-2024-1234, invalid, CVE-2024-5678') // ['CVE-2024-1234', 'CVE-2024-5678']
     */
    function parseCVEString(cveString) {
        if (!cveString || typeof cveString !== "string") {
            return [];
        }

        // First try comma separation
        let cveIds = [];
        if (cveString.includes(",")) {
            cveIds = cveString.split(",").map(id => id.trim());
        } 
        // Then try space separation
        else if (cveString.includes(" ")) {
            // Split by space and filter for CVE pattern
            cveIds = cveString.split(/\s+/).filter(part => 
                part.toUpperCase().startsWith("CVE-") || 
                part.toLowerCase().startsWith("cisco-sa-")
            );
        } 
        // Single CVE
        else {
            cveIds = [cveString.trim()];
        }

        // Validate and normalize each CVE
        return cveIds
            .filter(id => validateCVE(id) || validateCiscoSA(id))
            .map(id => id.toUpperCase());
    }

    /**
     * Extracts individual CVE IDs from a multi-CVE string
     * Returns first CVE if single is requested, all CVEs otherwise
     * @param {string} cveString - String containing CVEs
     * @param {boolean} [firstOnly=false] - Return only the first CVE
     * @returns {string|Array<string>} Single CVE string or array of CVEs
     * @example
     * extractCVEIds('CVE-2024-1234, CVE-2024-5678') // ['CVE-2024-1234', 'CVE-2024-5678']
     * extractCVEIds('CVE-2024-1234, CVE-2024-5678', true) // 'CVE-2024-1234'
     */
    function extractCVEIds(cveString, firstOnly = false) {
        const cveIds = parseCVEString(cveString);
        
        if (firstOnly) {
            return cveIds.length > 0 ? cveIds[0] : null;
        }
        
        return cveIds;
    }

    /**
     * Creates a CVE link element with proper event isolation
     * Prevents event bubbling and ensures only specific CVE is opened
     * @param {string} cveId - Single CVE identifier
     * @param {Object} [options] - Link creation options
     * @param {string} [options.cssClass='vulnerability-cve'] - CSS class for the link
     * @param {Function} [options.clickHandler] - Custom click handler function
     * @param {boolean} [options.preventDefault=true] - Prevent default link behavior
     * @param {boolean} [options.stopPropagation=true] - Stop event propagation
     * @returns {string} HTML string for the CVE link
     * @example
     * createCVELink('CVE-2024-1234')
     * // Returns: <a href="#" class="vulnerability-cve" data-cve="CVE-2024-1234">CVE-2024-1234</a>
     * 
     * createCVELink('CVE-2024-1234', { cssClass: 'custom-link' })
     * // Returns: <a href="#" class="custom-link" data-cve="CVE-2024-1234">CVE-2024-1234</a>
     */
    function createCVELink(cveId, options = {}) {
        if (!cveId || (!validateCVE(cveId) && !validateCiscoSA(cveId))) {
            console.warn("Invalid CVE/SA ID provided to createCVELink:", cveId);
            return escapeHtml(cveId || "");
        }

        const defaults = {
            cssClass: "vulnerability-cve",
            preventDefault: true,
            stopPropagation: true
        };

        const settings = Object.assign({}, defaults, options);
        const escapedCve = escapeHtml(cveId);
        
        // Build onclick handler with proper event isolation
        let onclickAttr = "";
        if (settings.preventDefault || settings.stopPropagation) {
            const handlers = [];
            if (settings.preventDefault) {handlers.push("event.preventDefault()");}
            if (settings.stopPropagation) {handlers.push("event.stopPropagation()");}
            
            // Add custom handler if provided
            if (settings.clickHandler) {
                // If clickHandler is a function name string
                if (typeof settings.clickHandler === "string") {
                    handlers.push(`${settings.clickHandler}('${escapedCve}')`);
                } else {
                    console.warn("Click handler must be a function name string");
                }
            } else if (settings.external) {
                // Open external link in popup
                let url;
                if (validateCVE(cveId)) {
                    url = `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${escapedCve}`;
                } else if (validateCiscoSA(cveId)) {
                    url = `https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/${escapedCve}`;
                } else {
                    console.warn("Unknown CVE/SA format for external link:", cveId);
                    return escapeHtml(cveId);
                }
                handlers.push(`window.open('${url}', 'cve_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes')`);
            } else {
                // T015/T016: Use new CVE-specific modal method instead of external lookup
                handlers.push(`vulnManager.showVulnerabilityDetailsByCVE('${escapedCve}')`);
            }
            
            onclickAttr = `onclick="${handlers.join("; ")}; return false;"`;
        }

        // Handle Cisco SA links with warning color
        const additionalClass = validateCiscoSA(cveId) ? "text-warning" : "";
        
        return `<a href="#" class="${settings.cssClass} ${additionalClass}" 
                   data-cve="${escapedCve}" 
                   ${onclickAttr}>
                    ${escapedCve}
                </a>`.replace(/\s+/g, " ").trim();
    }

    /**
     * Creates multiple CVE links from a multi-CVE string
     * Each CVE gets its own isolated link element
     * @param {string} cveString - String containing one or more CVEs
     * @param {Object} [options] - Options passed to createCVELink
     * @param {string} [options.separator=', '] - Separator between links
     * @returns {string} HTML string with all CVE links
     * @example
     * createMultipleCVELinks('CVE-2024-1234, CVE-2024-5678')
     * // Returns: <a ...>CVE-2024-1234</a>, <a ...>CVE-2024-5678</a>
     */
    function createMultipleCVELinks(cveString, options = {}) {
        const cveIds = parseCVEString(cveString);
        
        if (cveIds.length === 0) {
            return escapeHtml(cveString || "");
        }

        const separator = options.separator || ", ";
        delete options.separator; // Remove separator from options passed to createCVELink

        return cveIds
            .map(cveId => createCVELink(cveId, options))
            .join(separator);
    }

    /**
     * Attaches isolated event handlers to CVE links
     * Ensures each link only triggers its specific CVE lookup
     * @param {HTMLElement|string} container - Container element or selector
     * @param {Function} lookupHandler - Function to call with CVE ID
     * @param {Object} [options] - Event handling options
     * @example
     * attachCVEEventHandlers('#vulnerability-table', (cveId) => {
     *     console.log('Looking up:', cveId);
     *     vulnManager.lookupVulnerability(cveId);
     * });
     */
    function attachCVEEventHandlers(container, lookupHandler, options = {}) {
        const containerEl = typeof container === "string" 
            ? document.querySelector(container)
            : container;

        if (!containerEl) {
            console.warn("Container not found for CVE event handlers:", container);
            return;
        }

        // Use event delegation for efficiency
        containerEl.addEventListener("click", function(event) {
            // Find closest CVE link element
            const cveLink = event.target.closest("[data-cve]");
            
            if (!cveLink) {
                return;
            }

            // Prevent default and stop propagation
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();

            // Get the specific CVE ID from data attribute
            const cveId = cveLink.getAttribute("data-cve");
            
            if (!cveId) {
                console.warn("CVE link missing data-cve attribute");
                return;
            }

            // Validate CVE before lookup
            if (!validateCVE(cveId) && !validateCiscoSA(cveId)) {
                console.warn("Invalid CVE/SA ID in data attribute:", cveId);
                return;
            }

            // Call the lookup handler with ONLY this specific CVE
            if (typeof lookupHandler === "function") {
                try {
                    lookupHandler(cveId);
                } catch (error) {
                    console.error("Error in CVE lookup handler:", error);
                }
            } else {
                // T015/T016: Default behavior - show modal for specific CVE
                if (window.vulnManager && typeof window.vulnManager.showVulnerabilityDetailsByCVE === "function") {
                    try {
                        window.vulnManager.showVulnerabilityDetailsByCVE(cveId);
                    } catch (error) {
                        console.error("Error opening CVE modal:", error);
                        // Fallback to external lookup if modal fails
                        if (typeof window.vulnManager.lookupVulnerability === "function") {
                            window.vulnManager.lookupVulnerability(cveId);
                        }
                    }
                } else {
                    console.warn("vulnManager.showVulnerabilityDetailsByCVE not available, using external lookup");
                    if (window.vulnManager && typeof window.vulnManager.lookupVulnerability === "function") {
                        window.vulnManager.lookupVulnerability(cveId);
                    }
                }
            }
        }, options.useCapture || false);
    }

    /**
     * Escapes HTML special characters to prevent XSS
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML-safe text
     * @private
     */
    function escapeHtml(text) {
        const map = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            "\"": "&quot;",
            "'": "&#039;"
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }

    /**
     * Removes all CVE event handlers from a container
     * Useful for cleanup when destroying views
     * @param {HTMLElement|string} container - Container element or selector
     */
    function removeCVEEventHandlers(container) {
        const containerEl = typeof container === "string"
            ? document.querySelector(container)
            : container;

        if (!containerEl) {
            return;
        }

        // Clone and replace to remove all event listeners
        const newContainer = containerEl.cloneNode(true);
        containerEl.parentNode.replaceChild(newContainer, containerEl);
    }

    /**
     * Normalizes CVE format to uppercase standard
     * @param {string} cve - CVE identifier
     * @returns {string|null} Normalized CVE or null if invalid
     * @example
     * normalizeCVE('cve-2024-1234') // 'CVE-2024-1234'
     * normalizeCVE('CVE-2024-1234') // 'CVE-2024-1234'
     * normalizeCVE('invalid') // null
     */
    function normalizeCVE(cve) {
        if (!validateCVE(cve)) {
            return null;
        }
        return cve.trim().toUpperCase();
    }

    /**
     * Gets the first CVE from a multi-CVE string
     * Useful for display purposes when space is limited
     * @param {string} cveString - String containing CVEs
     * @returns {string|null} First valid CVE or null
     */
    function getFirstCVE(cveString) {
        return extractCVEIds(cveString, true);
    }

    /**
     * Counts the number of valid CVEs in a string
     * @param {string} cveString - String containing CVEs
     * @returns {number} Count of valid CVEs
     */
    function countCVEs(cveString) {
        return parseCVEString(cveString).length;
    }

    /**
     * Creates a summary display for multiple CVEs
     * Shows first CVE and count of additional ones
     * @param {string} cveString - String containing CVEs
     * @param {Object} [options] - Display options
     * @returns {string} HTML string with summary
     * @example
     * createCVESummary('CVE-2024-1234, CVE-2024-5678, CVE-2024-9999')
     * // Returns: '<span>CVE-2024-1234</span> <span class="badge">+2 more</span>'
     */
    function createCVESummary(cveString, options = {}) {
        const cveIds = parseCVEString(cveString);
        
        if (cveIds.length === 0) {
            return escapeHtml(cveString || "No CVE");
        }

        if (cveIds.length === 1) {
            return createCVELink(cveIds[0], options);
        }

        const firstLink = createCVELink(cveIds[0], options);
        const additionalCount = cveIds.length - 1;
        const badgeClass = options.badgeClass || "badge bg-secondary ms-1";
        
        return `${firstLink} <span class="${badgeClass}">+${additionalCount} more</span>`;
    }

    // Export utilities
    const CVEUtilities = {
        // Validation
        validateCVE,
        validateCiscoSA,
        
        // Parsing
        parseCVEString,
        extractCVEIds,
        getFirstCVE,
        normalizeCVE,
        countCVEs,
        
        // Link creation
        createCVELink,
        createMultipleCVELinks,
        createCVESummary,
        
        // Event handling
        attachCVEEventHandlers,
        removeCVEEventHandlers,
        
        // Constants (for testing)
        patterns: {
            CVE: CVE_PATTERN,
            CISCO_SA: CISCO_SA_PATTERN
        }
    };

    // Export for different environments
    if (typeof module !== "undefined" && module.exports) {
        // Node.js / CommonJS
        module.exports = CVEUtilities;
    } else if (typeof define === "function" && define.amd) {
        // AMD
        define([], function() {
            return CVEUtilities;
        });
    } else {
        // Browser global
        global.CVEUtilities = CVEUtilities;
    }

})(typeof window !== "undefined" ? window : global);