/**
 * @fileoverview VulnerabilitySearchManager - Handles search, filtering, and vulnerability lookup operations
 * Extracted from ModernVulnManager as part of Phase 2 modularization
 * @version 2.0.0
 * @author Claude
 * @date 2025-09-08
 */

/* eslint-env browser, es6 */
/* global btoa, fetch, alert, localStorage, window, document */
/* exported VulnerabilitySearchManager */

/**
 * Manages vulnerability search, filtering, and external lookup operations
 */
class VulnerabilitySearchManager {
    constructor(apiBase, dataManager, toastHandler) {
        this.apiBase = apiBase;
        this.dataManager = dataManager;
        this.toastHandler = toastHandler;
        this.setupEventListeners();
    }

    /**
     * Setup search and filter event listeners
     */
    setupEventListeners() {
        // Search input listener
        const searchInput = document.getElementById("searchInput");
        if (searchInput) {
            searchInput.addEventListener("input", () => {
                this.dataManager.filterData();
            });
        }

        // Severity filter listener  
        const severityFilter = document.getElementById("severityFilter");
        if (severityFilter) {
            severityFilter.addEventListener("change", () => {
                this.dataManager.filterData();
            });
        }
    }

    /**
     * Enhanced lookup method that handles different vulnerability ID types
     * @param {string} vulnId - Vulnerability ID (CVE, Cisco SA, or plugin)
     * @param {string} pluginName - Optional plugin name for extraction
     */
    async lookupVulnerability(vulnId, pluginName = null) {
        // If CVE, use existing CVE lookup
        if (vulnId && vulnId.startsWith("CVE-")) {
            return this.lookupCVE(vulnId);
        }
        
        // If it looks like a Cisco SA ID, open Cisco advisory
        if (vulnId && vulnId.startsWith("cisco-sa-")) {
            const popup = window.open(
                `https://www.cisco.com/c/en/us/support/docs/csa/${vulnId}.html`,
                `Cisco_Advisory_${vulnId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            
            if (popup) {
                popup.focus();
                this.toastHandler.showToast(`Opened Cisco advisory for ${vulnId}`, "success");
            } else {
                this.toastHandler.showToast("Popup blocked - please allow popups for vulnerability lookups", "warning");
            }
            return;
        }
        
        // If we have plugin name, try to extract Cisco ID from it
        if (pluginName) {
            const ciscoId = this.extractCiscoVulnId(pluginName);
            if (ciscoId) {
                return this.lookupVulnerability(ciscoId);
            }
        }
        
        // Default fallback
        this.toastHandler.showToast("No external vulnerability reference available for this item", "info");
    }

    /**
     * Handle CVE lookup with multiple CVE support
     * @param {string} cveId - CVE identifier(s)
     */
    async lookupCVE(cveId) {
        // IMPORTANT: Only process the single CVE that was clicked
        // Don't split multiple CVEs - each link should call this with a single CVE
        const cveIds = [cveId.trim()];

        const ciscoClientId = localStorage.getItem("cisco_client_id");
        const ciscoClientSecret = localStorage.getItem("cisco_client_secret");

        if (ciscoClientId && ciscoClientSecret && cveIds.length === 1) {
            await this.lookupCVEWithCiscoAPI(cveIds[0], ciscoClientId, ciscoClientSecret);
        } else {
            this.openCVEPopups(cveIds);
        }
    }

    /**
     * Lookup CVE using Cisco PSIRT API
     * @param {string} cveId - Single CVE identifier
     * @param {string} clientId - Cisco API client ID
     * @param {string} clientSecret - Cisco API client secret
     */
    async lookupCVEWithCiscoAPI(cveId, clientId, clientSecret) {
        try {
            this.toastHandler.showLoading(`Looking up ${cveId} via Cisco PSIRT...`);
            
            const tokenResponse = await fetch("https://id.cisco.com/oauth2/default/v1/token", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Authorization": "Basic " + btoa(`${clientId}:${clientSecret}`)
                },
                body: "grant_type=client_credentials"
            });

            if (tokenResponse.ok) {
                const tokenData = await tokenResponse.json();
                
                const psirtResponse = await fetch(`https://api.cisco.com/security/advisories/cve/${cveId}`, {
                    headers: {
                        "Authorization": `Bearer ${tokenData.access_token}`,
                        "Accept": "application/json"
                    }
                });

                this.toastHandler.hideLoading();

                if (psirtResponse.ok) {
                    const data = await psirtResponse.json();
                    this.displayCVEInfo(cveId, data);
                } else {
                    this.toastHandler.showToast(`No Cisco advisory found for ${cveId}. Opening external lookup...`, "warning");
                    this.openCVEPopups([cveId]);
                }
            } else {
                this.toastHandler.hideLoading();
                this.toastHandler.showToast("Failed to authenticate with Cisco API. Using external lookup...", "warning");
                this.openCVEPopups([cveId]);
            }
        } catch (_error) {
            this.toastHandler.hideLoading();
            this.toastHandler.showToast("Error with Cisco API. Using external lookup...", "warning");
            this.openCVEPopups([cveId]);
        }
    }

    /**
     * Open CVE lookup popups for multiple CVE IDs
     * @param {Array} cveIds - Array of CVE identifiers
     */
    openCVEPopups(cveIds) {
        if (!Array.isArray(cveIds) || cveIds.length === 0) {
            this.toastHandler.showToast("No valid CVE IDs found", "warning");
            return;
        }

        let successCount = 0;
        let blockedCount = 0;

        cveIds.forEach((cveId, index) => {
            if (!cveId.startsWith("CVE-")) {
                return;
            }

            setTimeout(() => {
                const popup = window.open(
                    `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId.trim()}`,
                    `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                    "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes,top=50,left=" + (100 + index * 50)
                );
                
                if (popup) {
                    popup.focus();
                    successCount++;
                } else {
                    blockedCount++;
                }

                if (index === cveIds.length - 1) {
                    setTimeout(() => {
                        if (blockedCount > 0) {
                            this.toastHandler.showToast(`${successCount} CVE lookup(s) opened. ${blockedCount} popup(s) blocked. Please allow popups for full CVE lookups.`, "warning");
                        } else if (successCount > 0) {
                            this.toastHandler.showToast(`${successCount} CVE lookup(s) opened successfully`, "success");
                        }
                    }, 100);
                }
            }, index * 200);
        });
    }

    /**
     * Display CVE information from Cisco PSIRT API
     * @param {string} cveId - CVE identifier
     * @param {Object} data - CVE data from API
     */
    displayCVEInfo(cveId, data) {
        let message = `CVE Information for ${cveId}:\n\n`;
        if (data.advisories && data.advisories.length > 0) {
            const advisory = data.advisories[0];
            message += `Title: ${advisory.advisoryTitle}\n`;
            message += `Severity: ${advisory.sir}\n`;
            message += `CVSSv3 Score: ${advisory.cvssBaseScore}\n`;
            message += `Publication Date: ${advisory.publicationUrl}\n`;
        }
        alert(message);
    }

    /**
     * Extract Cisco vulnerability ID from plugin name
     * @param {string} pluginName - Plugin name to search
     * @returns {string|null} Cisco SA identifier or null
     */
    extractCiscoVulnId(pluginName) {
        if (!pluginName || typeof pluginName !== "string") {
            return null;
        }
        
        // Look for cisco-sa- pattern in plugin name
        const ciscoSaMatch = pluginName.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
        if (ciscoSaMatch) {
            return `cisco-sa-${ciscoSaMatch[1]}`;
        }
        
        return null;
    }

    /**
     * Determine vulnerability ID type and create appropriate link
     * @param {Object} vulnData - Vulnerability data object
     * @returns {Object} Link information object
     */
    getVulnerabilityLink(vulnData) {
        const { cve, plugin_name } = vulnData;
        
        // Check for CVE first
        if (cve && cve.startsWith("CVE-")) {
            return {
                id: cve,
                type: "cve",
                url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve.trim()}`
            };
        }
        
        // Check for Cisco SA ID in plugin name
        const ciscoId = this.extractCiscoVulnId(plugin_name);
        if (ciscoId) {
            return {
                id: ciscoId,
                type: "cisco",
                url: `https://www.cisco.com/c/en/us/support/docs/csa/${ciscoId}.html`
            };
        }
        
        // Fall back to plugin ID
        return {
            id: `Plugin ${vulnData.plugin_id}`,
            type: "plugin",
            url: null
        };
    }
}