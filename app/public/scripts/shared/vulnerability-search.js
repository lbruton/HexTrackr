/**
 * @fileoverview VulnerabilitySearchManager - Handles search, filtering, and vulnerability lookup operations
 * Extracted from ModernVulnManager as part of Phase 2 modularization
 * @version 2.0.0
 * @author HexTrackr Team
 * @date 2025-09-08
 */

/* eslint-env browser, es6 */
/* global btoa, fetch, alert, localStorage, window, document */
/* exported VulnerabilitySearchManager */

/**
 * Manages vulnerability search, filtering, and external lookup operations
 */
class VulnerabilitySearchManager {
    constructor(apiBase, dataManager, toastHandler) {
        this.apiBase = apiBase;
        this.dataManager = dataManager;
        this.toastHandler = toastHandler;
        this.setupEventListeners();
    }

    /**
     * Setup search and filter event listeners
     */
    setupEventListeners() {
        // Search input listener
        const searchInput = document.getElementById("searchInput");
        if (searchInput) {
            searchInput.addEventListener("input", (e) => {
                const searchTerm = e.target.value;

                // Update data manager (for devices/vulnerabilities/table views)
                this.dataManager.filterData();

                // Also update location cards if they exist
                if (window.locationCardsManager && typeof window.locationCardsManager.applySearchFilter === "function") {
                    window.locationCardsManager.applySearchFilter(searchTerm);
                }
            });
        }

        // Severity filter listener
        const severityFilter = document.getElementById("severityFilter");
        if (severityFilter) {
            severityFilter.addEventListener("change", () => {
                this.dataManager.filterData();
            });
        }

        // Vendor filter listener
        const vendorFilter = document.getElementById("vendorFilter");
        if (vendorFilter) {
            vendorFilter.addEventListener("change", () => {
                this.dataManager.filterData();
            });
        }

        // Location filter listener
        const locationFilter = document.getElementById("locationFilter");
        if (locationFilter) {
            locationFilter.addEventListener("change", () => {
                // Update vulnerability data manager (for devices/vulnerabilities/table views)
                this.dataManager.filterData();

                // Also update location cards if they exist
                if (window.locationCardsManager && typeof window.locationCardsManager.applyLocationFilter === "function") {
                    const selectedLocation = locationFilter.value;
                    window.locationCardsManager.applyLocationFilter(selectedLocation);
                }
            });
        }
    }

    /**
     * Enhanced lookup method that handles different vulnerability ID types
     * @param {string} vulnId - Vulnerability ID (CVE, Cisco SA, or plugin)
     * @param {string} pluginName - Optional plugin name for extraction
     */
    async lookupVulnerability(vulnId, pluginName = null) {
        // If CVE, use existing CVE lookup
        if (vulnId && vulnId.startsWith("CVE-")) {
            return this.lookupCVE(vulnId);
        }
        
        // If it looks like a Cisco SA ID, open Cisco advisory
        if (vulnId && vulnId.startsWith("cisco-sa-")) {
            const popup = window.open(
                `https://www.cisco.com/c/en/us/support/docs/csa/${vulnId}.html`,
                `Cisco_Advisory_${vulnId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            
            if (popup) {
                popup.focus();
                this.toastHandler.showToast(`Opened Cisco advisory for ${vulnId}`, "success");
            } else {
                this.toastHandler.showToast("Popup blocked - please allow popups for vulnerability lookups", "warning");
            }
            return;
        }
        
        // If we have plugin name, try to extract Cisco ID from it
        if (pluginName) {
            const ciscoId = this.extractCiscoVulnId(pluginName);
            if (ciscoId) {
                return this.lookupVulnerability(ciscoId);
            }
        }
        
        // Default fallback
        this.toastHandler.showToast("No external vulnerability reference available for this item", "info");
    }

    /**
     * Handle CVE lookup with multiple CVE support
     * @param {string} cveId - CVE identifier(s)
     */
    async lookupCVE(cveId) {
        // IMPORTANT: Only process the single CVE that was clicked
        // Don't split multiple CVEs - each link should call this with a single CVE
        const cveIds = [cveId.trim()];

        const ciscoClientId = localStorage.getItem("cisco_client_id");
        const ciscoClientSecret = localStorage.getItem("cisco_client_secret");

        if (ciscoClientId && ciscoClientSecret && cveIds.length === 1) {
            await this.lookupCVEWithCiscoAPI(cveIds[0], ciscoClientId, ciscoClientSecret);
        } else {
            this.openCVEPopups(cveIds);
        }
    }

    /**
     * Lookup CVE using Cisco PSIRT API with retry and fallback (T040)
     * @param {string} cveId - Single CVE identifier
     * @param {string} clientId - Cisco API client ID
     * @param {string} clientSecret - Cisco API client secret
     * @param {number} _retryCount - Current retry attempt (unused - reserved for future retry logic)
     * @param {number} _maxRetries - Maximum number of retries (unused - reserved for future retry logic)
     */
    async lookupCVEWithCiscoAPI(cveId, clientId, clientSecret, _retryCount = 0, _maxRetries = 3) {
        try {
            // Use enhanced toast manager if available
            if (window.toastManager) {
                window.toastManager.showCVEStatus(cveId, "looking");
            } else if (this.toastHandler.showLoading) {
                this.toastHandler.showLoading(`Looking up ${cveId} via Cisco PSIRT...`);
            }
            
            const tokenResponse = await fetch("https://id.cisco.com/oauth2/default/v1/token", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Authorization": "Basic " + btoa(`${clientId}:${clientSecret}`)
                },
                body: "grant_type=client_credentials"
            });

            if (tokenResponse.ok) {
                const tokenData = await tokenResponse.json();
                
                const psirtResponse = await fetch(`https://api.cisco.com/security/advisories/cve/${cveId}`, {
                    headers: {
                        "Authorization": `Bearer ${tokenData.access_token}`,
                        "Accept": "application/json"
                    }
                });

                // Hide loading and show result
                if (window.toastManager) {
                    window.toastManager.hideLoading();
                } else if (this.toastHandler.hideLoading) {
                    this.toastHandler.hideLoading();
                }

                if (psirtResponse.ok) {
                    const data = await psirtResponse.json();
                    if (window.toastManager) {
                        window.toastManager.showCVEStatus(cveId, "found");
                    }
                    this.displayCVEInfo(cveId, data);
                } else {
                    if (window.toastManager) {
                        window.toastManager.showCVEStatus(cveId, "notfound");
                    } else {
                        this.toastHandler.showToast(`No Cisco advisory found for ${cveId}. Opening external lookup...`, "warning");
                    }
                    this.openCVEPopups([cveId]);
                }
            } else {
                if (window.toastManager) {
                    window.toastManager.hideLoading();
                    window.toastManager.showError("Failed to authenticate with Cisco API", { message: "Using external lookup..." });
                } else {
                    this.toastHandler.hideLoading();
                    this.toastHandler.showToast("Failed to authenticate with Cisco API. Using external lookup...", "warning");
                }
                this.openCVEPopups([cveId]);
            }
        } catch (error) {
            if (window.toastManager) {
                window.toastManager.showCVEStatus(cveId, "error", { error });
            } else {
                this.toastHandler.hideLoading();
                this.toastHandler.showToast("Error with Cisco API. Using external lookup...", "warning");
            }
            this.openCVEPopups([cveId]);
        }
    }

    /**
     * Open CVE lookup popups for multiple CVE IDs
     * @param {Array} cveIds - Array of CVE identifiers
     */
    /**
     * Open CVE lookup popups for multiple CVE IDs.
     * Handles popup blocking and provides user feedback for success/failure.
     *
     * @param {Array} cveIds - Array of CVE identifiers to lookup
     * @returns {void}
     */
    openCVEPopups(cveIds) {
        if (!Array.isArray(cveIds) || cveIds.length === 0) {
            this.toastHandler.showToast("No valid CVE IDs found", "warning");
            return;
        }

        let successCount = 0;
        let blockedCount = 0;

        cveIds.forEach((cveId, index) => {
            if (!cveId.startsWith("CVE-")) {
                return;
            }

            setTimeout(() => {
                const popup = window.open(
                    `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId.trim()}`,
                    `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                    "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes,top=50,left=" + (100 + index * 50)
                );
                
                if (popup) {
                    popup.focus();
                    successCount++;
                } else {
                    blockedCount++;
                }

                if (index === cveIds.length - 1) {
                    setTimeout(() => {
                        if (blockedCount > 0) {
                            this.toastHandler.showToast(`${successCount} CVE lookup(s) opened. ${blockedCount} popup(s) blocked. Please allow popups for full CVE lookups.`, "warning");
                        } else if (successCount > 0) {
                            this.toastHandler.showToast(`${successCount} CVE lookup(s) opened successfully`, "success");
                        }
                    }, 100);
                }
            }, index * 200);
        });
    }

    /**
     * Display CVE information from Cisco PSIRT API
     * @param {string} cveId - CVE identifier
     * @param {Object} data - CVE data from API
     */
    displayCVEInfo(cveId, data) {
        let message = `CVE Information for ${cveId}:\n\n`;
        if (data.advisories && data.advisories.length > 0) {
            const advisory = data.advisories[0];
            message += `Title: ${advisory.advisoryTitle}\n`;
            message += `Severity: ${advisory.sir}\n`;
            message += `CVSSv3 Score: ${advisory.cvssBaseScore}\n`;
            message += `Publication Date: ${advisory.publicationUrl}\n`;
        }
        alert(message);
    }

    /**
     * Extract Cisco vulnerability ID from plugin name
     * @param {string} pluginName - Plugin name to search
     * @returns {string|null} Cisco SA identifier or null
     */
    /**
     * Extract Cisco vulnerability ID from plugin name.
     * Searches for cisco-sa- pattern in the plugin name string.
     *
     * @param {string} pluginName - Plugin name to search for Cisco ID
     * @returns {string|null} Cisco vulnerability ID or null if not found
     * @example
     * // Returns: "cisco-sa-12345"
     * extractCiscoVulnId("Cisco Security Advisory cisco-sa-12345");
     */
    extractCiscoVulnId(pluginName) {
        if (!pluginName || typeof pluginName !== "string") {
            return null;
        }
        
        // Look for cisco-sa- pattern in plugin name
        const ciscoSaMatch = pluginName.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
        if (ciscoSaMatch) {
            return `cisco-sa-${ciscoSaMatch[1]}`;
        }
        
        return null;
    }

    /**
     * Determine vulnerability ID type and create appropriate link
     * @param {Object} vulnData - Vulnerability data object
     * @returns {Object} Link information object
     */
    /**
     * Generate vulnerability link information based on CVE or plugin data.
     * Determines the appropriate external link for a vulnerability,
     * prioritizing CVE links over Cisco SA links.
     *
     * @param {Object} vulnData - Vulnerability data object
     * @param {string} vulnData.cve - CVE identifier
     * @param {string} vulnData.plugin_name - Plugin name for Cisco ID extraction
     * @returns {Object|null} Link information object or null if no link available
     * @example
     * // Returns: { id: "CVE-2023-12345", type: "cve", url: "https://cve.mitre.org/..." }
     * getVulnerabilityLink({ cve: "CVE-2023-12345", plugin_name: "..." });
     */
    getVulnerabilityLink(vulnData) {
        const { cve, plugin_name } = vulnData;
        
        // Check for CVE first
        if (cve && cve.startsWith("CVE-")) {
            return {
                id: cve,
                type: "cve",
                url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve.trim()}`
            };
        }
        
        // Check for Cisco SA ID in plugin name
        const ciscoId = this.extractCiscoVulnId(plugin_name);
        if (ciscoId) {
            return {
                id: ciscoId,
                type: "cisco",
                url: `https://www.cisco.com/c/en/us/support/docs/csa/${ciscoId}.html`
            };
        }
        
        // Fall back to plugin ID
        return {
            id: `Plugin ${vulnData.plugin_id}`,
            type: "plugin",
            url: null
        };
    }

    /**
     * T040: Helper method for exponential backoff delay
     * @param {number} ms - Milliseconds to delay
     */
    /**
     * Create a delay promise for async operations.
     * Utility function for creating delays in API retry logic and timeouts.
     *
     * @param {number} ms - Milliseconds to delay
     * @returns {Promise} Promise that resolves after the specified delay
     * @example
     * // Wait 2 seconds before continuing
     * await delay(2000);
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * T040: Cache API responses for offline/failure scenarios
     * @param {string} cveId - CVE identifier
     * @param {Object} data - API response data
     */
    cacheAPIResponse(cveId, data) {
        try {
            const cache = JSON.parse(localStorage.getItem("cveAPICache") || "{}");
            cache[cveId] = {
                data: data,
                timestamp: Date.now(),
                expires: Date.now() + (7 * 24 * 60 * 60 * 1000) // 7 days
            };
            
            // Limit cache size to 100 entries
            const entries = Object.entries(cache);
            if (entries.length > 100) {
                // Remove oldest entries
                entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                const toKeep = entries.slice(-100);
                localStorage.setItem("cveAPICache", JSON.stringify(Object.fromEntries(toKeep)));
            } else {
                localStorage.setItem("cveAPICache", JSON.stringify(cache));
            }
        } catch (error) {
            logger.warn("ui", "[Cache Storage Error]:", error);
        }
    }

    /**
     * T040: Retrieve cached API response
     * @param {string} cveId - CVE identifier
     * @returns {Object|null} Cached data or null
     */
    /**
     * Retrieve cached API response for a CVE ID.
     * Checks localStorage cache for valid, non-expired entries.
     * Automatically cleans up expired cache entries.
     *
     * @param {string} cveId - CVE identifier to lookup in cache
     * @returns {Object|null} Cached API response data or null if not found/expired
     */
    getCachedAPIResponse(cveId) {
        try {
            const cache = JSON.parse(localStorage.getItem("cveAPICache") || "{}");
            const entry = cache[cveId];
            
            if (entry && entry.expires > Date.now()) {
                return entry.data;
            }
            
            // Clean up expired entry
            if (entry) {
                delete cache[cveId];
                localStorage.setItem("cveAPICache", JSON.stringify(cache));
            }
        } catch (error) {
            logger.warn("ui", "[Cache Retrieval Error]:", error);
        }
        return null;
    }

    /**
     * T040: Handle offline mode with graceful degradation
     * @param {string} cveId - CVE identifier
     */
    handleOfflineMode(cveId) {
        // Check for cached data first
        const cachedData = this.getCachedAPIResponse(cveId);
        if (cachedData) {
            this.toastHandler.showToast("Using cached CVE data (offline mode)...", "info");
            this.displayCVEInfo(cveId, cachedData);
        } else {
            // Provide offline-friendly alternative
            this.toastHandler.showToast("Offline: Cannot fetch CVE data. Showing local information...", "warning");
            this.displayOfflineCVEInfo(cveId);
        }
    }

    /**
     * T040: Display offline CVE information
     * @param {string} cveId - CVE identifier
     */
    displayOfflineCVEInfo(cveId) {
        const modal = document.getElementById("cveDetailsModal");
        if (!modal) {return;}

        const modalTitle = modal.querySelector(".modal-title");
        const modalBody = modal.querySelector(".modal-body");

        if (modalTitle) {
            modalTitle.textContent = `${cveId} (Offline Mode)`;
        }

        if (modalBody) {
            modalBody.innerHTML = `
                <div class="offline-notice">
                    <h4>‚ö†Ô∏è Offline Mode</h4>
                    <p>Unable to fetch live CVE data. You can:</p>
                    <ul>
                        <li>View this CVE when connection is restored</li>
                        <li>Check your local vulnerability database</li>
                        <li>Save this CVE ID for later lookup: <strong>${cveId}</strong></li>
                    </ul>
                    <div class="cve-actions">
                        <button class="btn btn-secondary" onclick="navigator.clipboard.writeText('${cveId}').then(() => window.toastHandler?.showToast('CVE ID copied to clipboard', 'success'))">
                            üìã Copy CVE ID
                        </button>
                        <button class="btn btn-primary" onclick="localStorage.setItem('pendingCVELookups', JSON.stringify([...(JSON.parse(localStorage.getItem('pendingCVELookups') || '[]')), '${cveId}'])); window.toastHandler?.showToast('CVE saved for later lookup', 'success')">
                            üíæ Save for Later
                        </button>
                    </div>
                </div>
            `;
        }

        // Show the modal
        modal.style.display = "block";
        setTimeout(() => modal.classList.add("show"), 10);
    }

    /**
     * T040: Process pending CVE lookups when coming back online
     */
    processPendingCVELookups() {
        const pendingLookups = JSON.parse(localStorage.getItem("pendingCVELookups") || "[]");
        if (pendingLookups.length > 0 && navigator.onLine) {
            this.toastHandler.showToast(`Processing ${pendingLookups.length} pending CVE lookup(s)...`, "info");
            
            pendingLookups.forEach((cveId, index) => {
                setTimeout(() => {
                    this.lookupVulnerability(cveId);
                }, index * 1000); // Stagger requests
            });
            
            // Clear pending list
            localStorage.removeItem("pendingCVELookups");
        }
    }
}