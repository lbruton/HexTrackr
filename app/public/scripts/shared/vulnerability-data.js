/* eslint-env browser */
/* exported VulnerabilityDataManager */

/**
 * @fileoverview
 * Vulnerability Data Management Module
 * Extracted from ModernVulnManager as part of JavaScript modularization effort.
 * 
 * This module provides:
 * - API data fetching and caching
 * - Device data processing and aggregation
 * - Data filtering and search functionality
 * - CVE grouping and vulnerability organization
 * - Statistics loading and management
 * 
 * @version 1.0.0
 * @author HexTrackr Team
 * @date 2025-09-05
 */

/**
 * VulnerabilityDataManager - Centralized data management for vulnerability system
 * 
 * Usage:
 * ```javascript
 * const dataManager = new VulnerabilityDataManager('/api');
 * await dataManager.loadData();
 * const filteredData = dataManager.filterData('searchTerm', 'Critical');
 * ```
 */
class VulnerabilityDataManager {
    constructor(apiBase = "/api") {
        this.apiBase = apiBase;
        this.vulnerabilities = [];
        this.filteredVulnerabilities = [];
        this.devices = [];
        this.historicalData = [];
        this.statistics = {};
        this.trends = {};
        this.uniqueAssets = new Set();

        // HEX-101 Section 5: Store pagination info from server
        this.paginationInfo = {
            total: 0,
            page: 1,
            limit: 30000,
            pages: 1
        };

        /**
         * HEX-112 Phase 3: Master Toggle for Pagination Architecture Migration
         *
         * CRITICAL: This is infrastructure for component migration, NOT a user feature!
         *
         * This flag controls TWO critical behaviors:
         * 1. Data Loading Mode: Legacy (30k records) vs Paginated (100 records + API calls)
         * 2. Cache Control: When enabled, bypasses aggressive 5-10min caching for fresh queries
         *
         * WHY THIS EXISTS:
         * - Legacy mode uses aggressive caching (fast but stale data for filters/search)
         * - Pagination mode needs fresh data for every user interaction
         * - Without this, searches would return 10-minute-old cached results
         *
         * MIGRATION STRATEGY:
         * - Phase 3: Infrastructure (THIS TOGGLE) ‚úÖ COMPLETE
         * - Phase 4: Migrate components to check this flag and use appropriate data source
         * - Each component will have conditional logic: if (isPaginationEnabled()) {...}
         *
         * DO NOT expose this to users via UI - it's controlled via console:
         * localStorage.setItem("hextrackr_enablePagination", "true")
         *
         * @type {boolean}
         * @private
         */
        this.usePagination = localStorage.getItem("hextrackr_enablePagination") === "true";

        // HEX-112 Phase 3: Pagination mode data storage
        this.currentPage = []; // Only the current page of data in pagination mode
        this.serverStats = null; // Statistics from server endpoint
        this.chartDataCache = {}; // Chart data from server endpoints

        // Event listeners for data updates
        this.listeners = new Map();
    }

    /**
     * Load vulnerability data from API endpoints
     * HEX-112 Phase 3: Dual-mode implementation with feature flag
     *
     * @param {boolean} bustCache - Force cache bypass (CRITICAL for pagination mode)
     *                              When true, adds timestamp to bypass nginx/node-cache (5-10min TTL)
     *                              Essential for fresh results in search/filter operations
     *                              Without this, users would see 10-minute-old cached results
     * @param {Object} options - Pagination options (only used in pagination mode)
     * @param {number} options.page - Page number (default: 1)
     * @param {number} options.limit - Records per page (default: 100)
     * @param {Object} options.filters - Filter criteria for server-side filtering
     * @param {string} options.sortBy - Sort field (default: 'scan_date')
     * @param {string} options.order - Sort order 'asc'|'desc' (default: 'desc')
     * @returns {Promise<void>}
     */
    async loadData(bustCache = false, options = {}) {
        if (this.usePagination) {
            // HEX-112 Phase 3: Pagination mode
            await this._loadDataPaginated(bustCache, options);
        } else {
            // Legacy mode (current production)
            // HEX-117 Phase 2: Pass options to legacy mode for filtering
            await this._loadDataLegacy(bustCache, options);
        }
    }

    /**
     * HEX-112 Phase 3: Legacy mode data loading
     * HEX-117 Phase 2: Modified to accept filter options (limit, isKev, etc.)
     * @param {boolean} bustCache - Force cache refresh
     * @param {Object} options - Filter options (limit, isKev, etc.)
     * @returns {Promise<void>}
     * @private
     */
    async _loadDataLegacy(bustCache = false, options = {}) {
        try {
            // Emit loading start event
            this.emit("loadingStart", { message: "Loading vulnerability data..." });

            // HEX-117 Phase 2: Build URL with optional filters
            const limit = options.limit || 30000;
            const timestamp = bustCache ? `&_t=${Date.now()}` : "";
            // HEX-117: Standardized 'kev' parameter (not 'isKev') for consistency with backend
            const kevFilter = options.kev ? `&kev=${options.kev}` : "";
            const vulnerabilitiesUrl = `${this.apiBase}/vulnerabilities?limit=${limit}${kevFilter}${timestamp}`;

            // PERFORMANCE FIX: Load stats and trends in parallel FIRST
            // Only skip if we loaded them in THIS EXACT REQUEST (not just if data exists)
            // Use a simple flag to track if we loaded stats/trends in this _loadDataLegacy call
            let statsLoadedThisRequest = false;

            // Only load if: (1) no data exists OR (2) cache bust requested
            if (bustCache || !this.statistics || Object.keys(this.statistics).length === 0 ||
                !this.historicalData || this.historicalData.length === 0 ||
                !this.trends || Object.keys(this.trends).length === 0) {

                const timestampParam = bustCache ? `?_t=${Date.now()}` : "";
                const [statsResponse, trendsResponse, recentTrendsResponse] = await Promise.all([
                    fetch(`${this.apiBase}/vulnerabilities/stats${timestampParam}`),
                    fetch(`${this.apiBase}/vulnerabilities/trends${timestampParam}`),
                    fetch(`${this.apiBase}/vulnerabilities/recent-trends${timestampParam}`)
                ]);

                // Process all responses
                if (statsResponse.ok) {
                    this.statistics = await statsResponse.json();
                    console.log("‚ö° Statistics loaded in parallel");
                    statsLoadedThisRequest = true;
                }

                if (trendsResponse.ok) {
                    this.historicalData = await trendsResponse.json();
                    console.log("‚ö° Historical trends (chart data) loaded in parallel");
                }

                if (recentTrendsResponse.ok) {
                    this.trends = await recentTrendsResponse.json();
                    console.log("‚ö° Recent trends (percentages) loaded in parallel");
                }

                // Emit event AFTER all data is loaded
                this.emit("statisticsLoaded", {
                    statistics: this.statistics,
                    trends: this.trends
                });
            } else {
                console.log("‚ö° Stats/trends already loaded in this session, skipping");
            }

            // Emit early progress - charts can now render
            this.emit("loadingProgress", { message: "Charts ready, loading table data...", percent: 30 });

            // Load current vulnerabilities (can be slow for 30k records)
            const response = await fetch(vulnerabilitiesUrl);
            if (response.ok) {
                this.emit("loadingProgress", { message: "Processing vulnerability data...", percent: 30 });

                const result = await response.json();

                // HEX-101 Section 5: Capture pagination info from server
                if (result.pagination) {
                    this.paginationInfo = result.pagination;
                    console.log(`üìä Pagination info: ${result.pagination.total} total vulnerabilities, page ${result.pagination.page} of ${result.pagination.pages}`);
                }

                // HEX-120: Process ALL datasets client-side for consistent data structure
                // Previous optimization used backend /api/devices/stats but had incompatible format
                const dataSize = (result.data || []).length;
                console.log(`Processing ${dataSize} vulnerabilities client-side`);

                // Store raw vulnerability data
                this.vulnerabilities = result.data || [];

                // Build device objects with correct structure (includes device.vulnerabilities arrays)
                this.processDevices();

                // Emit device processing completion
                this.emit("devicesProcessed", { devices: this.devices });

                // Data completeness monitoring
                this.checkDataCompleteness(result);
            } else {
                this.vulnerabilities = [];
                // Reset pagination info on error
                this.paginationInfo = {
                    total: 0,
                    page: 1,
                    limit: 30000,
                    pages: 1
                };
            }

            this.emit("loadingProgress", { message: "Finalizing data processing...", percent: 85 });

            // Statistics and trends already loaded in parallel at start - just filter data
            this.filterData();

            this.emit("loadingProgress", { message: "Finalizing...", percent: 95 });

            // Notify listeners of data update
            this.emit("dataLoaded", {
                mode: "legacy",
                vulnerabilities: this.vulnerabilities,
                devices: this.devices,
                historicalData: this.historicalData,
                statistics: this.statistics
            });

            // Emit loading complete event
            this.emit("loadingComplete", {
                message: `Loaded ${this.vulnerabilities.length} vulnerabilities successfully`,
                totalVulnerabilities: this.vulnerabilities.length,
                mode: "legacy"
            });

            // Navigation Performance Fix: Hybrid caching strategy
            // Store only lightweight metadata (stats + trends) in sessionStorage
            // Full vulnerability data will be cached by HTTP/nginx layer
            // This enables instant charts/stats restore + fast grid load (~10-20ms)
            try {
                sessionStorage.setItem('hextrackr_last_load', Date.now().toString());
                sessionStorage.setItem('hextrackr_cache_metadata', JSON.stringify({
                    statistics: this.statistics,
                    historicalData: this.historicalData,
                    trends: this.trends,
                    recordCount: this.vulnerabilities.length,
                    // Flag indicating grid data is cached in browser/nginx
                    gridDataCached: true
                }));
                console.log(`üíæ Cached metadata for instant navigation (${this.vulnerabilities.length} records in HTTP cache)`);
            } catch (cacheError) {
                // SessionStorage quota exceeded or unavailable - non-critical
                console.warn("Could not save cache metadata:", cacheError);
            }

        } catch (error) {
            console.error("Error loading vulnerability data:", error);
            this.emit("error", { message: "Error loading data from database", error });
            throw error;
        }
    }

    /**
     * HEX-112 Phase 3: Pagination mode data loading (multiple targeted endpoints)
     * @param {boolean} bustCache - Force cache refresh
     * @param {Object} options - Pagination options
     * @returns {Promise<void>}
     * @private
     */
    async _loadDataPaginated(bustCache = false, options = {}) {
        try {
            this.emit("loadingStart", { message: "Loading paginated data..." });

            const { page = 1, limit = 100, filters = {}, sortBy = "scan_date", order = "desc" } = options;
            const timestamp = bustCache ? `&_t=${Date.now()}` : "";

            // Build filter query string manually (avoid URLSearchParams for ESLint compatibility)
            const filterPairs = Object.entries(filters).map(([key, value]) => `${key}=${encodeURIComponent(value)}`);
            const filterString = filterPairs.length > 0 ? `&${filterPairs.join("&")}` : "";

            // Parallel fetch for efficiency - load all needed data at once
            this.emit("loadingProgress", { message: "Fetching data from server...", percent: 20 });

            const [pageData, stats, trends, devices, cvss, severity, recent] = await Promise.all([
                fetch(`${this.apiBase}/vulnerabilities?page=${page}&limit=${limit}&sortBy=${sortBy}&order=${order}${filterString}${timestamp}`).then(r => r.ok ? r.json() : { data: [], pagination: {} }),
                fetch(`${this.apiBase}/vulnerabilities/stats${timestamp ? "?" + timestamp.slice(1) : ""}`).then(r => r.ok ? r.json() : null),
                fetch(`${this.apiBase}/vulnerabilities/trends${timestamp ? "?" + timestamp.slice(1) : ""}`).then(r => r.ok ? r.json() : []),
                fetch(`${this.apiBase}/devices/stats${timestamp ? "?" + timestamp.slice(1) : ""}`).then(r => r.ok ? r.json() : []),
                fetch(`${this.apiBase}/vulnerabilities/cvss-distribution${timestamp ? "?" + timestamp.slice(1) : ""}`).then(r => r.ok ? r.json() : []),
                fetch(`${this.apiBase}/vulnerabilities/severity-distribution${timestamp ? "?" + timestamp.slice(1) : ""}`).then(r => r.ok ? r.json() : []),
                fetch(`${this.apiBase}/vulnerabilities/recent?limit=10${timestamp}`).then(r => r.ok ? r.json() : [])
            ]);

            this.emit("loadingProgress", { message: "Processing paginated data...", percent: 60 });

            // Store paginated data
            this.currentPage = pageData.data || [];
            this.paginationInfo = pageData.pagination || { total: 0, page: 1, limit: 100, pages: 1 };

            // Store server statistics
            this.serverStats = stats;

            // Convert stats to expected format for backward compatibility
            if (stats) {
                this.statistics = {};
                ["critical", "high", "medium", "low", "info"].forEach(severity => {
                    this.statistics[severity] = {
                        count: stats[severity]?.count || 0,
                        total_vpr: stats[severity]?.total_vpr || 0,
                        avg_vpr: stats[severity]?.avg_vpr || 0
                    };
                });
            }

            // Store chart data cache
            this.chartDataCache = {
                trends: trends,
                devices: devices,
                cvss: cvss,
                severity: severity,
                recent: recent
            };

            // Store historical data for charts
            this.historicalData = trends;

            this.emit("loadingProgress", { message: "Building device view...", percent: 80 });

            // Build devices from server endpoint data
            // Extract devices array from response object
            this.devices = devices.devices || devices || [];
            this.uniqueAssets = new Set(this.devices.map(d => d.hostname));

            // In pagination mode, we don't filter client-side
            // Filtering happens server-side via filter parameters
            this.filteredVulnerabilities = this.currentPage;

            this.emit("loadingProgress", { message: "Finalizing...", percent: 95 });

            // Notify listeners of data update with pagination metadata
            this.emit("dataLoaded", {
                mode: "paginated",
                currentPage: this.currentPage,
                pagination: this.paginationInfo,
                devices: this.devices,
                historicalData: this.historicalData,
                statistics: this.statistics,
                chartData: this.chartDataCache
            });

            // Emit loading complete event
            this.emit("loadingComplete", {
                message: `Loaded page ${this.paginationInfo.page} of ${this.paginationInfo.pages} (${this.currentPage.length} vulnerabilities)`,
                totalVulnerabilities: this.paginationInfo.total,
                loadedVulnerabilities: this.currentPage.length,
                mode: "paginated"
            });

            console.log(`‚úÖ Pagination Mode: Page ${this.paginationInfo.page}/${this.paginationInfo.pages}, ${this.currentPage.length} records loaded, ${this.paginationInfo.total} total`);

        } catch (error) {
            console.error("Error loading paginated data:", error);
            this.emit("error", { message: "Error loading paginated data", error });
            throw error;
        }
    }

    /**
     * Process vulnerability data to create device aggregations with VPR scoring.
     * Groups vulnerabilities by hostname and calculates severity counts and VPR totals
     * for each device. Updates both devices array and unique assets set.
     *
     * @returns {void}
     */
    processDevices() {
        const deviceMap = new Map();
        
        this.vulnerabilities.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    vulnerabilities: [],
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalCount: 0,
                    totalVPR: 0
                });
            }
            
            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;
            
            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;
            
            switch (vuln.severity) {
                case "Critical": 
                    device.criticalCount++; 
                    device.criticalVPR += vprScore;
                    break;
                case "High": 
                    device.highCount++; 
                    device.highVPR += vprScore;
                    break;
                case "Medium": 
                    device.mediumCount++; 
                    device.mediumVPR += vprScore;
                    break;
                case "Low": 
                    device.lowCount++; 
                    device.lowVPR += vprScore;
                    break;
            }
        });
        
        this.devices = Array.from(deviceMap.values());
        this.uniqueAssets = new Set(this.devices.map(d => d.hostname));
        
        // Notify listeners of device processing completion
        this.emit("devicesProcessed", { devices: this.devices });
    }

    /**
     * Process vulnerability data asynchronously in chunks to prevent UI blocking
     * @param {Array} data - Array of vulnerability objects
     * @returns {Promise<void>}
     */
    async processDataAsync(data) {
        this.vulnerabilities = data;
        const chunkSize = 1000;
        const totalItems = data.length;

        // Initialize device map
        const deviceMap = new Map();

        // Process data in chunks to prevent UI blocking
        for (let i = 0; i < totalItems; i += chunkSize) {
            const chunk = data.slice(i, i + chunkSize);
            const progress = Math.min(Math.round(((i + chunkSize) / totalItems) * 35), 35); // 30-65% range

            // Emit progress update
            this.emit("loadingProgress", {
                message: `Processing vulnerabilities... (${Math.min(i + chunkSize, totalItems)}/${totalItems})`,
                percent: 30 + progress
            });

            // Process chunk asynchronously
            await new Promise(resolve => {
                // Use requestIdleCallback for non-blocking processing
                const callback = () => {
                    this.processVulnerabilityChunk(chunk, deviceMap);
                    resolve();
                };

                if (window.requestIdleCallback) {
                    requestIdleCallback(callback, { timeout: 50 });
                } else {
                    // Fallback for browsers without requestIdleCallback
                    setTimeout(callback, 0);
                }
            });
        }

        // Finalize device processing
        this.devices = Array.from(deviceMap.values());
        this.uniqueAssets = new Set(this.devices.map(d => d.hostname));

        // Emit completion of device processing
        this.emit("devicesProcessed", { devices: this.devices });
    }

    /**
     * Process a chunk of vulnerabilities for device aggregation
     * @param {Array} chunk - Chunk of vulnerability objects
     * @param {Map} deviceMap - Map to accumulate device data
     */
    processVulnerabilityChunk(chunk, deviceMap) {
        chunk.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    ipAddress: vuln.ip_address || "",
                    vulnerabilities: [],
                    totalCount: 0,
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalVPR: 0
                });
            }

            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;

            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;

            switch (vuln.severity) {
                case "Critical":
                    device.criticalCount++;
                    device.criticalVPR += vprScore;
                    break;
                case "High":
                    device.highCount++;
                    device.highVPR += vprScore;
                    break;
                case "Medium":
                    device.mediumCount++;
                    device.mediumVPR += vprScore;
                    break;
                case "Low":
                    device.lowCount++;
                    device.lowVPR += vprScore;
                    break;
            }
        });
    }

    /**
     * Load statistics and trend data from API
     * @param {boolean} bustCache - Force cache refresh with timestamp parameter
     * @returns {Promise<void>}
     */
    async loadStatistics(bustCache = false) {
        try {
            // Build URL with optional cache-busting parameter
            const statsTimestamp = bustCache ? `?_t=${Date.now()}` : "";
            const statsUrl = `${this.apiBase}/vulnerabilities/stats${statsTimestamp}`;

            // First load the actual statistics
            const statsResponse = await fetch(statsUrl);
            if (statsResponse.ok) {
                const stats = await statsResponse.json();

                // Convert the stats response to the expected format
                this.statistics = {};
                ["critical", "high", "medium", "low", "info"].forEach(severity => {
                    if (stats[severity]) {
                        this.statistics[severity] = {
                            count: stats[severity].count,
                            total_vpr: stats[severity].total_vpr,
                            avg_vpr: stats[severity].avg_vpr || 0
                        };
                    } else {
                        // Default for missing severities
                        this.statistics[severity] = {
                            count: 0,
                            total_vpr: 0,
                            avg_vpr: 0
                        };
                    }
                });

                // Also try to load trends (but don't fail if not available)
                try {
                    const recentTrendsTimestamp = bustCache ? `?_t=${Date.now()}` : "";
                    const recentTrendsUrl = `${this.apiBase}/vulnerabilities/recent-trends${recentTrendsTimestamp}`;
                    const trendsResponse = await fetch(recentTrendsUrl);
                    if (trendsResponse.ok) {
                        this.trends = await trendsResponse.json();
                    }
                } catch (trendsError) {
                    console.warn("Trends not available:", trendsError);
                    this.trends = {};
                }

                // Notify listeners of statistics update
                this.emit("statisticsLoaded", {
                    statistics: this.statistics,
                    trends: this.trends
                });
            }
        } catch (error) {
            console.error("Error loading statistics:", error);
            this.emit("error", { message: "Error loading statistics", error });
        }
    }

    /**
     * Filter vulnerability data based on search term, severity, and vendor
     * @param {string} searchTerm - Search term for hostname, CVE, or plugin name
     * @param {string} severityFilter - Severity level filter
     * @param {string} vendorFilter - Vendor filter (CISCO, Palo Alto, Other)
     * @returns {Array} Filtered vulnerabilities
     */
    filterData(searchTerm = null, severityFilter = null, vendorFilter = null) {
        // Get current filter values from DOM if not provided
        const currentSearchTerm = searchTerm ??
            (document.getElementById("searchInput")?.value.toLowerCase() || "");
        const currentSeverityFilter = severityFilter ??
            (document.getElementById("severityFilter")?.value || "");
        const currentVendorFilter = vendorFilter ??
            (document.getElementById("vendorFilter")?.value || "");

        this.filteredVulnerabilities = this.vulnerabilities.filter(vuln => {
            const matchesSearch = !currentSearchTerm ||
                vuln.hostname.toLowerCase().includes(currentSearchTerm) ||
                vuln.cve.toLowerCase().includes(currentSearchTerm) ||
                vuln.plugin_name.toLowerCase().includes(currentSearchTerm);

            // Handle KEV filtering separately from severity filtering
            let matchesSeverity;
            if (currentSeverityFilter === "KEV") {
                matchesSeverity = vuln.isKev === "Yes";
            } else {
                matchesSeverity = !currentSeverityFilter || vuln.severity === currentSeverityFilter;
            }

            // Handle vendor filtering using plugin_name to determine vendor
            let matchesVendor = true;
            if (currentVendorFilter) {
                const pluginVendor = this.normalizeVendor(vuln.plugin_name || "");
                matchesVendor = pluginVendor === currentVendorFilter;
            }

            return matchesSearch && matchesSeverity && matchesVendor;
        });

        // Notify listeners of filter update
        this.emit("dataFiltered", {
            filteredVulnerabilities: this.filteredVulnerabilities,
            searchTerm: currentSearchTerm,
            severityFilter: currentSeverityFilter,
            vendorFilter: currentVendorFilter
        });

        return this.filteredVulnerabilities;
    }

    /**
     * Group filtered vulnerabilities by CVE for card view display.
     * Uses CVE identifier when available, falls back to plugin ID for grouping.
     * Used by vulnerability cards component to organize vulnerabilities by unique identifier.
     *
     * @returns {Object} Object with CVE/plugin keys mapping to arrays of vulnerabilities
     * @example
     * // Returns: { "CVE-2023-12345": [vuln1, vuln2], "plugin_12345": [vuln3] }
     */
    groupVulnerabilitiesByCVE() {
        const grouped = {};
        this.filteredVulnerabilities.forEach(vuln => {
            const key = vuln.cve || `plugin_${vuln.plugin_id}`;
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(vuln);
        });
        return grouped;
    }

    /**
     * Get device by hostname
     * @param {string} hostname - Device hostname
     * @returns {Object|null} Device object or null if not found
     */
    getDeviceByHostname(hostname) {
        // HEX-120 Fix: Ensure devices is an array before calling find
        if (!Array.isArray(this.devices)) {
            console.warn("Devices array not initialized yet. Processing devices now...");
            // Force process devices from vulnerabilities if not done yet
            if (this.vulnerabilities && this.vulnerabilities.length > 0) {
                this.processDevices();
            }
            if (!Array.isArray(this.devices)) {
                return null;
            }
        }
        const device = this.devices.find(d => d.hostname === hostname) || null;
        return device;
    }

    /**
     * Get vulnerability statistics
     * @returns {Object} Current statistics object
     */
    getStatistics() {
        return this.statistics;
    }

    /**
     * Get trend data
     * @returns {Object} Current trend data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Get historical data for charting
     * @returns {Array} Historical trend data
     */
    getHistoricalData() {
        return this.historicalData;
    }

    /**
     * Get all vulnerability data
     * HEX-112 Phase 3: Returns current page in pagination mode, full array in legacy mode
     * @returns {Array} All vulnerabilities (or current page in pagination mode)
     */
    getAllVulnerabilities() {
        return this.usePagination ? this.currentPage : this.vulnerabilities;
    }

    /**
     * Get filtered vulnerability data
     * @returns {Array} Filtered vulnerabilities
     */
    getFilteredVulnerabilities() {
        return this.filteredVulnerabilities;
    }

    /**
     * HEX-101 Section 5: Get total count from server pagination info
     * @returns {number} Total count of vulnerabilities from server
     */
    getTotalCount() {
        // Use server-provided total if available, fallback to array length
        return this.paginationInfo.total || this.vulnerabilities.length;
    }

    /**
     * HEX-101 Section 5: Get filtered count
     * @returns {number} Count of filtered vulnerabilities
     * @note When server-side filtering is implemented, this will use server total
     */
    getFilteredCount() {
        // For now, still uses client-side filtered array
        // In future, this will come from server response for filtered queries
        return this.filteredVulnerabilities.length;
    }

    /**
     * HEX-101 Section 5: Get complete pagination info
     * @returns {Object} Full pagination metadata from server
     */
    getPaginationInfo() {
        return this.paginationInfo;
    }

    /**
     * Get all processed devices
     * @returns {Array} All device objects
     */
    getDevices() {
        return this.devices;
    }

    /**
     * Get devices built from filtered vulnerabilities.
     * This method rebuilds device objects using only the filtered vulnerabilities,
     * ensuring that device cards respect severity and search filters.
     *
     * @returns {Array} Array of device objects containing only filtered vulnerabilities
     * @since v1.0.25
     */
    getFilteredDevices() {
        const deviceMap = new Map();

        this.filteredVulnerabilities.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    vulnerabilities: [],
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalCount: 0,
                    totalVPR: 0,
                    hasKev: false,
                    kevCve: null
                });
            }

            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;

            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;

            // Track if device has any KEV vulnerabilities
            if (vuln.isKev === "Yes") {
                device.hasKev = true;
                // Track the first KEV CVE for modal display
                if (!device.kevCve) {
                    device.kevCve = vuln.cve;
                }
            }

            switch (vuln.severity) {
                case "Critical":
                    device.criticalCount++;
                    device.criticalVPR += vprScore;
                    break;
                case "High":
                    device.highCount++;
                    device.highVPR += vprScore;
                    break;
                case "Medium":
                    device.mediumCount++;
                    device.mediumVPR += vprScore;
                    break;
                case "Low":
                    device.lowCount++;
                    device.lowVPR += vprScore;
                    break;
            }
        });

        return Array.from(deviceMap.values());
    }

    /**
     * Get unique asset count
     * @returns {number} Number of unique assets
     */
    getUniqueAssetCount() {
        return this.uniqueAssets.size;
    }

    /**
     * Refresh all data from API
     * @returns {Promise<void>}
     */
    async refreshData(bustCache = false) {
        await this.loadData(bustCache);
    }

    // Event system for communication with other modules
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} callback - Callback function
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} callback - Callback function to remove
     */
    off(event, callback) {
        if (this.listeners.has(event)) {
            const callbacks = this.listeners.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    /**
     * Emit event to all listeners
     * @param {string} event - Event name
     * @param {Object} data - Event data
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in event listener for ${event}:`, error);
                }
            });
        }
    }

    /**
     * Extend timeline data with interpolated values for charting.
     * Adds backward extension (14 days before first data point) and forward extension
     * (to current date) with interpolated VPR values for smooth chart rendering.
     * Marks interpolated points with hasActualData: false for styling distinction.
     *
     * @param {Array} originalData - Original historical data points from API
     * @returns {Array} Extended data with interpolated values for smooth charting
     * @example
     * // Original data: [{date: "2025-01-01", Critical: 5, High: 10}]
     * // Returns: Extended array with interpolated points and hasActualData flags
     */
    extendTimelineData(originalData) {
        if (!originalData || originalData.length === 0) {return [];}
        
        const sortedData = [...originalData].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        const earliestDate = new Date(sortedData[0].date);
        const latestDate = new Date(sortedData[sortedData.length - 1].date);
        const currentDate = new Date();
        
        const backwardExtensionDays = 14;
        const extendedStartDate = new Date(earliestDate);
        extendedStartDate.setDate(extendedStartDate.getDate() - backwardExtensionDays);
        
        const extendedData = [];
        
        const earliestValues = sortedData[0];
        
        // Add backward extension points
        for (let d = new Date(extendedStartDate); d < earliestDate; d.setDate(d.getDate() + 1)) {
            extendedData.push({
                date: new Date(d).toISOString().split("T")[0],
                scan_date: new Date(d).toISOString().split("T")[0],
                Critical: earliestValues.Critical || 0,
                High: earliestValues.High || 0,
                Medium: earliestValues.Medium || 0,
                Low: earliestValues.Low || 0,
                hasActualData: false
            });
        }
        
        // Add original data points
        sortedData.forEach(dataPoint => {
            extendedData.push({
                ...dataPoint,
                hasActualData: true
            });
        });
        
        // Add forward extension to current date if needed
        if (latestDate < currentDate) {
            const latestValues = sortedData[sortedData.length - 1];
            for (let d = new Date(latestDate); d <= currentDate; d.setDate(d.getDate() + 1)) {
                if (d > latestDate) {
                    extendedData.push({
                        date: new Date(d).toISOString().split("T")[0],
                        scan_date: new Date(d).toISOString().split("T")[0],
                        Critical: latestValues.Critical || 0,
                        High: latestValues.High || 0,
                        Medium: latestValues.Medium || 0,
                        Low: latestValues.Low || 0,
                        hasActualData: false
                    });
                }
            }
        }
        
        return extendedData;
    }

    /**
     * Export device vulnerability report as CSV data
     * @param {string} hostname - Device hostname
     * @returns {Object|null} CSV data and metadata or null if device not found
     */
    exportDeviceReport(hostname) {
        const device = this.getDeviceByHostname(hostname);
        if (!device) {
            this.emit("error", { message: `Device ${hostname} not found` });
            return null;
        }

        const csvData = device.vulnerabilities.map(vuln => ({
            "Device": hostname,
            "CVE": vuln.cve || "N/A",
            "VPR Score": vuln.vpr_score || 0,
            "Severity": vuln.severity,
            "Plugin Name": vuln.plugin_name,
            "Port": vuln.port || "N/A",
            "First Seen": vuln.first_seen ? new Date(vuln.first_seen).toLocaleDateString() : "N/A",
            "Last Seen": vuln.last_seen && vuln.last_seen.trim() !== "" 
                ? new Date(vuln.last_seen).toLocaleDateString() 
                : (vuln.scan_date && vuln.scan_date.trim() !== "" 
                    ? new Date(vuln.scan_date).toLocaleDateString()
                    : "N/A"),
            "State": vuln.state || "ACTIVE",
            "Plugin ID": vuln.plugin_id || "N/A",
            "Risk Factor": vuln.risk_factor || "Unknown",
            "Solution": vuln.solution || "N/A"
        }));

        this.emit("deviceReportGenerated", { hostname, csvData, device });
        
        return {
            csvData,
            filename: `device_${hostname}_vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`,
            device
        };
    }

    /**
     * Save vulnerability changes via API
     * @param {number} id - Vulnerability ID
     * @param {Object} formData - Updated vulnerability data
     * @returns {Promise<boolean>} Success status
     */
    async saveVulnerability(id, formData) {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                await this.refreshData();
                this.emit("vulnerabilitySaved", { id, formData });
                return true;
            } else {
                const errorData = await response.json();
                this.emit("error", { message: "Failed to save vulnerability", error: errorData });
                return false;
            }
        } catch (error) {
            console.error("Error saving vulnerability:", error);
            this.emit("error", { message: "Error saving vulnerability", error });
            return false;
        }
    }

    /**
     * Delete vulnerability via API
     * @param {number} id - Vulnerability ID
     * @returns {Promise<boolean>} Success status
     */
    async deleteVulnerability(id) {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "DELETE"
            });

            if (response.ok) {
                await this.refreshData();
                this.emit("vulnerabilityDeleted", { id });
                return true;
            } else {
                this.emit("error", { message: "Failed to delete vulnerability" });
                return false;
            }
        } catch (error) {
            console.error("Error deleting vulnerability:", error);
            this.emit("error", { message: "Error deleting vulnerability", error });
            return false;
        }
    }

    /**
     * Clear all vulnerability data via API
     * @returns {Promise<boolean>} Success status
     */
    async clearAllData() {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/clear`, {
                method: "DELETE"
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Clear operation failed");
            }

            // Bust cache to ensure fresh empty data is loaded (not cached response)
            await this.loadData(true);
            this.emit("allDataCleared", {});
            return true;
        } catch (error) {
            console.error("Error clearing all data:", error);
            this.emit("error", { message: "Error clearing all data", error });
            return false;
        }
    }

    /**
     * Fetch historical VPR data from Tenable API
     * @param {string} apiKey - Tenable API key
     * @param {string} secretKey - Tenable secret key
     * @returns {Promise<Object|null>} Fetched data or null on error
     */
    async fetchTenableHistoricalData(apiKey, secretKey) {
        if (!apiKey || !secretKey) {
            this.emit("error", { message: "Tenable API credentials not configured" });
            return null;
        }
        
        try {
            const response = await fetch(`${this.apiBase}/tenable/historical-vpr`, {
                headers: {
                    "X-Tenable-Api-Key": apiKey,
                    "X-Tenable-Secret-Key": secretKey
                }
            });

            if (!response.ok) {
                const error = await response.json();
                this.emit("error", { message: "Failed to fetch Tenable data", error: error.error });
                return null;
            }

            const data = await response.json();
            await this.refreshData();
            this.emit("tenableDataFetched", { count: data.count, data });
            return data;
        } catch (error) {
            console.error("Error fetching Tenable data:", error);
            this.emit("error", { message: "Error fetching Tenable data", error });
            return null;
        }
    }

    /**
     * Check data completeness and warn if approaching limits
     * @param {Object} result - API response with pagination data
     */
    checkDataCompleteness(result) {
        const loadedCount = this.vulnerabilities.length;
        const totalCount = result.pagination?.total || loadedCount;
        const limit = 30000;

        // Calculate completion percentage
        const completeness = (loadedCount / totalCount) * 100;

        // Store completeness info for monitoring
        this.dataCompleteness = {
            loadedCount,
            totalCount,
            limit,
            completeness: Math.round(completeness * 100) / 100,
            isComplete: loadedCount >= totalCount,
            nearLimit: loadedCount >= (limit * 0.9) // Within 90% of limit
        };

        // Log completeness status
        if (this.dataCompleteness.isComplete) {
            console.log(`‚úÖ Data Complete: ${loadedCount}/${totalCount} vulnerabilities loaded`);
        } else if (this.dataCompleteness.nearLimit) {
            console.warn(`‚ö†Ô∏è Data Limit Warning: ${loadedCount}/${totalCount} vulnerabilities loaded (${this.dataCompleteness.completeness}% complete). Consider increasing limit or implementing pagination.`);
        } else {
            console.log(`üìä Data Loaded: ${loadedCount}/${totalCount} vulnerabilities (${this.dataCompleteness.completeness}% complete)`);
        }

        // HEX-101 Section 5: Update UI with data completeness warning
        this.updateDataCompletenessUI();

        // Emit completeness event for UI notifications
        this.emit("dataCompleteness", this.dataCompleteness);
    }

    /**
     * HEX-101 Section 5: Update UI with data completeness information
     * Shows warning when not all data is loaded
     */
    updateDataCompletenessUI() {
        const info = this.dataCompleteness;
        if (!info) {return;}

        // Update the pagination info display with completeness warning
        const paginationDisplay = document.getElementById("gridPaginationInfo");
        if (paginationDisplay) {
            if (!info.isComplete) {
                // Show warning about incomplete data
                const percentLoaded = info.completeness.toFixed(1);
                paginationDisplay.innerHTML = `
                    <div class="alert alert-warning alert-sm mb-2">
                        <div class="d-flex align-items-center">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            <div>
                                <strong>Partial Data Loaded:</strong>
                                Showing ${info.loadedCount.toLocaleString()} of ${info.totalCount.toLocaleString()} vulnerabilities
                                (${percentLoaded}% loaded)
                                ${info.nearLimit ? "<br><small>‚ö†Ô∏è Approaching 30,000 record limit. Full pagination implementation needed.</small>" : ""}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // All data loaded successfully
                paginationDisplay.innerHTML = `
                    <span class="text-muted">
                        Showing all <strong>${info.loadedCount.toLocaleString()}</strong> vulnerabilities
                    </span>
                `;
            }
        }
    }

    /**
     * Get data completeness information
     * @returns {Object} Completeness metrics
     */
    getDataCompleteness() {
        return this.dataCompleteness || {
            loadedCount: 0,
            totalCount: 0,
            limit: 30000,
            completeness: 0,
            isComplete: true,
            nearLimit: false
        };
    }

    /**
     * Normalize vendor name for consistent filtering
     * @param {string} pluginName - Plugin name to extract vendor from
     * @returns {string} Normalized vendor name (CISCO, Palo Alto, or Other)
     */
    normalizeVendor(pluginName) {
        if (!pluginName) {
            return "Other";
        }

        const cleanName = pluginName.trim().toLowerCase();

        if (cleanName.includes("cisco")) {
            return "CISCO";
        } else if (cleanName.includes("palo alto")) {
            return "Palo Alto";
        } else {
            return "Other";
        }
    }

    /**
     * HEX-112 Phase 3: Enable pagination mode
     * Switches from legacy mode (30k records) to pagination mode (100 records per page)
     * @returns {Promise<void>}
     */
    async enablePagination() {
        if (this.usePagination) {
            console.log("‚ö†Ô∏è Pagination mode already enabled");
            return;
        }

        console.log("üîÑ Switching to PAGINATION mode...");
        this.usePagination = true;
        localStorage.setItem("hextrackr_enablePagination", "true");

        // Reload data in new mode
        await this.refreshData();

        this.emit("paginationModeChanged", { mode: "paginated", enabled: true });
        console.log("‚úÖ Pagination mode enabled");
    }

    /**
     * HEX-112 Phase 3: Disable pagination mode
     * Switches from pagination mode back to legacy mode (30k records)
     * @returns {Promise<void>}
     */
    async disablePagination() {
        if (!this.usePagination) {
            console.log("‚ö†Ô∏è Legacy mode already active");
            return;
        }

        console.log("üîÑ Switching to LEGACY mode...");
        this.usePagination = false;
        localStorage.setItem("hextrackr_enablePagination", "false");

        // Reload data in new mode
        await this.refreshData();

        this.emit("paginationModeChanged", { mode: "legacy", enabled: false });
        console.log("‚úÖ Legacy mode enabled");
    }

    /**
     * HEX-112 Phase 3: Check if pagination mode is enabled
     * @returns {boolean} True if pagination mode is active
     */
    isPaginationEnabled() {
        return this.usePagination;
    }

    /**
     * HEX-112 Phase 3: Get current mode name for UI display
     * @returns {string} Current mode ("paginated" or "legacy")
     */
    getCurrentMode() {
        return this.usePagination ? "paginated" : "legacy";
    }

    /**
     * HEX-112 Phase 3: Load specific page (pagination mode only)
     * @param {number} page - Page number to load
     * @param {Object} options - Additional options (filters, sort, etc.)
     * @returns {Promise<void>}
     */
    async loadPage(page, options = {}) {
        if (!this.usePagination) {
            console.warn("‚ö†Ô∏è loadPage() called in legacy mode - ignored");
            return;
        }

        await this.loadData(false, { ...options, page });
    }

    /**
     * HEX-112 Phase 3: Get chart data (from server in pagination mode, calculated in legacy)
     * @param {string} type - Chart type (trends, devices, cvss, severity, recent)
     * @returns {Array|Object} Chart data
     */
    getChartData(type) {
        if (this.usePagination) {
            return this.chartDataCache[type] || [];
        } else {
            // Legacy mode - calculate from in-memory data
            // This is a simplified version; components handle their own calculations
            return this[type] || [];
        }
    }
}