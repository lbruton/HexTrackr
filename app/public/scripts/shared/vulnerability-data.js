/* eslint-env browser */
/* exported VulnerabilityDataManager */

/**
 * @fileoverview
 * Vulnerability Data Management Module
 * Extracted from ModernVulnManager as part of JavaScript modularization effort.
 * 
 * This module provides:
 * - API data fetching and caching
 * - Device data processing and aggregation
 * - Data filtering and search functionality
 * - CVE grouping and vulnerability organization
 * - Statistics loading and management
 * 
 * @version 1.0.0
 * @author HexTrackr Team
 * @date 2025-09-05
 */

/**
 * VulnerabilityDataManager - Centralized data management for vulnerability system
 * 
 * Usage:
 * ```javascript
 * const dataManager = new VulnerabilityDataManager('/api');
 * await dataManager.loadData();
 * const filteredData = dataManager.filterData('searchTerm', 'Critical');
 * ```
 */
class VulnerabilityDataManager {
    constructor(apiBase = "/api") {
        this.apiBase = apiBase;
        this.vulnerabilities = [];
        this.filteredVulnerabilities = [];
        this.devices = [];
        this.historicalData = [];
        this.statistics = {};
        this.trends = {};
        this.uniqueAssets = new Set();
        
        // Event listeners for data updates
        this.listeners = new Map();
    }

    /**
     * Load vulnerability data from API endpoints
     * @returns {Promise<void>}
     */
    async loadData() {
        try {
            // Emit loading start event
            this.emit("loadingStart", { message: "Loading vulnerability data..." });

            // Load current vulnerabilities
            const response = await fetch(`${this.apiBase}/vulnerabilities?limit=30000`);
            if (response.ok) {
                this.emit("loadingProgress", { message: "Processing vulnerability data...", percent: 30 });

                const result = await response.json();

                // Process data asynchronously to prevent UI blocking
                await this.processDataAsync(result.data || []);

                // Data completeness monitoring
                this.checkDataCompleteness(result);
            } else {
                this.vulnerabilities = [];
            }
            
            this.emit("loadingProgress", { message: "Loading trend data...", percent: 70 });

            // Load historical trend data
            const trendsResponse = await fetch(`${this.apiBase}/vulnerabilities/trends`);
            if (trendsResponse.ok) {
                this.historicalData = await trendsResponse.json();
            } else {
                this.historicalData = [];
            }

            this.emit("loadingProgress", { message: "Loading statistics...", percent: 85 });

            // Load statistics (processDevices was done in processDataAsync)
            await this.loadStatistics();
            this.filterData();

            this.emit("loadingProgress", { message: "Finalizing...", percent: 95 });

            // Notify listeners of data update
            this.emit("dataLoaded", {
                vulnerabilities: this.vulnerabilities,
                devices: this.devices,
                historicalData: this.historicalData,
                statistics: this.statistics
            });

            // Emit loading complete event
            this.emit("loadingComplete", {
                message: `Loaded ${this.vulnerabilities.length} vulnerabilities successfully`,
                totalVulnerabilities: this.vulnerabilities.length
            });
            
        } catch (error) {
            console.error("Error loading vulnerability data:", error);
            this.emit("error", { message: "Error loading data from database", error });
            throw error;
        }
    }

    /**
     * Process vulnerability data to create device aggregations with VPR scoring.
     * Groups vulnerabilities by hostname and calculates severity counts and VPR totals
     * for each device. Updates both devices array and unique assets set.
     *
     * @returns {void}
     */
    processDevices() {
        const deviceMap = new Map();
        
        this.vulnerabilities.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    vulnerabilities: [],
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalCount: 0,
                    totalVPR: 0
                });
            }
            
            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;
            
            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;
            
            switch (vuln.severity) {
                case "Critical": 
                    device.criticalCount++; 
                    device.criticalVPR += vprScore;
                    break;
                case "High": 
                    device.highCount++; 
                    device.highVPR += vprScore;
                    break;
                case "Medium": 
                    device.mediumCount++; 
                    device.mediumVPR += vprScore;
                    break;
                case "Low": 
                    device.lowCount++; 
                    device.lowVPR += vprScore;
                    break;
            }
        });
        
        this.devices = Array.from(deviceMap.values());
        this.uniqueAssets = new Set(this.devices.map(d => d.hostname));
        
        // Notify listeners of device processing completion
        this.emit("devicesProcessed", { devices: this.devices });
    }

    /**
     * Process vulnerability data asynchronously in chunks to prevent UI blocking
     * @param {Array} data - Array of vulnerability objects
     * @returns {Promise<void>}
     */
    async processDataAsync(data) {
        this.vulnerabilities = data;
        const chunkSize = 1000;
        const totalItems = data.length;

        // Initialize device map
        const deviceMap = new Map();

        // Process data in chunks to prevent UI blocking
        for (let i = 0; i < totalItems; i += chunkSize) {
            const chunk = data.slice(i, i + chunkSize);
            const progress = Math.min(Math.round(((i + chunkSize) / totalItems) * 35), 35); // 30-65% range

            // Emit progress update
            this.emit("loadingProgress", {
                message: `Processing vulnerabilities... (${Math.min(i + chunkSize, totalItems)}/${totalItems})`,
                percent: 30 + progress
            });

            // Process chunk asynchronously
            await new Promise(resolve => {
                // Use requestIdleCallback for non-blocking processing
                const callback = () => {
                    this.processVulnerabilityChunk(chunk, deviceMap);
                    resolve();
                };

                if (window.requestIdleCallback) {
                    requestIdleCallback(callback, { timeout: 50 });
                } else {
                    // Fallback for browsers without requestIdleCallback
                    setTimeout(callback, 0);
                }
            });
        }

        // Finalize device processing
        this.devices = Array.from(deviceMap.values());
        this.uniqueAssets = new Set(this.devices.map(d => d.hostname));

        // Emit completion of device processing
        this.emit("devicesProcessed", { devices: this.devices });
    }

    /**
     * Process a chunk of vulnerabilities for device aggregation
     * @param {Array} chunk - Chunk of vulnerability objects
     * @param {Map} deviceMap - Map to accumulate device data
     */
    processVulnerabilityChunk(chunk, deviceMap) {
        chunk.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    ipAddress: vuln.ip_address || "",
                    vulnerabilities: [],
                    totalCount: 0,
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalVPR: 0
                });
            }

            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;

            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;

            switch (vuln.severity) {
                case "Critical":
                    device.criticalCount++;
                    device.criticalVPR += vprScore;
                    break;
                case "High":
                    device.highCount++;
                    device.highVPR += vprScore;
                    break;
                case "Medium":
                    device.mediumCount++;
                    device.mediumVPR += vprScore;
                    break;
                case "Low":
                    device.lowCount++;
                    device.lowVPR += vprScore;
                    break;
            }
        });
    }

    /**
     * Load statistics and trend data from API
     * @returns {Promise<void>}
     */
    async loadStatistics() {
        try {
            // First load the actual statistics
            const statsResponse = await fetch(`${this.apiBase}/vulnerabilities/stats`);
            if (statsResponse.ok) {
                const stats = await statsResponse.json();

                // Convert the stats response to the expected format
                this.statistics = {};
                ["critical", "high", "medium", "low", "info"].forEach(severity => {
                    if (stats[severity]) {
                        this.statistics[severity] = {
                            count: stats[severity].count,
                            total_vpr: stats[severity].total_vpr,
                            avg_vpr: stats[severity].avg_vpr || 0
                        };
                    } else {
                        // Default for missing severities
                        this.statistics[severity] = {
                            count: 0,
                            total_vpr: 0,
                            avg_vpr: 0
                        };
                    }
                });

                // Also try to load trends (but don't fail if not available)
                try {
                    const trendsResponse = await fetch(`${this.apiBase}/vulnerabilities/recent-trends`);
                    if (trendsResponse.ok) {
                        this.trends = await trendsResponse.json();
                    }
                } catch (trendsError) {
                    console.warn("Trends not available:", trendsError);
                    this.trends = {};
                }

                // Notify listeners of statistics update
                this.emit("statisticsLoaded", {
                    statistics: this.statistics,
                    trends: this.trends
                });
            }
        } catch (error) {
            console.error("Error loading statistics:", error);
            this.emit("error", { message: "Error loading statistics", error });
        }
    }

    /**
     * Filter vulnerability data based on search term and severity
     * @param {string} searchTerm - Search term for hostname, CVE, or plugin name
     * @param {string} severityFilter - Severity level filter
     * @returns {Array} Filtered vulnerabilities
     */
    filterData(searchTerm = null, severityFilter = null) {
        // Get current filter values from DOM if not provided
        const currentSearchTerm = searchTerm ?? 
            (document.getElementById("searchInput")?.value.toLowerCase() || "");
        const currentSeverityFilter = severityFilter ?? 
            (document.getElementById("severityFilter")?.value || "");

        this.filteredVulnerabilities = this.vulnerabilities.filter(vuln => {
            const matchesSearch = !currentSearchTerm || 
                vuln.hostname.toLowerCase().includes(currentSearchTerm) ||
                vuln.cve.toLowerCase().includes(currentSearchTerm) ||
                vuln.plugin_name.toLowerCase().includes(currentSearchTerm);
            
            // Handle KEV filtering separately from severity filtering
            let matchesSeverity;
            if (currentSeverityFilter === "KEV") {
                matchesSeverity = vuln.isKev === "Yes";
            } else {
                matchesSeverity = !currentSeverityFilter || vuln.severity === currentSeverityFilter;
            }

            return matchesSearch && matchesSeverity;
        });

        // Notify listeners of filter update
        this.emit("dataFiltered", { 
            filteredVulnerabilities: this.filteredVulnerabilities,
            searchTerm: currentSearchTerm,
            severityFilter: currentSeverityFilter
        });

        return this.filteredVulnerabilities;
    }

    /**
     * Group filtered vulnerabilities by CVE for card view display.
     * Uses CVE identifier when available, falls back to plugin ID for grouping.
     * Used by vulnerability cards component to organize vulnerabilities by unique identifier.
     *
     * @returns {Object} Object with CVE/plugin keys mapping to arrays of vulnerabilities
     * @example
     * // Returns: { "CVE-2023-12345": [vuln1, vuln2], "plugin_12345": [vuln3] }
     */
    groupVulnerabilitiesByCVE() {
        const grouped = {};
        this.filteredVulnerabilities.forEach(vuln => {
            const key = vuln.cve || `plugin_${vuln.plugin_id}`;
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(vuln);
        });
        return grouped;
    }

    /**
     * Get device by hostname
     * @param {string} hostname - Device hostname
     * @returns {Object|null} Device object or null if not found
     */
    getDeviceByHostname(hostname) {
        return this.devices.find(d => d.hostname === hostname) || null;
    }

    /**
     * Get vulnerability statistics
     * @returns {Object} Current statistics object
     */
    getStatistics() {
        return this.statistics;
    }

    /**
     * Get trend data
     * @returns {Object} Current trend data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Get historical data for charting
     * @returns {Array} Historical trend data
     */
    getHistoricalData() {
        return this.historicalData;
    }

    /**
     * Get all vulnerability data
     * @returns {Array} All vulnerabilities
     */
    getAllVulnerabilities() {
        return this.vulnerabilities;
    }

    /**
     * Get filtered vulnerability data
     * @returns {Array} Filtered vulnerabilities
     */
    getFilteredVulnerabilities() {
        return this.filteredVulnerabilities;
    }

    /**
     * Get all processed devices
     * @returns {Array} All device objects
     */
    getDevices() {
        return this.devices;
    }

    /**
     * Get devices built from filtered vulnerabilities.
     * This method rebuilds device objects using only the filtered vulnerabilities,
     * ensuring that device cards respect severity and search filters.
     *
     * @returns {Array} Array of device objects containing only filtered vulnerabilities
     * @since v1.0.25
     */
    getFilteredDevices() {
        const deviceMap = new Map();

        this.filteredVulnerabilities.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    vulnerabilities: [],
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalCount: 0,
                    totalVPR: 0
                });
            }

            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;

            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;

            switch (vuln.severity) {
                case "Critical":
                    device.criticalCount++;
                    device.criticalVPR += vprScore;
                    break;
                case "High":
                    device.highCount++;
                    device.highVPR += vprScore;
                    break;
                case "Medium":
                    device.mediumCount++;
                    device.mediumVPR += vprScore;
                    break;
                case "Low":
                    device.lowCount++;
                    device.lowVPR += vprScore;
                    break;
            }
        });

        return Array.from(deviceMap.values());
    }

    /**
     * Get unique asset count
     * @returns {number} Number of unique assets
     */
    getUniqueAssetCount() {
        return this.uniqueAssets.size;
    }

    /**
     * Refresh all data from API
     * @returns {Promise<void>}
     */
    async refreshData() {
        await this.loadData();
    }

    // Event system for communication with other modules
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} callback - Callback function
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} callback - Callback function to remove
     */
    off(event, callback) {
        if (this.listeners.has(event)) {
            const callbacks = this.listeners.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    /**
     * Emit event to all listeners
     * @param {string} event - Event name
     * @param {Object} data - Event data
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in event listener for ${event}:`, error);
                }
            });
        }
    }

    /**
     * Extend timeline data with interpolated values for charting.
     * Adds backward extension (14 days before first data point) and forward extension
     * (to current date) with interpolated VPR values for smooth chart rendering.
     * Marks interpolated points with hasActualData: false for styling distinction.
     *
     * @param {Array} originalData - Original historical data points from API
     * @returns {Array} Extended data with interpolated values for smooth charting
     * @example
     * // Original data: [{date: "2025-01-01", Critical: 5, High: 10}]
     * // Returns: Extended array with interpolated points and hasActualData flags
     */
    extendTimelineData(originalData) {
        if (!originalData || originalData.length === 0) {return [];}
        
        const sortedData = [...originalData].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        const earliestDate = new Date(sortedData[0].date);
        const latestDate = new Date(sortedData[sortedData.length - 1].date);
        const currentDate = new Date();
        
        const backwardExtensionDays = 14;
        const extendedStartDate = new Date(earliestDate);
        extendedStartDate.setDate(extendedStartDate.getDate() - backwardExtensionDays);
        
        const extendedData = [];
        
        const earliestValues = sortedData[0];
        
        // Add backward extension points
        for (let d = new Date(extendedStartDate); d < earliestDate; d.setDate(d.getDate() + 1)) {
            extendedData.push({
                date: new Date(d).toISOString().split("T")[0],
                scan_date: new Date(d).toISOString().split("T")[0],
                Critical: earliestValues.Critical || 0,
                High: earliestValues.High || 0,
                Medium: earliestValues.Medium || 0,
                Low: earliestValues.Low || 0,
                hasActualData: false
            });
        }
        
        // Add original data points
        sortedData.forEach(dataPoint => {
            extendedData.push({
                ...dataPoint,
                hasActualData: true
            });
        });
        
        // Add forward extension to current date if needed
        if (latestDate < currentDate) {
            const latestValues = sortedData[sortedData.length - 1];
            for (let d = new Date(latestDate); d <= currentDate; d.setDate(d.getDate() + 1)) {
                if (d > latestDate) {
                    extendedData.push({
                        date: new Date(d).toISOString().split("T")[0],
                        scan_date: new Date(d).toISOString().split("T")[0],
                        Critical: latestValues.Critical || 0,
                        High: latestValues.High || 0,
                        Medium: latestValues.Medium || 0,
                        Low: latestValues.Low || 0,
                        hasActualData: false
                    });
                }
            }
        }
        
        return extendedData;
    }

    /**
     * Export device vulnerability report as CSV data
     * @param {string} hostname - Device hostname
     * @returns {Object|null} CSV data and metadata or null if device not found
     */
    exportDeviceReport(hostname) {
        const device = this.getDeviceByHostname(hostname);
        if (!device) {
            this.emit("error", { message: `Device ${hostname} not found` });
            return null;
        }

        const csvData = device.vulnerabilities.map(vuln => ({
            "Device": hostname,
            "CVE": vuln.cve || "N/A",
            "VPR Score": vuln.vpr_score || 0,
            "Severity": vuln.severity,
            "Plugin Name": vuln.plugin_name,
            "Port": vuln.port || "N/A",
            "First Seen": vuln.first_seen ? new Date(vuln.first_seen).toLocaleDateString() : "N/A",
            "Last Seen": vuln.last_seen && vuln.last_seen.trim() !== "" 
                ? new Date(vuln.last_seen).toLocaleDateString() 
                : (vuln.scan_date && vuln.scan_date.trim() !== "" 
                    ? new Date(vuln.scan_date).toLocaleDateString()
                    : "N/A"),
            "State": vuln.state || "ACTIVE",
            "Plugin ID": vuln.plugin_id || "N/A",
            "Risk Factor": vuln.risk_factor || "Unknown",
            "Solution": vuln.solution || "N/A"
        }));

        this.emit("deviceReportGenerated", { hostname, csvData, device });
        
        return {
            csvData,
            filename: `device_${hostname}_vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`,
            device
        };
    }

    /**
     * Save vulnerability changes via API
     * @param {number} id - Vulnerability ID
     * @param {Object} formData - Updated vulnerability data
     * @returns {Promise<boolean>} Success status
     */
    async saveVulnerability(id, formData) {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                await this.refreshData();
                this.emit("vulnerabilitySaved", { id, formData });
                return true;
            } else {
                const errorData = await response.json();
                this.emit("error", { message: "Failed to save vulnerability", error: errorData });
                return false;
            }
        } catch (error) {
            console.error("Error saving vulnerability:", error);
            this.emit("error", { message: "Error saving vulnerability", error });
            return false;
        }
    }

    /**
     * Delete vulnerability via API
     * @param {number} id - Vulnerability ID
     * @returns {Promise<boolean>} Success status
     */
    async deleteVulnerability(id) {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "DELETE"
            });

            if (response.ok) {
                await this.refreshData();
                this.emit("vulnerabilityDeleted", { id });
                return true;
            } else {
                this.emit("error", { message: "Failed to delete vulnerability" });
                return false;
            }
        } catch (error) {
            console.error("Error deleting vulnerability:", error);
            this.emit("error", { message: "Error deleting vulnerability", error });
            return false;
        }
    }

    /**
     * Clear all vulnerability data via API
     * @returns {Promise<boolean>} Success status
     */
    async clearAllData() {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/clear`, {
                method: "DELETE"
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Clear operation failed");
            }

            await this.refreshData();
            this.emit("allDataCleared", {});
            return true;
        } catch (error) {
            console.error("Error clearing all data:", error);
            this.emit("error", { message: "Error clearing all data", error });
            return false;
        }
    }

    /**
     * Fetch historical VPR data from Tenable API
     * @param {string} apiKey - Tenable API key
     * @param {string} secretKey - Tenable secret key
     * @returns {Promise<Object|null>} Fetched data or null on error
     */
    async fetchTenableHistoricalData(apiKey, secretKey) {
        if (!apiKey || !secretKey) {
            this.emit("error", { message: "Tenable API credentials not configured" });
            return null;
        }
        
        try {
            const response = await fetch(`${this.apiBase}/tenable/historical-vpr`, {
                headers: {
                    "X-Tenable-Api-Key": apiKey,
                    "X-Tenable-Secret-Key": secretKey
                }
            });

            if (!response.ok) {
                const error = await response.json();
                this.emit("error", { message: "Failed to fetch Tenable data", error: error.error });
                return null;
            }

            const data = await response.json();
            await this.refreshData();
            this.emit("tenableDataFetched", { count: data.count, data });
            return data;
        } catch (error) {
            console.error("Error fetching Tenable data:", error);
            this.emit("error", { message: "Error fetching Tenable data", error });
            return null;
        }
    }

    /**
     * Check data completeness and warn if approaching limits
     * @param {Object} result - API response with pagination data
     */
    checkDataCompleteness(result) {
        const loadedCount = this.vulnerabilities.length;
        const totalCount = result.pagination?.total || loadedCount;
        const limit = 30000;

        // Calculate completion percentage
        const completeness = (loadedCount / totalCount) * 100;

        // Store completeness info for monitoring
        this.dataCompleteness = {
            loadedCount,
            totalCount,
            limit,
            completeness: Math.round(completeness * 100) / 100,
            isComplete: loadedCount >= totalCount,
            nearLimit: loadedCount >= (limit * 0.9) // Within 90% of limit
        };

        // Log completeness status
        if (this.dataCompleteness.isComplete) {
            console.log(`‚úÖ Data Complete: ${loadedCount}/${totalCount} vulnerabilities loaded`);
        } else if (this.dataCompleteness.nearLimit) {
            console.warn(`‚ö†Ô∏è Data Limit Warning: ${loadedCount}/${totalCount} vulnerabilities loaded (${this.dataCompleteness.completeness}% complete). Consider increasing limit or implementing pagination.`);
        } else {
            console.log(`üìä Data Loaded: ${loadedCount}/${totalCount} vulnerabilities (${this.dataCompleteness.completeness}% complete)`);
        }

        // Emit completeness event for UI notifications
        this.emit("dataCompleteness", this.dataCompleteness);
    }

    /**
     * Get data completeness information
     * @returns {Object} Completeness metrics
     */
    getDataCompleteness() {
        return this.dataCompleteness || {
            loadedCount: 0,
            totalCount: 0,
            limit: 30000,
            completeness: 0,
            isComplete: true,
            nearLimit: false
        };
    }
}