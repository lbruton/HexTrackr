/**
 * Vulnerability Markdown Editor Module for HexTrackr v1.0.21
 *
 * Provides interactive markdown template editing functionality for vulnerability reports.
 * Features: template editing, variable substitution, preview mode, and validation.
 *
 * @fileoverview Vulnerability markdown template editor for customizing vulnerability display
 * @author HexTrackr Development Team
 * @version 1.0.21
 */

/* global fetch, bootstrap, DOMPurify */

/**
 * Vulnerability Markdown Editor Class
 * Manages the vulnerability markdown template editing interface
 */
class VulnerabilityMarkdownEditor {
    constructor() {
        this.isEditMode = false;
        this.currentTemplate = null;
        this.currentTicketData = null;
        this.validationTimeout = null;
        this.isRestoring = false;

        // Use unified variables from the global variable system
        this.variables = window.HexTrackrTemplateVariables?.getRecommendedVariables('vulnerability') || [];

        this.init();
    }

    /**
     * Initialize the vulnerability markdown editor
     */
    init() {
        // Populate variable reference panel when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.populateVariablePanel());
        } else {
            this.populateVariablePanel();
        }

        // Set up real-time validation
        this.setupValidation();
    }

    /**
     * Toggle between view and edit modes
     */
    async toggleEditMode() {
        const viewMode = document.getElementById('vulnerabilityViewMode');
        const editMode = document.getElementById('vulnerabilityEditMode');

        if (!this.isEditMode) {
            // Entering edit mode
            try {
                await this.loadTemplateForEditing();

                viewMode.style.display = 'none';
                editMode.style.display = 'block';
                this.isEditMode = true;

                // Focus on editor
                const editor = document.getElementById('vulnerabilityTemplateEditor');
                if (editor) {
                    editor.focus();
                }

                // Ensure variable panel is populated
                this.populateVariablePanel();

                this.showToast('Vulnerability template edit mode enabled', 'info');
            } catch (error) {
                console.error('Error entering vulnerability template edit mode:', error);
                this.showToast('Failed to enter vulnerability template edit mode', 'error');
            }
        } else {
            // Exiting edit mode
            viewMode.style.display = 'block';
            editMode.style.display = 'none';
            this.isEditMode = false;

            this.showToast('Vulnerability template edit mode disabled', 'info');
        }
    }

    /**
     * Load template for editing
     */
    async loadTemplateForEditing(forceRefresh = false) {
        try {
            // If forceRefresh is true, always fetch from API
            if (forceRefresh) {
                console.log('[VulnerabilityMarkdownEditor] Force refresh requested, fetching from API');
                const response = await fetch('/api/templates/by-name/default_vulnerability');
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        this.currentTemplate = result.data;
                        this.cacheTemplate(this.currentTemplate);
                        console.log('[VulnerabilityMarkdownEditor] Template refreshed from API');
                    }
                }
            } else {
                // Try cache first, then API if no cache
                const cached = this.getCachedTemplate('default_vulnerability');
                if (cached) {
                    this.currentTemplate = cached;
                    console.log('[VulnerabilityMarkdownEditor] Using cached template');
                } else if (!this.currentTemplate) {
                    const response = await fetch('/api/templates/by-name/default_vulnerability');
                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            this.currentTemplate = result.data;
                            this.cacheTemplate(this.currentTemplate);
                            console.log('[VulnerabilityMarkdownEditor] Template loaded from API');
                        }
                    }
                }
            }

            if (!this.currentTemplate) {
                await this.createDefaultTemplate();
                return;
            }

            // Temporarily disable aggressive template validation to prevent unwanted restoration
            // TODO: Implement more robust template validation that doesn't interfere with user edits
            if (!this.isRestoring && !this.isTemplateContentValid(this.currentTemplate.template_content)) {
                console.warn('Template content validation failed, but allowing user content to load for editing.');
                console.log('Template content preview:', this.currentTemplate.template_content.substring(0, 100));
            }

            const editor = document.getElementById('vulnerabilityTemplateEditor');
            if (editor && this.currentTemplate) {
                editor.value = this.currentTemplate.template_content;
                this.validateTemplate();
            }
        } catch (error) {
            console.error('Error loading vulnerability template:', error);
            await this.createDefaultTemplate();
        }
    }

    /**
     * Create default template from hardcoded version
     */
    async createDefaultTemplate() {
        const defaultContent = `# Vulnerability Report for [LOCATION]

**XT#:** [XT_NUMBER]
**Hexagon#:** [HEXAGON_TICKET]
**ServiceNow#:** [SERVICENOW_TICKET]

Generated: [GENERATED_TIME]

## Summary

**Total Vulnerabilities:** [TOTAL_VULNERABILITIES]
- **Critical:** [CRITICAL_COUNT]
- **High:** [HIGH_COUNT]
- **Medium:** [MEDIUM_COUNT]
- **Low:** [LOW_COUNT]

**Devices Affected:** [DEVICE_COUNT]

## Vulnerability Details

[VULNERABILITY_DETAILS]

---

**Report End**

*This report was generated automatically from vulnerability scan data. Please review all findings and coordinate with the security team for remediation planning.*`;

        try {
            const templateData = {
                name: 'default_vulnerability',
                description: 'Default vulnerability report template',
                template_content: defaultContent,
                default_content: defaultContent,
                variables: JSON.stringify(this.variables),
                category: 'vulnerability'
            };

            const response = await fetch('/api/templates', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(templateData)
            });

            if (response.status === 409) {
                const existing = await fetch('/api/templates/by-name/default_vulnerability');
                if (existing.ok) {
                    const existingResult = await existing.json();
                    if (existingResult.success) {
                        this.currentTemplate = existingResult.data;
                    }
                }
            } else {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'Failed to seed vulnerability template');
                }

                this.currentTemplate = result.data;
            }

            const editor = document.getElementById('vulnerabilityTemplateEditor');
            if (editor) {
                editor.value = this.currentTemplate.template_content;
                this.validateTemplate();
            }

            this.cacheTemplate(this.currentTemplate);
        } catch (error) {
            console.error('Error ensuring default vulnerability template:', error);
            const editor = document.getElementById('vulnerabilityTemplateEditor');
            if (editor) {
                editor.value = defaultContent;
                this.validateTemplate();
            }

            this.currentTemplate = {
                id: null,
                name: 'default_vulnerability',
                template_content: defaultContent
            };
        }
    }

    /**
     * Populate the variable reference dropdown with organized categories
     */
    populateVariablePanel() {
        const dropdown = document.getElementById('vulnerabilityVariableDropdown');
        if (!dropdown) return;

        dropdown.innerHTML = '';
        dropdown.className = 'dropdown-menu variable-dropdown';

        // Get categories from the global variable system
        const categories = window.HexTrackrTemplateVariables?.categories || {};

        // Group variables by category
        const variablesByCategory = {};
        this.variables.forEach(variable => {
            const category = variable.category || 'other';
            if (!variablesByCategory[category]) {
                variablesByCategory[category] = [];
            }
            variablesByCategory[category].push(variable);
        });

        // Create dropdown items organized by category
        Object.keys(variablesByCategory).forEach((categoryKey, index) => {
            const categoryInfo = categories[categoryKey] || { label: categoryKey, icon: 'fas fa-tag' };
            const variables = variablesByCategory[categoryKey];

            // Add category header
            const categoryHeader = document.createElement('li');
            categoryHeader.innerHTML = `
                <h6 class="dropdown-header">
                    <i class="${categoryInfo.icon}"></i>
                    ${categoryInfo.label}
                </h6>
            `;
            dropdown.appendChild(categoryHeader);

            // Add variables for this category
            variables.forEach(variable => {
                const item = document.createElement('li');
                const button = document.createElement('button');
                button.type = 'button';
                button.className = `dropdown-item ${variable.required ? 'required' : ''}`;
                button.onclick = () => this.insertVariable(variable.name);
                button.title = `${variable.description}${variable.required ? ' (Required)' : ' (Optional)'}`;

                button.innerHTML = `
                    <span>${variable.name}</span>
                    <small class="variable-description">${variable.description}</small>
                `;

                item.appendChild(button);
                dropdown.appendChild(item);
            });

            // Add divider between categories (except for last category)
            if (index < Object.keys(variablesByCategory).length - 1) {
                const divider = document.createElement('li');
                divider.innerHTML = '<hr class="dropdown-divider">';
                dropdown.appendChild(divider);
            }
        });
    }

    /**
     * Insert variable at cursor position
     * @param {string} variable - Variable to insert
     */
    insertVariable(variable) {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (!editor) return;

        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const text = editor.value;

        // Insert variable at cursor position
        const newText = text.substring(0, start) + variable + text.substring(end);
        editor.value = newText;

        // Set cursor position after inserted variable
        const newPosition = start + variable.length;
        editor.setSelectionRange(newPosition, newPosition);
        editor.focus();

        // Trigger validation
        this.validateTemplate();

        this.showToast(`Inserted ${variable}`, 'success');
    }

    /**
     * Preview template with current ticket data
     */
    async previewTemplate() {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (!editor || !this.currentTicketData) {
            this.showToast('No ticket data available for preview', 'warning');
            return;
        }

        try {
            const templateContent = editor.value;

            // Fetch vulnerability data for preview
            const ticketId = document.getElementById("viewTicketModal").getAttribute("data-ticket-id");
            const ticket = window.ticketManager?.getTicketById(ticketId);

            if (ticket?.devices && ticket.devices.length > 0) {
                const vulnerabilities = await window.ticketManager.fetchVulnerabilitiesForDevices(ticket.devices);
                const processedContent = this.processTemplate(templateContent, ticket, vulnerabilities);
                this.showPreviewModal(processedContent);
            } else {
                const processedContent = this.processTemplate(templateContent, this.currentTicketData, []);
                this.showPreviewModal(processedContent);
            }
        } catch (error) {
            console.error('Error previewing vulnerability template:', error);
            this.showToast('Failed to generate preview', 'error');
        }
    }

    /**
     * Process template with ticket and vulnerability data
     * @param {string} template - Template content
     * @param {Object} ticket - Ticket data
     * @param {Array} vulnerabilities - Vulnerability data
     * @returns {string} Processed content
     */
    processTemplate(template, ticket, vulnerabilities = []) {
        let processed = template;

        // Calculate vulnerability counts
        const counts = this.calculateVulnerabilityCounts(vulnerabilities);

        // Generate vulnerability details
        const vulnerabilityDetails = this.generateVulnerabilityDetails(ticket, vulnerabilities);

        // Replace variables with actual data
        const replacements = {
            '[LOCATION]': ticket.location || ticket.site || 'Unknown Location',
            '[XT_NUMBER]': ticket.xtNumber || ticket.xt_number || 'N/A',
            '[HEXAGON_TICKET]': ticket.hexagonTicket || 'N/A',
            '[SERVICENOW_TICKET]': ticket.serviceNowTicket || 'N/A',
            '[GENERATED_TIME]': `${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
            '[VULNERABILITY_DETAILS]': vulnerabilityDetails,
            '[TOTAL_VULNERABILITIES]': counts.total,
            '[CRITICAL_COUNT]': counts.critical,
            '[HIGH_COUNT]': counts.high,
            '[MEDIUM_COUNT]': counts.medium,
            '[LOW_COUNT]': counts.low,
            '[DEVICE_COUNT]': this.getUniqueDeviceCount(vulnerabilities)
        };

        Object.keys(replacements).forEach(variable => {
            const regex = new RegExp(this.escapeRegex(variable), 'g');
            processed = processed.replace(regex, replacements[variable]);
        });

        return processed;
    }

    /**
     * Calculate vulnerability counts by severity
     * @param {Array} vulnerabilities - Vulnerability array
     * @returns {Object} Counts by severity
     */
    calculateVulnerabilityCounts(vulnerabilities) {
        const counts = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };

        vulnerabilities.forEach(vuln => {
            counts.total++;
            const severity = (vuln.severity || '').toLowerCase();
            if (severity === 'critical') counts.critical++;
            else if (severity === 'high') counts.high++;
            else if (severity === 'medium') counts.medium++;
            else if (severity === 'low') counts.low++;
        });

        return counts;
    }

    /**
     * Get unique device count from vulnerabilities
     * @param {Array} vulnerabilities - Vulnerability array
     * @returns {number} Unique device count
     */
    getUniqueDeviceCount(vulnerabilities) {
        const devices = new Set();
        vulnerabilities.forEach(vuln => {
            if (vuln.hostname) devices.add(vuln.hostname);
        });
        return devices.size;
    }

    /**
     * Generate vulnerability details section
     * @param {Object} ticket - Ticket data
     * @param {Array} vulnerabilities - Vulnerability data
     * @returns {string} Formatted vulnerability details
     */
    generateVulnerabilityDetails(ticket, vulnerabilities) {
        if (!vulnerabilities || vulnerabilities.length === 0) {
            return "No vulnerabilities found for the devices in this ticket.";
        }

        // Group vulnerabilities by device
        const vulnsByDevice = {};
        vulnerabilities.forEach(vuln => {
            const hostname = vuln.hostname || 'Unknown Device';
            if (!vulnsByDevice[hostname]) {
                vulnsByDevice[hostname] = [];
            }
            vulnsByDevice[hostname].push(vuln);
        });

        let details = '';

        Object.keys(vulnsByDevice).forEach(hostname => {
            const deviceVulns = vulnsByDevice[hostname];
            details += `\\n### ${hostname}\\n\\n`;
            details += `**Vulnerabilities Found:** ${deviceVulns.length}\\n\\n`;

            // Group by severity for this device
            const severityGroups = {};
            deviceVulns.forEach(vuln => {
                const severity = (vuln.severity || 'Unknown').toLowerCase();
                if (!severityGroups[severity]) severityGroups[severity] = [];
                severityGroups[severity].push(vuln);
            });

            // Display by severity (critical first)
            const severityOrder = ['critical', 'high', 'medium', 'low', 'unknown'];
            severityOrder.forEach(severity => {
                if (severityGroups[severity]) {
                    details += `**${severity.charAt(0).toUpperCase() + severity.slice(1)} (${severityGroups[severity].length})**\\n\\n`;

                    severityGroups[severity].slice(0, 10).forEach((vuln, index) => {
                        details += `${index + 1}. ${vuln.vulnerability_name || vuln.title || 'Unknown Vulnerability'}`;
                        if (vuln.cve_id) details += ` (${vuln.cve_id})`;
                        if (vuln.cvss_score) details += ` - CVSS: ${vuln.cvss_score}`;
                        details += '\\n';
                    });

                    if (severityGroups[severity].length > 10) {
                        details += `... and ${severityGroups[severity].length - 10} more\\n`;
                    }
                    details += '\\n';
                }
            });
        });

        return details;
    }

    /**
     * Escape regex special characters
     * @param {string} string - String to escape
     * @returns {string} Escaped string
     */
    escapeRegex(string) {
        return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    /**
     * Show preview modal
     * @param {string} previewContent - Processed template content
     */
    showPreviewModal(previewContent) {
        const modalHtml = `
            <div class="modal fade" id="vulnerabilityTemplatePreviewModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-eye me-2"></i>Vulnerability Template Preview
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <pre class="terminal-content">${DOMPurify.sanitize(previewContent)}</pre>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Remove existing preview modal if any
        const existingModal = document.getElementById('vulnerabilityTemplatePreviewModal');
        if (existingModal) {
            existingModal.remove();
        }

        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Show the modal
        const previewModal = new bootstrap.Modal(document.getElementById('vulnerabilityTemplatePreviewModal'));
        previewModal.show();

        // Clean up when modal is hidden
        document.getElementById('vulnerabilityTemplatePreviewModal').addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }

    /**
     * Save template changes
     */
    async saveTemplate() {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (!editor) return;

        try {
            const templateContent = editor.value;

            // Validate before saving
            const validation = await this.validateTemplateContent(templateContent);
            if (!validation.valid) {
                this.showToast(`Cannot save: ${validation.errors.join(', ')}`, 'error');
                return;
            }

            if (!this.currentTemplate?.id) {
                await this.createDefaultTemplate();
            }

            const response = await fetch(`/api/templates/${this.currentTemplate.id}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    template_content: templateContent,
                    category: 'vulnerability',
                    template_name: 'default_vulnerability'
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            if (result.success) {
                this.currentTemplate.template_content = templateContent;
                this.cacheTemplate(this.currentTemplate);

                this.showToast('Vulnerability template saved successfully', 'success');

                // Refresh the vulnerability view if loaded
                if (window.ticketManager && window.ticketManager.loadVulnerabilityMarkdownForModal) {
                    window.ticketManager.loadVulnerabilityMarkdownForModal();
                }
            } else {
                throw new Error(result.error || 'Save failed');
            }
        } catch (error) {
            console.error('Error saving vulnerability template:', error);
            this.showToast('Failed to save vulnerability template', 'error');
        }
    }

    /**
     * Reset template to default
     */
    async resetToDefault() {
        if (!this.currentTemplate?.id) {
            await this.createDefaultTemplate();
        }

        if (!confirm('Reset template to default? This will lose all custom changes.')) {
            return;
        }

        this.isRestoring = true;
        try {
            console.log(`[VulnerabilityMarkdownEditor] Resetting template with ID: ${this.currentTemplate.id}`);
            const response = await fetch(`/api/templates/${this.currentTemplate.id}/reset`, {
                method: 'POST'
            });

            if (!response.ok) {
                console.error(`[VulnerabilityMarkdownEditor] Reset failed with status: ${response.status}`);
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            console.log(`[VulnerabilityMarkdownEditor] Reset response:`, result);
            if (!result.success) {
                throw new Error(result.error || 'Reset failed');
            }

            this.clearTemplateCache('default_vulnerability');
            await this.loadTemplateForEditing(true);
            this.showToast('Vulnerability template reset to default', 'success');
        } catch (error) {
            console.error('Error resetting vulnerability template:', error);
            this.showToast('Failed to reset vulnerability template', 'error');
        } finally {
            this.isRestoring = false;
        }
    }

    /**
     * Validate vulnerability template content against expected markers
     * @param {string} content - Template content
     * @returns {boolean} True when content appears valid for vulnerability templates
     */
    isTemplateContentValid(content) {
        if (!content) {
            return false;
        }

        const hasVulnerabilitySignature = content.includes('# Vulnerability Report');
        const containsForeignSignature = content.includes('Subject: Hexagon Work Order');

        return hasVulnerabilitySignature && !containsForeignSignature;
    }

    /**
     * Restore vulnerability template from server defaults when corruption is detected
     */
    async restoreTemplateFromServer() {
        this.isRestoring = true;
        try {
            if (this.currentTemplate?.id) {
                await fetch(`/api/templates/${this.currentTemplate.id}/reset`, { method: 'POST' });
            }
        } catch (resetError) {
            console.warn('Failed to reset vulnerability template on server:', resetError.message);
        } finally {
            this.clearTemplateCache('default_vulnerability');
            this.currentTemplate = null;
            await this.loadTemplateForEditing(true);
            this.isRestoring = false;
        }
    }

    /**
     * Cache template in localStorage
     * @param {Object} template - Template object to cache
     */
    cacheTemplate(template) {
        try {
            if (!template?.name) return;
            const cacheKey = `hextrackr_vulnerability_template_${template.name}`;
            const cacheData = {
                template,
                timestamp: Date.now(),
                expires: Date.now() + (60 * 60 * 1000),
                category: 'vulnerability'
            };
            localStorage.setItem(cacheKey, JSON.stringify(cacheData));
            console.log(`[VulnerabilityMarkdownEditor] Cached template with key: ${cacheKey}`);
        } catch (error) {
            console.warn('Failed to cache vulnerability template:', error);
        }
    }

    /**
     * Retrieve cached template from localStorage
     * @param {string} templateName - Template name
     * @returns {Object|null} Cached template or null
     */
    getCachedTemplate(templateName) {
        try {
            const cacheKey = `hextrackr_vulnerability_template_${templateName}`;
            const cached = localStorage.getItem(cacheKey);
            if (!cached) {
                console.log(`[VulnerabilityMarkdownEditor] No cached template found for key: ${cacheKey}`);
                return null;
            }

            const cacheData = JSON.parse(cached);
            if (cacheData.expires < Date.now()) {
                console.log(`[VulnerabilityMarkdownEditor] Cached template expired for key: ${cacheKey}`);
                localStorage.removeItem(cacheKey);
                return null;
            }

            console.log(`[VulnerabilityMarkdownEditor] Retrieved cached template for key: ${cacheKey}`);

            return cacheData.template;
        } catch (error) {
            console.warn('Failed to load cached vulnerability template:', error);
            return null;
        }
    }

    /**
     * Clear cached template(s)
     * @param {string|null} templateName - Optional template to clear
     */
    clearTemplateCache(templateName = null) {
        try {
            if (templateName) {
                const cacheKey = `hextrackr_vulnerability_template_${templateName}`;
                localStorage.removeItem(cacheKey);
                console.log(`[VulnerabilityMarkdownEditor] Cleared cache for key: ${cacheKey}`);
                return;
            }

            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('hextrackr_vulnerability_template_')) {
                    localStorage.removeItem(key);
                    console.log(`[VulnerabilityMarkdownEditor] Cleared cache for key: ${key}`);
                }
            });
        } catch (error) {
            console.warn('Failed to clear vulnerability template cache:', error);
        }
    }

    /**
     * Set up real-time validation
     */
    setupValidation() {
        const setupListener = () => {
            const editor = document.getElementById('vulnerabilityTemplateEditor');
            if (editor) {
                editor.addEventListener('input', () => {
                    // Debounce validation
                    clearTimeout(this.validationTimeout);
                    this.validationTimeout = setTimeout(() => {
                        this.validateTemplate();
                    }, 500);
                });
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupListener);
        } else {
            setupListener();
        }
    }

    /**
     * Validate template content in real-time
     */
    async validateTemplate() {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        const validationDiv = document.getElementById('vulnerabilityTemplateValidation');

        if (!editor || !validationDiv) return;

        const content = editor.value;
        if (!content.trim()) {
            validationDiv.innerHTML = '';
            return;
        }

        try {
            const validation = await this.validateTemplateContent(content);
            this.displayValidationResults(validation);
        } catch (error) {
            console.error('Validation error:', error);
        }
    }

    /**
     * Validate template content
     * @param {string} content - Template content to validate
     * @returns {Object} Validation result
     */
    async validateTemplateContent(content) {
        const errors = [];
        const warnings = [];

        // Basic bracket matching
        const openBrackets = (content.match(/\[/g) || []).length;
        const closeBrackets = (content.match(/\]/g) || []).length;

        if (openBrackets !== closeBrackets) {
            errors.push('Unmatched brackets detected');
        }

        // Check for empty variables
        if (content.includes('[]')) {
            errors.push('Empty variable brackets found');
        }

        // Extract variables
        const variableMatches = content.match(/\\[[A-Z_]+\\]/g) || [];
        const uniqueVariables = [...new Set(variableMatches)];
        const knownVariables = this.variables.map(v => v.name);

        // Check for unknown variables
        const unknownVariables = uniqueVariables.filter(v => !knownVariables.includes(v));
        if (unknownVariables.length > 0) {
            warnings.push(`Unknown variables: ${unknownVariables.join(', ')}`);
        }

        return {
            valid: errors.length === 0,
            errors,
            warnings,
            variables: {
                found: uniqueVariables,
                unknown: unknownVariables
            }
        };
    }

    /**
     * Display validation results
     * @param {Object} validation - Validation result
     */
    displayValidationResults(validation) {
        const validationDiv = document.getElementById('vulnerabilityTemplateValidation');
        if (!validationDiv) return;

        let html = '';

        if (validation.errors.length > 0) {
            html += `<div class="alert alert-danger alert-sm mb-2">
                <i class="fas fa-exclamation-triangle me-1"></i>
                ${validation.errors.join(', ')}
            </div>`;
        }

        if (validation.warnings.length > 0) {
            html += `<div class="alert alert-warning alert-sm mb-2">
                <i class="fas fa-exclamation-circle me-1"></i>
                ${validation.warnings.join(', ')}
            </div>`;
        }

        if (validation.valid && validation.warnings.length === 0) {
            html = `<div class="alert alert-success alert-sm mb-2">
                <i class="fas fa-check me-1"></i>
                Template is valid
            </div>`;
        }

        validationDiv.innerHTML = html;
    }

    /**
     * Set current ticket data for preview
     * @param {Object} ticketData - Current ticket data
     */
    setTicketData(ticketData) {
        this.currentTicketData = ticketData;
    }

    /**
     * Show toast notification
     * @param {string} message - Message to show
     * @param {string} type - Type of toast (success, error, warning, info)
     */
    showToast(message, type = 'info') {
        // Use existing toast system if available, otherwise fallback to console
        if (window.ticketManager && window.ticketManager.showToast) {
            window.ticketManager.showToast(message, type);
        } else {
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    }
}

// Create global instance
window.vulnerabilityMarkdownEditor = new VulnerabilityMarkdownEditor();
