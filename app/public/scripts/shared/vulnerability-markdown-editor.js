/**
 * Vulnerability Markdown Editor Module for HexTrackr v1.0.21
 *
 * Provides interactive markdown template editing functionality for vulnerability reports.
 * Features: template editing, variable substitution, preview mode, and validation.
 *
 * @fileoverview Vulnerability markdown template editor for customizing vulnerability display
 * @author HexTrackr Development Team
 * @version 1.0.21
 */

/* global fetch, bootstrap, DOMPurify */

/**
 * Vulnerability Markdown Editor Class
 * Manages the vulnerability markdown template editing interface
 */
class VulnerabilityMarkdownEditor {
    constructor() {
        this.isEditMode = false;
        this.currentTemplate = null;
        this.currentTicketData = null;
        this.validationTimeout = null;

        // Available variables for vulnerability markdown template
        this.variables = [
            { name: '[LOCATION]', description: 'Location or site name', required: true },
            { name: '[XT_NUMBER]', description: 'Internal XT number', required: true },
            { name: '[HEXAGON_TICKET]', description: 'Hexagon ticket number', required: false },
            { name: '[SERVICENOW_TICKET]', description: 'ServiceNow ticket number', required: false },
            { name: '[GENERATED_TIME]', description: 'Report generation timestamp', required: false },
            { name: '[VULNERABILITY_DETAILS]', description: 'Dynamic vulnerability data per device', required: true },
            { name: '[TOTAL_VULNERABILITIES]', description: 'Total vulnerability count', required: false },
            { name: '[CRITICAL_COUNT]', description: 'Critical vulnerabilities count', required: false },
            { name: '[HIGH_COUNT]', description: 'High vulnerabilities count', required: false },
            { name: '[MEDIUM_COUNT]', description: 'Medium vulnerabilities count', required: false },
            { name: '[LOW_COUNT]', description: 'Low vulnerabilities count', required: false },
            { name: '[DEVICE_COUNT]', description: 'Number of devices with vulnerabilities', required: false }
        ];

        this.init();
    }

    /**
     * Initialize the vulnerability markdown editor
     */
    init() {
        // Populate variable reference panel when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.populateVariablePanel());
        } else {
            this.populateVariablePanel();
        }

        // Set up real-time validation
        this.setupValidation();
    }

    /**
     * Toggle between view and edit modes
     */
    async toggleEditMode() {
        const viewMode = document.getElementById('vulnerabilityViewMode');
        const editMode = document.getElementById('vulnerabilityEditMode');

        if (!this.isEditMode) {
            // Entering edit mode
            try {
                await this.loadTemplateForEditing();

                viewMode.style.display = 'none';
                editMode.style.display = 'block';
                this.isEditMode = true;

                // Focus on editor
                const editor = document.getElementById('vulnerabilityTemplateEditor');
                if (editor) {
                    editor.focus();
                }

                // Ensure variable panel is populated
                this.populateVariablePanel();

                this.showToast('Vulnerability template edit mode enabled', 'info');
            } catch (error) {
                console.error('Error entering vulnerability template edit mode:', error);
                this.showToast('Failed to enter vulnerability template edit mode', 'error');
            }
        } else {
            // Exiting edit mode
            viewMode.style.display = 'block';
            editMode.style.display = 'none';
            this.isEditMode = false;

            this.showToast('Vulnerability template edit mode disabled', 'info');
        }
    }

    /**
     * Load template for editing
     */
    async loadTemplateForEditing() {
        try {
            const response = await fetch('/api/templates/by-name/default_vulnerability');
            if (!response.ok) {
                // If template doesn't exist, use fallback
                console.warn('No vulnerability template found, using default');
                this.createDefaultTemplate();
                return;
            }

            const result = await response.json();
            if (result.success) {
                this.currentTemplate = result.data;

                // Load template content into editor
                const editor = document.getElementById('vulnerabilityTemplateEditor');
                if (editor) {
                    editor.value = this.currentTemplate.template_content;

                    // Trigger validation
                    this.validateTemplate();
                }
            } else {
                throw new Error(result.error || 'Failed to load vulnerability template');
            }
        } catch (error) {
            console.error('Error loading vulnerability template:', error);
            // Use default template
            this.createDefaultTemplate();
        }
    }

    /**
     * Create default template from hardcoded version
     */
    createDefaultTemplate() {
        const defaultContent = `# Vulnerability Report for [LOCATION]

**XT#:** [XT_NUMBER]
**Hexagon#:** [HEXAGON_TICKET]
**ServiceNow#:** [SERVICENOW_TICKET]

Generated: [GENERATED_TIME]

## Summary

**Total Vulnerabilities:** [TOTAL_VULNERABILITIES]
- **Critical:** [CRITICAL_COUNT]
- **High:** [HIGH_COUNT]
- **Medium:** [MEDIUM_COUNT]
- **Low:** [LOW_COUNT]

**Devices Affected:** [DEVICE_COUNT]

## Vulnerability Details

[VULNERABILITY_DETAILS]

---

**Report End**

*This report was generated automatically from vulnerability scan data. Please review all findings and coordinate with the security team for remediation planning.*`;

        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (editor) {
            editor.value = defaultContent;
            this.validateTemplate();
        }

        this.currentTemplate = {
            id: null,
            name: 'default_vulnerability',
            template_content: defaultContent
        };
    }

    /**
     * Populate the variable reference panel
     */
    populateVariablePanel() {
        const panel = document.getElementById('vulnerabilityVariablePanel');
        if (!panel) return;

        panel.innerHTML = '';

        this.variables.forEach(variable => {
            const variableElement = document.createElement('div');
            variableElement.className = 'variable-item mb-2';

            variableElement.innerHTML = `
                <span class="variable-tag ${variable.required ? 'required' : 'optional'}"
                      onclick="vulnerabilityMarkdownEditor.insertVariable('${variable.name}')"
                      title="${variable.description}${variable.required ? ' (Required)' : ' (Optional)'}">
                    ${variable.name}
                </span>
                <small class="text-muted d-block">${variable.description}</small>
            `;

            panel.appendChild(variableElement);
        });
    }

    /**
     * Insert variable at cursor position
     * @param {string} variable - Variable to insert
     */
    insertVariable(variable) {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (!editor) return;

        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const text = editor.value;

        // Insert variable at cursor position
        const newText = text.substring(0, start) + variable + text.substring(end);
        editor.value = newText;

        // Set cursor position after inserted variable
        const newPosition = start + variable.length;
        editor.setSelectionRange(newPosition, newPosition);
        editor.focus();

        // Trigger validation
        this.validateTemplate();

        this.showToast(`Inserted ${variable}`, 'success');
    }

    /**
     * Preview template with current ticket data
     */
    async previewTemplate() {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (!editor || !this.currentTicketData) {
            this.showToast('No ticket data available for preview', 'warning');
            return;
        }

        try {
            const templateContent = editor.value;

            // Fetch vulnerability data for preview
            const ticketId = document.getElementById("viewTicketModal").getAttribute("data-ticket-id");
            const ticket = window.ticketManager?.getTicketById(ticketId);

            if (ticket?.devices && ticket.devices.length > 0) {
                const vulnerabilities = await window.ticketManager.fetchVulnerabilitiesForDevices(ticket.devices);
                const processedContent = this.processTemplate(templateContent, ticket, vulnerabilities);
                this.showPreviewModal(processedContent);
            } else {
                const processedContent = this.processTemplate(templateContent, this.currentTicketData, []);
                this.showPreviewModal(processedContent);
            }
        } catch (error) {
            console.error('Error previewing vulnerability template:', error);
            this.showToast('Failed to generate preview', 'error');
        }
    }

    /**
     * Process template with ticket and vulnerability data
     * @param {string} template - Template content
     * @param {Object} ticket - Ticket data
     * @param {Array} vulnerabilities - Vulnerability data
     * @returns {string} Processed content
     */
    processTemplate(template, ticket, vulnerabilities = []) {
        let processed = template;

        // Calculate vulnerability counts
        const counts = this.calculateVulnerabilityCounts(vulnerabilities);

        // Generate vulnerability details
        const vulnerabilityDetails = this.generateVulnerabilityDetails(ticket, vulnerabilities);

        // Replace variables with actual data
        const replacements = {
            '[LOCATION]': ticket.location || ticket.site || 'Unknown Location',
            '[XT_NUMBER]': ticket.xtNumber || ticket.xt_number || 'N/A',
            '[HEXAGON_TICKET]': ticket.hexagonTicket || 'N/A',
            '[SERVICENOW_TICKET]': ticket.serviceNowTicket || 'N/A',
            '[GENERATED_TIME]': `${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
            '[VULNERABILITY_DETAILS]': vulnerabilityDetails,
            '[TOTAL_VULNERABILITIES]': counts.total,
            '[CRITICAL_COUNT]': counts.critical,
            '[HIGH_COUNT]': counts.high,
            '[MEDIUM_COUNT]': counts.medium,
            '[LOW_COUNT]': counts.low,
            '[DEVICE_COUNT]': this.getUniqueDeviceCount(vulnerabilities)
        };

        Object.keys(replacements).forEach(variable => {
            const regex = new RegExp(this.escapeRegex(variable), 'g');
            processed = processed.replace(regex, replacements[variable]);
        });

        return processed;
    }

    /**
     * Calculate vulnerability counts by severity
     * @param {Array} vulnerabilities - Vulnerability array
     * @returns {Object} Counts by severity
     */
    calculateVulnerabilityCounts(vulnerabilities) {
        const counts = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };

        vulnerabilities.forEach(vuln => {
            counts.total++;
            const severity = (vuln.severity || '').toLowerCase();
            if (severity === 'critical') counts.critical++;
            else if (severity === 'high') counts.high++;
            else if (severity === 'medium') counts.medium++;
            else if (severity === 'low') counts.low++;
        });

        return counts;
    }

    /**
     * Get unique device count from vulnerabilities
     * @param {Array} vulnerabilities - Vulnerability array
     * @returns {number} Unique device count
     */
    getUniqueDeviceCount(vulnerabilities) {
        const devices = new Set();
        vulnerabilities.forEach(vuln => {
            if (vuln.hostname) devices.add(vuln.hostname);
        });
        return devices.size;
    }

    /**
     * Generate vulnerability details section
     * @param {Object} ticket - Ticket data
     * @param {Array} vulnerabilities - Vulnerability data
     * @returns {string} Formatted vulnerability details
     */
    generateVulnerabilityDetails(ticket, vulnerabilities) {
        if (!vulnerabilities || vulnerabilities.length === 0) {
            return "No vulnerabilities found for the devices in this ticket.";
        }

        // Group vulnerabilities by device
        const vulnsByDevice = {};
        vulnerabilities.forEach(vuln => {
            const hostname = vuln.hostname || 'Unknown Device';
            if (!vulnsByDevice[hostname]) {
                vulnsByDevice[hostname] = [];
            }
            vulnsByDevice[hostname].push(vuln);
        });

        let details = '';

        Object.keys(vulnsByDevice).forEach(hostname => {
            const deviceVulns = vulnsByDevice[hostname];
            details += `\\n### ${hostname}\\n\\n`;
            details += `**Vulnerabilities Found:** ${deviceVulns.length}\\n\\n`;

            // Group by severity for this device
            const severityGroups = {};
            deviceVulns.forEach(vuln => {
                const severity = (vuln.severity || 'Unknown').toLowerCase();
                if (!severityGroups[severity]) severityGroups[severity] = [];
                severityGroups[severity].push(vuln);
            });

            // Display by severity (critical first)
            const severityOrder = ['critical', 'high', 'medium', 'low', 'unknown'];
            severityOrder.forEach(severity => {
                if (severityGroups[severity]) {
                    details += `**${severity.charAt(0).toUpperCase() + severity.slice(1)} (${severityGroups[severity].length})**\\n\\n`;

                    severityGroups[severity].slice(0, 10).forEach((vuln, index) => {
                        details += `${index + 1}. ${vuln.vulnerability_name || vuln.title || 'Unknown Vulnerability'}`;
                        if (vuln.cve_id) details += ` (${vuln.cve_id})`;
                        if (vuln.cvss_score) details += ` - CVSS: ${vuln.cvss_score}`;
                        details += '\\n';
                    });

                    if (severityGroups[severity].length > 10) {
                        details += `... and ${severityGroups[severity].length - 10} more\\n`;
                    }
                    details += '\\n';
                }
            });
        });

        return details;
    }

    /**
     * Escape regex special characters
     * @param {string} string - String to escape
     * @returns {string} Escaped string
     */
    escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');
    }

    /**
     * Show preview modal
     * @param {string} previewContent - Processed template content
     */
    showPreviewModal(previewContent) {
        const modalHtml = `
            <div class="modal fade" id="vulnerabilityTemplatePreviewModal" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-eye me-2"></i>Vulnerability Template Preview
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <pre class="terminal-content">${DOMPurify.sanitize(previewContent)}</pre>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Remove existing preview modal if any
        const existingModal = document.getElementById('vulnerabilityTemplatePreviewModal');
        if (existingModal) {
            existingModal.remove();
        }

        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Show the modal
        const previewModal = new bootstrap.Modal(document.getElementById('vulnerabilityTemplatePreviewModal'));
        previewModal.show();

        // Clean up when modal is hidden
        document.getElementById('vulnerabilityTemplatePreviewModal').addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }

    /**
     * Save template changes
     */
    async saveTemplate() {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        if (!editor) return;

        try {
            const templateContent = editor.value;

            // Validate before saving
            const validation = await this.validateTemplateContent(templateContent);
            if (!validation.valid) {
                this.showToast(`Cannot save: ${validation.errors.join(', ')}`, 'error');
                return;
            }

            // Create or update template
            const templateData = {
                name: 'default_vulnerability',
                description: 'Default vulnerability report template',
                template_content: templateContent,
                default_content: templateContent,
                variables: JSON.stringify(this.variables),
                category: 'vulnerability'
            };

            const url = this.currentTemplate?.id ?
                `/api/templates/${this.currentTemplate.id}` :
                '/api/templates';
            const method = this.currentTemplate?.id ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(templateData)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            if (result.success) {
                this.showToast('Vulnerability template saved successfully', 'success');

                // Update current template
                if (!this.currentTemplate?.id) {
                    this.currentTemplate = result.data;
                } else {
                    this.currentTemplate.template_content = templateContent;
                }

                // Refresh the vulnerability view if loaded
                if (window.ticketManager && window.ticketManager.loadVulnerabilityMarkdownForModal) {
                    window.ticketManager.loadVulnerabilityMarkdownForModal();
                }
            } else {
                throw new Error(result.error || 'Save failed');
            }
        } catch (error) {
            console.error('Error saving vulnerability template:', error);
            this.showToast('Failed to save vulnerability template', 'error');
        }
    }

    /**
     * Reset template to default
     */
    async resetToDefault() {
        if (!confirm('Reset template to default? This will lose all custom changes.')) {
            return;
        }

        try {
            this.createDefaultTemplate();
            this.showToast('Vulnerability template reset to default', 'success');
        } catch (error) {
            console.error('Error resetting vulnerability template:', error);
            this.showToast('Failed to reset vulnerability template', 'error');
        }
    }

    /**
     * Set up real-time validation
     */
    setupValidation() {
        const setupListener = () => {
            const editor = document.getElementById('vulnerabilityTemplateEditor');
            if (editor) {
                editor.addEventListener('input', () => {
                    // Debounce validation
                    clearTimeout(this.validationTimeout);
                    this.validationTimeout = setTimeout(() => {
                        this.validateTemplate();
                    }, 500);
                });
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupListener);
        } else {
            setupListener();
        }
    }

    /**
     * Validate template content in real-time
     */
    async validateTemplate() {
        const editor = document.getElementById('vulnerabilityTemplateEditor');
        const validationDiv = document.getElementById('vulnerabilityTemplateValidation');

        if (!editor || !validationDiv) return;

        const content = editor.value;
        if (!content.trim()) {
            validationDiv.innerHTML = '';
            return;
        }

        try {
            const validation = await this.validateTemplateContent(content);
            this.displayValidationResults(validation);
        } catch (error) {
            console.error('Validation error:', error);
        }
    }

    /**
     * Validate template content
     * @param {string} content - Template content to validate
     * @returns {Object} Validation result
     */
    async validateTemplateContent(content) {
        const errors = [];
        const warnings = [];

        // Basic bracket matching
        const openBrackets = (content.match(/\[/g) || []).length;
        const closeBrackets = (content.match(/\]/g) || []).length;

        if (openBrackets !== closeBrackets) {
            errors.push('Unmatched brackets detected');
        }

        // Check for empty variables
        if (content.includes('[]')) {
            errors.push('Empty variable brackets found');
        }

        // Extract variables
        const variableMatches = content.match(/\\[[A-Z_]+\\]/g) || [];
        const uniqueVariables = [...new Set(variableMatches)];
        const knownVariables = this.variables.map(v => v.name);

        // Check for unknown variables
        const unknownVariables = uniqueVariables.filter(v => !knownVariables.includes(v));
        if (unknownVariables.length > 0) {
            warnings.push(`Unknown variables: ${unknownVariables.join(', ')}`);
        }

        return {
            valid: errors.length === 0,
            errors,
            warnings,
            variables: {
                found: uniqueVariables,
                unknown: unknownVariables
            }
        };
    }

    /**
     * Display validation results
     * @param {Object} validation - Validation result
     */
    displayValidationResults(validation) {
        const validationDiv = document.getElementById('vulnerabilityTemplateValidation');
        if (!validationDiv) return;

        let html = '';

        if (validation.errors.length > 0) {
            html += `<div class="alert alert-danger alert-sm mb-2">
                <i class="fas fa-exclamation-triangle me-1"></i>
                ${validation.errors.join(', ')}
            </div>`;
        }

        if (validation.warnings.length > 0) {
            html += `<div class="alert alert-warning alert-sm mb-2">
                <i class="fas fa-exclamation-circle me-1"></i>
                ${validation.warnings.join(', ')}
            </div>`;
        }

        if (validation.valid && validation.warnings.length === 0) {
            html = `<div class="alert alert-success alert-sm mb-2">
                <i class="fas fa-check me-1"></i>
                Template is valid
            </div>`;
        }

        validationDiv.innerHTML = html;
    }

    /**
     * Set current ticket data for preview
     * @param {Object} ticketData - Current ticket data
     */
    setTicketData(ticketData) {
        this.currentTicketData = ticketData;
    }

    /**
     * Show toast notification
     * @param {string} message - Message to show
     * @param {string} type - Type of toast (success, error, warning, info)
     */
    showToast(message, type = 'info') {
        // Use existing toast system if available, otherwise fallback to console
        if (window.ticketManager && window.ticketManager.showToast) {
            window.ticketManager.showToast(message, type);
        } else {
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    }
}

// Create global instance
window.vulnerabilityMarkdownEditor = new VulnerabilityMarkdownEditor();