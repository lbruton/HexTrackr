/**
 * @fileoverview VulnerabilityStatisticsManager
 * Manages vulnerability statistics, trends, and chart data processing
 */

/* global CustomEvent, module, EventTarget, console, document, setTimeout, authState */

class VulnerabilityStatisticsManager extends EventTarget {
    constructor(dataManager) {
        super();
        this.dataManager = dataManager;
        this.trends = {};
        this.currentMetricType = "vpr";
    }

    /**
     * Updates statistics display in the UI
     * HEX-117: Modified to use cached backend endpoint for performance
     * HEX-144: Sets up VPR export shortcut after stats update
     * HEX-156: Added vendor parameter for vendor-filtered statistics
     * @param {string|null} vendor - Optional vendor filter ('CISCO', 'Palo Alto', 'Other', or null for all)
     */
    async updateStatisticsDisplay(vendor = null) {
        // HEX-156: Build vendor-aware API URL
        const url = vendor
            ? `/api/vulnerabilities/stats?vendor=${encodeURIComponent(vendor)}`
            : "/api/vulnerabilities/stats";

        let statistics;
        try {
            const response = await authState.authenticatedFetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            statistics = await response.json();

            const vendorLabel = vendor ? ` (${vendor})` : "";
            console.log(`✅ Stats loaded from cached backend endpoint${vendorLabel}`);
        } catch (error) {
            console.error("Failed to fetch stats from backend:", error);
            // No fallback for vendor filtering - show error to user (Task 3.2)
            throw error;
        }

        if (!statistics) {
            console.warn("Statistics data not available");
            return;
        }

        const trendsSource = (this.trends && Object.keys(this.trends).length > 0)
            ? this.trends
            : (this.dataManager && this.dataManager.getTrends ? this.dataManager.getTrends() : {});

        // HEX-183: Collect all trend update promises to await them together
        const trendUpdatePromises = [];

        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            const stat = statistics[severity];
            if (stat) {
                const countEl = document.getElementById(`${severity}Count`);
                const vprEl = document.getElementById(`${severity}VPR`);

                if (countEl) {
                    countEl.textContent = stat.count;
                }

                if (vprEl) {
                    vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
                }

                const totalVprEl = document.getElementById(`${severity}TotalVPR`);
                const avgVprEl = document.getElementById(`${severity}AvgVPR`);

                if (totalVprEl) {
                    totalVprEl.textContent = stat.total_vpr.toFixed(1);
                }

                if (avgVprEl) {
                    const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                    avgVprEl.textContent = `${average} avg`;
                }

                const legacyCountEl = document.getElementById(`${severity}-count`);
                const legacyVprEl = document.getElementById(`${severity}-vpr`);

                if (legacyCountEl) {
                    legacyCountEl.textContent = stat.count;
                }

                if (legacyVprEl) {
                    legacyVprEl.textContent = stat.total_vpr.toFixed(1);
                }

                // HEX-183: Queue trend update promise
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
                const trendBucket = trendsSource && trendsSource[severityKey] ? trendsSource[severityKey] : null;

                trendUpdatePromises.push(
                    this.updateTrendDisplay(severity, stat, trendBucket, vendor).catch(error => {
                        console.error(`Failed to update trend for ${severity}:`, error);
                    })
                );
            }
        });

        // HEX-183: Wait for all trend updates to complete before proceeding
        // This prevents race conditions when rapidly toggling vendor filters
        await Promise.all(trendUpdatePromises);
        
        const totalVulns = Object.values(statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }

        // HEX-144: Setup VPR export shortcut after stats are rendered
        this.setupVprExportShortcut();

        this.dispatchEvent(new CustomEvent("statisticsDisplayUpdated", {
            detail: { statistics, totalVulns }
        }));
    }

    /**
     * Updates the trend display for a specific severity bucket
     * HEX-183: Modified to support vendor-filtered trends
     * @param {string} severity - Severity level (critical, high, medium, low, info)
     * @param {Object} currentStat - Current statistics for this severity
     * @param {Object} trendBucket - Trend data bucket for this severity (may be null)
     * @param {string|null} vendorFilter - Optional vendor filter ('CISCO', 'Palo Alto', 'Other')
     */
    async updateTrendDisplay(severity, currentStat, trendBucket, vendorFilter = null) {
        const trendEl = document.getElementById(`${severity}Trend`);
        if (!trendEl) return;

        let trendData = trendBucket ? trendBucket.trend : null;

        // HEX-183: Fetch vendor-filtered trend data if vendor filter is active
        if (vendorFilter) {
            try {
                const vendorTrends = await this._fetchVendorTrends(vendorFilter);
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);

                if (vendorTrends && vendorTrends[severityKey]) {
                    // Replace trend data with vendor-filtered version
                    trendData = vendorTrends[severityKey].trend;
                }
            } catch (error) {
                console.error(`Failed to fetch vendor trends for ${severity}:`, error);
                // Fall back to global trends on error
            }
        }

        if (!trendData) return;

        const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
        const current = this.currentMetricType === "vpr" ? currentStat.total_vpr : currentStat.count;
        const previous = current - change;

        const iconEl = trendEl.querySelector("i");
        const badgeEl = trendEl.querySelector(".trend-value");

        if (!iconEl || !badgeEl) return;

        // HEX-183: Handle first upload edge case (no previous data)
        // If previous is 0 or very close to 0, show "N/A" instead of calculating percentage
        if (previous === 0 || Math.abs(previous) < 0.01) {
            iconEl.className = "ti ti-minus fs-3";
            badgeEl.textContent = "N/A";
            return;
        }

        // Calculate percentage change
        const percentage = Math.abs((change / previous) * 100);
        const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";

        // Cap percentage at reasonable maximum (999.9%) to prevent display overflow
        const displayPercentage = Math.min(percentage, 999.9);

        if (direction === "up") {
            iconEl.className = "ti ti-trending-up fs-3";
            badgeEl.textContent = `+${displayPercentage.toFixed(1)}%`;
        } else if (direction === "down") {
            iconEl.className = "ti ti-trending-down fs-3";
            badgeEl.textContent = `-${displayPercentage.toFixed(1)}%`;
        } else {
            iconEl.className = "ti ti-minus fs-3";
            badgeEl.textContent = "0%";
        }
    }

    /**
     * Fetches vendor-filtered trend data from backend API
     * HEX-183: Helper method to get vendor-specific trends
     * @param {string} vendorFilter - Vendor filter ('CISCO', 'Palo Alto', 'Other')
     * @returns {Promise<Object>} Trends data object with severity buckets
     * @private
     */
    async _fetchVendorTrends(vendorFilter) {
        const url = `/api/vulnerabilities/trends?vendor=${encodeURIComponent(vendorFilter)}`;
        const response = await authState.authenticatedFetch(url);

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const trends = await response.json();

        // Convert array format to object format matching this.trends structure
        // Backend returns: [{date, Critical: {}, High: {}, ...}, ...]
        // We need: {Critical: {current: {}, trend: {}}, High: {}, ...}

        if (!Array.isArray(trends) || trends.length === 0) {
            return {};
        }

        // HEX-183: Handle single upload case (no previous data to compare)
        if (trends.length === 1) {
            console.log("Only 1 data point - no trend comparison available");
            return {}; // Return empty, will trigger "N/A" display
        }

        const currentWeek = trends[trends.length - 1];
        const previousWeek = trends[trends.length - 2]; // Safe now due to length check above

        const result = {};
        const severities = ["Critical", "High", "Medium", "Low", "Info"];

        severities.forEach(severity => {
            const current = currentWeek[severity];
            const previous = previousWeek ? previousWeek[severity] : null;

            if (current) {
                const vprChange = previous ? (current.total_vpr - previous.total_vpr) : 0;
                const countChange = previous ? (current.count - previous.count) : 0;

                result[severity] = {
                    current: current,
                    trend: {
                        direction: vprChange > 0 ? "up" : vprChange < 0 ? "down" : "stable",
                        vpr_change: vprChange,
                        count_change: countChange
                    }
                };
            }
        });

        return result;
    }

    /**
     * Calculates trend between two values
     */
    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }

        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }

        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    /**
     * Updates chart with current metric type and data
     * HEX-117: Modified to use cached backend trends endpoint
     * HEX-156: Added vendor parameter for vendor-filtered trends
     * @param {Object} chart - ApexCharts instance to update
     * @param {boolean} bustCache - If true, append timestamp to bypass cache
     * @param {string|null} vendor - Optional vendor filter ('CISCO', 'Palo Alto', 'Other', or null for all)
     */
    async updateChart(chart, bustCache = false, vendor = null) {
        if (!chart) {
            return;
        }

        // HEX-156: Fetch trends from vendor-aware backend endpoint
        let historicalData;
        try {
            // Build vendor-aware API URL
            const vendorParam = vendor ? `vendor=${encodeURIComponent(vendor)}` : "";
            const cacheBustParam = bustCache ? `_t=${Date.now()}` : "";
            const params = [vendorParam, cacheBustParam].filter(p => p).join("&");
            const trendsUrl = `/api/vulnerabilities/trends${params ? "?" + params : ""}`;

            const response = await authState.authenticatedFetch(trendsUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            historicalData = await response.json();

            const vendorLabel = vendor ? ` (${vendor})` : "";
            console.log(`✅ Chart trends loaded from ${bustCache ? "fresh" : "cached"} backend endpoint${vendorLabel}`);
        } catch (error) {
            console.error("Failed to fetch trends from backend:", error);
            throw error;
        }

        if (!historicalData || historicalData.length === 0) {
            return;
        }

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        this.currentMetricType = metricType;

        const extendedData = this.dataManager.extendTimelineData(historicalData);
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date).getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        chart.updateSeries(series);

        setTimeout(() => {
            if (chart && chart.resetSeries) {
                chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date).toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        if (value && value > 0) {
                            const color = colors[index];
                            tooltipContent += `
                                <div class="tooltip-row">
                                    <span class="color-indicator" style="background-color: ${color}"></span>
                                    <span class="severity-name">${severity}:</span>
                                    <span class="severity-value">${metricType === "vpr" ? value.toFixed(2) : value.toFixed(0)}</span>
                                </div>`;
                        }
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        this.dispatchEvent(new CustomEvent("chartUpdated", {
            detail: { series, metricType, extendedData }
        }));
    }

    /**
     * Get current metric type
     */
    getCurrentMetricType() {
        return this.currentMetricType;
    }

    /**
     * Set current metric type
     */
    setCurrentMetricType(metricType) {
        this.currentMetricType = metricType;
        this.dispatchEvent(new CustomEvent("metricTypeChanged", {
            detail: { metricType }
        }));
    }

    /**
     * Get current trends data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Set trends data
     */
    setTrends(trends) {
        this.trends = trends;
        this.dispatchEvent(new CustomEvent("trendsSet", {
            detail: { trends }
        }));
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Simple instant toggle for all 4 severity levels
     */
    flipStatCards() {
        const severities = ["critical", "high", "medium", "low"];

        severities.forEach(severity => {
            const statCard = document.querySelector(`.stat-card-enhanced[data-severity="${severity}"]`);
            if (!statCard) {return;}

            const cardFront = statCard.querySelector(".card-front");
            const cardBack = statCard.querySelector(".card-back");

            if (!cardFront || !cardBack) {return;}

            // Simple instant toggle - no animation
            if (cardFront.style.display !== "none") {
                cardFront.style.display = "none";
                cardBack.style.display = "block";
            } else {
                cardFront.style.display = "block";
                cardBack.style.display = "none";
            }
        });

        // Dispatch event for tracking/testing
        this.dispatchEvent(new CustomEvent("cardsFlipped", {
            detail: { timestamp: new Date().toISOString() }
        }));
    }

    /**
     * Setup keyboard shortcut for VPR weekly summary export (HEX-144)
     * Attaches Cmd+Shift+Click (Mac) or Ctrl+Shift+Click (Windows) listeners to all 4 VPR cards
     * Hidden power user feature for quick CSV export of weekly VPR totals
     *
     * @returns {void}
     *
     * @example
     * // Called after statistics update to ensure cards are rendered
     * statisticsManager.setupVprExportShortcut();
     */
    setupVprExportShortcut() {
        // Security check: Only enable for authenticated users
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("VPR export shortcut not enabled - user not authenticated");
            return;
        }

        const cards = document.querySelectorAll(".stat-card-enhanced[data-severity]");

        cards.forEach(card => {
            // Remove existing listener if any (prevent duplicates)
            card.removeEventListener("click", this._handleCardClick);

            // Bind context and store reference for removal
            this._handleCardClick = this._handleCardClick.bind(this);

            // Add event listener
            card.addEventListener("click", this._handleCardClick);
        });

        console.log("✅ VPR export shortcut enabled (Cmd+Shift+Click or Ctrl+Shift+Click)");
    }

    /**
     * Handle card click event for export shortcut (HEX-144)
     * Internal method bound to card click events
     *
     * @private
     * @param {MouseEvent} event - Click event
     * @returns {void}
     */
    _handleCardClick(event) {
        // Check for Cmd+Shift (Mac) or Ctrl+Shift (Windows)
        if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            event.preventDefault();
            event.stopPropagation(); // Prevent card flip
            this.exportVprWeeklySummary();
        }
    }

    /**
     * Aggregate VPR totals by vendor category from backend trends API
     * Fetches vendor-filtered trends to get BOTH current totals AND historical data
     * for accurate percentage change calculations (uses vulnerability_snapshots table)
     *
     * CSV EXPORT FIX: Previously used stats endpoint which only provided current totals,
     * forcing CSV export to use "All Vendors" percentage changes. Now fetches trends
     * to calculate vendor-specific percentage changes for accurate historical data.
     *
     * @param {string} vendorFilter - 'CISCO', 'Palo Alto', or 'Other'
     * @returns {Promise<Object>} Object with current totals and percentage changes:
     *   {
     *     current: {critical, high, medium, low},
     *     percentChanges: {critical, high, medium, low}
     *   }
     * @private
     */
    async _aggregateVprByVendor(vendorFilter) {
        try {
            // Fetch trends from backend API (not stats - we need historical data!)
            const url = `/api/vulnerabilities/trends?vendor=${encodeURIComponent(vendorFilter)}`;
            const response = await authState.authenticatedFetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const trends = await response.json();

            // Validate trends data
            if (!Array.isArray(trends) || trends.length === 0) {
                console.warn(`No trends data available for ${vendorFilter}`);
                return {
                    current: { critical: 0, high: 0, medium: 0, low: 0 },
                    currentCounts: { critical: 0, high: 0, medium: 0, low: 0 },
                    percentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                    countPercentChanges: { critical: 0, high: 0, medium: 0, low: 0 }
                };
            }

            // Get most recent (current week) and second most recent (previous week) data points
            const currentWeek = trends[trends.length - 1];
            const previousWeek = trends.length >= 2 ? trends[trends.length - 2] : null;

            // Extract current totals (both VPR and counts)
            const currentTotals = {
                critical: currentWeek.Critical?.total_vpr || 0,
                high: currentWeek.High?.total_vpr || 0,
                medium: currentWeek.Medium?.total_vpr || 0,
                low: currentWeek.Low?.total_vpr || 0
            };

            const currentCounts = {
                critical: currentWeek.Critical?.count || 0,
                high: currentWeek.High?.count || 0,
                medium: currentWeek.Medium?.count || 0,
                low: currentWeek.Low?.count || 0
            };

            // Calculate percentage changes for both VPR and counts
            const percentChanges = {};
            const countPercentChanges = {};
            const severities = ["critical", "high", "medium", "low"];

            severities.forEach(severity => {
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1); // "critical" -> "Critical"

                // VPR percentage changes
                const currentVpr = currentTotals[severity];
                const previousVpr = previousWeek ? (previousWeek[severityKey]?.total_vpr || 0) : 0;

                if (previousVpr === 0) {
                    percentChanges[severity] = currentVpr > 0 ? 100 : 0;
                } else {
                    percentChanges[severity] = ((currentVpr - previousVpr) / previousVpr) * 100;
                }

                // Count percentage changes
                const currentCount = currentCounts[severity];
                const previousCount = previousWeek ? (previousWeek[severityKey]?.count || 0) : 0;

                if (previousCount === 0) {
                    countPercentChanges[severity] = currentCount > 0 ? 100 : 0;
                } else {
                    countPercentChanges[severity] = ((currentCount - previousCount) / previousCount) * 100;
                }
            });

            // Validation logging
            console.log(`[Vendor Aggregation] ${vendorFilter}:`, {
                source: "backend trends API (vulnerability_snapshots)",
                currentTotals: currentTotals,
                currentCounts: currentCounts,
                percentChanges: percentChanges,
                countPercentChanges: countPercentChanges,
                dates: {
                    current: currentWeek.date,
                    previous: previousWeek?.date || "N/A"
                }
            });

            return {
                current: currentTotals,
                currentCounts: currentCounts,
                percentChanges: percentChanges,
                countPercentChanges: countPercentChanges
            };
        } catch (error) {
            console.error(`Failed to fetch ${vendorFilter} trends from backend:`, error);

            // Return zeros on error (CSV export should not fail silently)
            return {
                current: { critical: 0, high: 0, medium: 0, low: 0 },
                currentCounts: { critical: 0, high: 0, medium: 0, low: 0 },
                percentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                countPercentChanges: { critical: 0, high: 0, medium: 0, low: 0 }
            };
        }
    }

    /**
     * Format vendor VPR totals into CSV table rows (PREV WEEK, THIS WEEK, CHANGE)
     * @param {Object} currentTotals - Current period VPR totals by severity
     * @param {Object} percentChanges - Percentage changes from trend badges
     * @returns {string} Three CSV rows with vendor table data
     * @private
     */
    _formatVendorTable(currentTotals, percentChanges) {
        const severities = ["critical", "high", "medium", "low"];

        // Calculate previous week values using reverse percentage formula
        const prevTotals = {};
        severities.forEach(severity => {
            const current = currentTotals[severity] || 0;
            const pctChange = percentChanges[severity] || 0;
            prevTotals[severity] = current / (1 + (pctChange / 100));
        });

        // Calculate totals
        const currentTotal = severities.reduce((sum, s) => sum + (currentTotals[s] || 0), 0);
        const prevTotal = severities.reduce((sum, s) => sum + (prevTotals[s] || 0), 0);
        const changeTotal = currentTotal - prevTotal;

        // Format as CSV rows
        const prevRow = `PREV WEEK,${severities.map(s => prevTotals[s].toFixed(1)).join(",")},${prevTotal.toFixed(1)}`;
        const currentRow = `THIS WEEK,${severities.map(s => currentTotals[s].toFixed(1)).join(",")},${currentTotal.toFixed(1)}`;
        const changeRow = `CHANGE,${severities.map(s => ((currentTotals[s] || 0) - prevTotals[s]).toFixed(1)).join(",")},${changeTotal.toFixed(1)}`;

        return `${prevRow}\n${currentRow}\n${changeRow}`;
    }

    /**
     * Export VPR weekly summary to CSV with vendor breakdown (HEX-144, HEX-149)
     * Extracts current VPR values and percentage changes from stat cards,
     * calculates previous week values, and generates 4-table CSV download:
     * 1. Overall VPR Totals (all devices)
     * 2. CISCO Devices (vendor-filtered)
     * 3. Palo Alto Devices (vendor-filtered)
     * 4. Other Devices (remaining/unmatched)
     *
     * CSV Format (4 tables separated by blank lines):
     * OVERALL VPR TOTALS
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * PREV WEEK,148.0,23222.0,18689.9,1484.9,43544.8
     * THIS WEEK,203.2,23216.7,24452.7,1483.9,49356.5
     * CHANGE,55.2,-5.3,5762.8,-1.0,5811.7
     *
     * CISCO DEVICES
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * ... (vendor-specific rows)
     *
     * @returns {void}
     *
     * @example
     * statisticsManager.exportVprWeeklySummary();
     * // Downloads: vpr-vendor-breakdown-2025-10-07.csv
     */
    async exportVprWeeklySummary() {
        // Security check
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("Export aborted - user not authenticated");
            return;
        }

        const severities = ["critical", "high", "medium", "low"];

        // Extract overall VPR totals and counts from DOM stat cards
        const overallTotals = {};
        const overallCounts = {};
        const percentChanges = {};

        severities.forEach(severity => {
            const totalVprEl = document.getElementById(`${severity}TotalVPR`);
            const countEl = document.getElementById(`${severity}Count`);
            const trendBadgeEl = document.querySelector(`#${severity}Trend .trend-value`);

            if (!totalVprEl || !countEl || !trendBadgeEl) {
                console.error(`Missing elements for ${severity} severity`);
                return;
            }

            overallTotals[severity] = parseFloat(totalVprEl.textContent) || 0;
            overallCounts[severity] = parseInt(countEl.textContent, 10) || 0;

            const percentText = trendBadgeEl.textContent.trim();
            percentChanges[severity] = parseFloat(percentText.replace("%", "")) || 0;
        });

        // Fetch vendor totals AND percentage changes from backend API (parallel for efficiency)
        // Each vendor gets its own historical trend data for accurate previous week calculation
        const [ciscoData, paloData, otherData] = await Promise.all([
            this._aggregateVprByVendor("CISCO"),
            this._aggregateVprByVendor("Palo Alto"),
            this._aggregateVprByVendor("Other")
        ]);

        // Destructure vendor-specific totals (VPR and counts) and percentage changes
        const {
            current: ciscoTotals,
            currentCounts: ciscoCounts,
            percentChanges: ciscoPctChanges,
            countPercentChanges: ciscoCountPctChanges
        } = ciscoData;

        const {
            current: paloTotals,
            currentCounts: paloCounts,
            percentChanges: paloPctChanges,
            countPercentChanges: paloCountPctChanges
        } = paloData;

        const {
            current: otherTotals,
            currentCounts: otherCounts,
            percentChanges: otherPctChanges,
            countPercentChanges: otherCountPctChanges
        } = otherData;

        // Build side-by-side CSV with VPR tables on left, Count tables on right (2-cell spacing)
        let csvContent = "";
        const spacing = ",,"; // 2 empty cells

        // Helper to merge VPR and Count table rows side-by-side
        const mergeTables = (vprRows, countRows) => {
            return vprRows.map((vprRow, index) => {
                const countRow = countRows[index] || "";
                return `${vprRow}${spacing}${countRow}`;
            }).join("\n");
        };

        // Table 1: Overall VPR and Count Totals
        const overallVprHeader = "OVERALL VPR TOTALS,,,,," + spacing + "OVERALL VULNERABILITY COUNTS";
        const overallHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const overallVprRows = this._formatVendorTable(overallTotals, percentChanges).split("\n");
        const overallCountRows = this._formatVendorTable(overallCounts, percentChanges).split("\n");

        csvContent += overallVprHeader + "\n";
        csvContent += overallHeaders + "\n";
        csvContent += mergeTables(overallVprRows, overallCountRows) + "\n\n";

        // Table 2: CISCO Devices VPR and Counts
        const ciscoVprHeader = "CISCO DEVICES (VPR),,,,," + spacing + "CISCO DEVICES (COUNTS)";
        const ciscoHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const ciscoVprRows = this._formatVendorTable(ciscoTotals, ciscoPctChanges).split("\n");
        const ciscoCountRows = this._formatVendorTable(ciscoCounts, ciscoCountPctChanges).split("\n");

        csvContent += ciscoVprHeader + "\n";
        csvContent += ciscoHeaders + "\n";
        csvContent += mergeTables(ciscoVprRows, ciscoCountRows) + "\n\n";

        // Table 3: Palo Alto Devices VPR and Counts
        const paloVprHeader = "PALO ALTO DEVICES (VPR),,,,," + spacing + "PALO ALTO DEVICES (COUNTS)";
        const paloHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const paloVprRows = this._formatVendorTable(paloTotals, paloPctChanges).split("\n");
        const paloCountRows = this._formatVendorTable(paloCounts, paloCountPctChanges).split("\n");

        csvContent += paloVprHeader + "\n";
        csvContent += paloHeaders + "\n";
        csvContent += mergeTables(paloVprRows, paloCountRows) + "\n\n";

        // Table 4: Other Devices VPR and Counts
        const otherVprHeader = "OTHER DEVICES (VPR),,,,," + spacing + "OTHER DEVICES (COUNTS)";
        const otherHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const otherVprRows = this._formatVendorTable(otherTotals, otherPctChanges).split("\n");
        const otherCountRows = this._formatVendorTable(otherCounts, otherCountPctChanges).split("\n");

        csvContent += otherVprHeader + "\n";
        csvContent += otherHeaders + "\n";
        csvContent += mergeTables(otherVprRows, otherCountRows);

        // Download with updated filename
        const dateStr = new Date().toISOString().split("T")[0];
        this.downloadCSV(csvContent, `vpr-vendor-breakdown-${dateStr}`);

        console.log("✅ VPR vendor breakdown exported with side-by-side counts (using backend API for consistency)");
    }

    /**
     * Download data as CSV file (HEX-144, HEX-149)
     * Generates CSV from 2D array or string and triggers browser download
     *
     * @param {Array<Array<string|number>>|string} data - 2D array of CSV data or pre-formatted CSV string
     * @param {string} filename - Base filename (without extension or timestamp)
     * @returns {void}
     *
     * @example
     * // Array format
     * statisticsManager.downloadCSV([
     *   ["Name", "Value"],
     *   ["Item 1", 100]
     * ], "my-data");
     *
     * // String format
     * statisticsManager.downloadCSV("Name,Value\nItem 1,100", "my-data");
     * // Downloads: my-data-2025-10-07.csv
     */
    downloadCSV(data, filename) {
        // Convert 2D array to CSV string if needed
        const csvContent = Array.isArray(data)
            ? data.map(row => row.join(",")).join("\n")
            : data;

        // Create Blob with UTF-8 BOM for Excel compatibility
        const BOM = "\uFEFF";
        const blob = new Blob([BOM + csvContent], { type: "text/csv;charset=utf-8;" });

        // Create download link
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
        link.href = URL.createObjectURL(blob);
        link.download = `${filename}-${timestamp}.csv`;

        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Clean up object URL
        URL.revokeObjectURL(link.href);
    }
}

if (typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityStatisticsManager;
}
