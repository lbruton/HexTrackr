/**
 * @fileoverview VulnerabilityStatisticsManager
 * Manages vulnerability statistics, trends, and chart data processing
 */

/* global CustomEvent, module, EventTarget, console, document, setTimeout */

class VulnerabilityStatisticsManager extends EventTarget {
    constructor(dataManager) {
        super();
        this.dataManager = dataManager;
        this.trends = {};
        this.currentMetricType = "vpr";
    }

    /**
     * Updates statistics display in the UI
     * HEX-117: Modified to use cached backend endpoint for performance
     */
    async updateStatisticsDisplay() {
        // HEX-117: Use cached backend endpoint instead of client-side calculation
        let statistics;
        try {
            const response = await fetch("/api/vulnerabilities/stats");
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            statistics = await response.json();
            console.log("✅ Stats loaded from cached backend endpoint");
        } catch (error) {
            console.error("Failed to fetch stats from backend, falling back to dataManager:", error);
            // Fallback to dataManager if API fails
            statistics = this.dataManager.getStatistics();
        }

        if (!statistics) {
            console.warn("Statistics data not available");
            return;
        }
        
        const trendsSource = (this.trends && Object.keys(this.trends).length > 0)
            ? this.trends
            : (this.dataManager && this.dataManager.getTrends ? this.dataManager.getTrends() : {});

        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            const stat = statistics[severity];
            if (stat) {
                const countEl = document.getElementById(`${severity}Count`);
                const vprEl = document.getElementById(`${severity}VPR`);
                
                if (countEl) {
                    countEl.textContent = stat.count;
                }
                
                if (vprEl) {
                    vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
                }
                
                const totalVprEl = document.getElementById(`${severity}TotalVPR`);
                const avgVprEl = document.getElementById(`${severity}AvgVPR`);
                
                if (totalVprEl) {
                    totalVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (avgVprEl) {
                    const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                    avgVprEl.textContent = `${average} avg`;
                }
                
                const legacyCountEl = document.getElementById(`${severity}-count`);
                const legacyVprEl = document.getElementById(`${severity}-vpr`);
                
                if (legacyCountEl) {
                    legacyCountEl.textContent = stat.count;
                }
                
                if (legacyVprEl) {
                    legacyVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                const trendEl = document.getElementById(`${severity}Trend`);
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
                const trendBucket = trendsSource && trendsSource[severityKey] ? trendsSource[severityKey] : null;
                const trendData = trendBucket ? trendBucket.trend : null;
                
                if (trendEl && trendData) {
                    const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
                    const current = this.currentMetricType === "vpr" ? trendBucket.current.total_vpr : trendBucket.current.count;
                    const previous = current - change;
                    const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";

                    let percentage = 0;
                    if (previous !== 0) {
                        percentage = Math.abs((change / previous) * 100);
                    }

                    const iconEl = trendEl.querySelector("i");
                    const badgeEl = trendEl.querySelector(".trend-value");

                    if (iconEl && badgeEl) {
                        if (direction === "up") {
                            iconEl.className = "ti ti-trending-up fs-3";
                            badgeEl.textContent = `+${percentage.toFixed(1)}%`;
                        } else if (direction === "down") {
                            iconEl.className = "ti ti-trending-down fs-3";
                            badgeEl.textContent = `-${percentage.toFixed(1)}%`;
                        } else {
                            iconEl.className = "ti ti-minus fs-3";
                            badgeEl.textContent = "0%";
                        }
                    }
                }
            }
        });
        
        const totalVulns = Object.values(statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }

        this.dispatchEvent(new CustomEvent("statisticsDisplayUpdated", {
            detail: { statistics, totalVulns }
        }));
    }

    /**
     * Calculates trend between two values
     */
    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }
        
        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }
        
        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    /**
     * Updates chart with current metric type and data
     * HEX-117: Modified to use cached backend trends endpoint
     */
    async updateChart(chart) {
        if (!chart) {
            return;
        }

        // HEX-117: Fetch trends from cached backend endpoint
        let historicalData;
        try {
            const response = await fetch("/api/vulnerabilities/trends");
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            historicalData = await response.json();
            console.log("✅ Chart trends loaded from cached backend endpoint");
        } catch (error) {
            console.error("Failed to fetch trends from backend, falling back to dataManager:", error);
            // Fallback to dataManager if API fails
            historicalData = this.dataManager.getHistoricalData();
        }

        if (!historicalData || historicalData.length === 0) {
            return;
        }

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        this.currentMetricType = metricType;

        const extendedData = this.dataManager.extendTimelineData(historicalData);
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date).getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        chart.updateSeries(series);

        setTimeout(() => {
            if (chart && chart.resetSeries) {
                chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date).toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        if (value && value > 0) {
                            const color = colors[index];
                            tooltipContent += `
                                <div class="tooltip-row">
                                    <span class="color-indicator" style="background-color: ${color}"></span>
                                    <span class="severity-name">${severity}:</span>
                                    <span class="severity-value">${metricType === "vpr" ? value.toFixed(2) : value.toFixed(0)}</span>
                                </div>`;
                        }
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        this.dispatchEvent(new CustomEvent("chartUpdated", {
            detail: { series, metricType, extendedData }
        }));
    }

    /**
     * Get current metric type
     */
    getCurrentMetricType() {
        return this.currentMetricType;
    }

    /**
     * Set current metric type
     */
    setCurrentMetricType(metricType) {
        this.currentMetricType = metricType;
        this.dispatchEvent(new CustomEvent("metricTypeChanged", {
            detail: { metricType }
        }));
    }

    /**
     * Get current trends data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Set trends data
     */
    setTrends(trends) {
        this.trends = trends;
        this.dispatchEvent(new CustomEvent("trendsSet", {
            detail: { trends }
        }));
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Simple instant toggle for all 4 severity levels
     */
    flipStatCards() {
        const severities = ["critical", "high", "medium", "low"];
        
        severities.forEach(severity => {
            const statCard = document.querySelector(`.stat-card-enhanced[data-severity="${severity}"]`);
            if (!statCard) {return;}
            
            const cardFront = statCard.querySelector(".card-front");
            const cardBack = statCard.querySelector(".card-back");
            
            if (!cardFront || !cardBack) {return;}
            
            // Simple instant toggle - no animation
            if (cardFront.style.display !== "none") {
                cardFront.style.display = "none";
                cardBack.style.display = "block";
            } else {
                cardFront.style.display = "block";
                cardBack.style.display = "none";
            }
        });
        
        // Dispatch event for tracking/testing
        this.dispatchEvent(new CustomEvent("cardsFlipped", {
            detail: { timestamp: new Date().toISOString() }
        }));
    }
}

if (typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityStatisticsManager;
}
