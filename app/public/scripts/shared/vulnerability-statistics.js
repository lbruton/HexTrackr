/**
 * @fileoverview VulnerabilityStatisticsManager
 * Manages vulnerability statistics, trends, and chart data processing
 */

/* global CustomEvent, module, EventTarget, console, document, setTimeout, authState */

class VulnerabilityStatisticsManager extends EventTarget {
    constructor(dataManager) {
        super();
        this.dataManager = dataManager;
        this.trends = {};
        this.currentMetricType = "vpr";
    }

    /**
     * Updates statistics display in the UI
     * HEX-117: Modified to use cached backend endpoint for performance
     * HEX-144: Sets up VPR export shortcut after stats update
     */
    async updateStatisticsDisplay() {
        // HEX-117: Use cached backend endpoint instead of client-side calculation
        let statistics;
        try {
            const response = await authState.authenticatedFetch("/api/vulnerabilities/stats");
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            statistics = await response.json();
            console.log("✅ Stats loaded from cached backend endpoint");
        } catch (error) {
            console.error("Failed to fetch stats from backend, falling back to dataManager:", error);
            // Fallback to dataManager if API fails
            statistics = this.dataManager.getStatistics();
        }

        if (!statistics) {
            console.warn("Statistics data not available");
            return;
        }

        const trendsSource = (this.trends && Object.keys(this.trends).length > 0)
            ? this.trends
            : (this.dataManager && this.dataManager.getTrends ? this.dataManager.getTrends() : {});

        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            const stat = statistics[severity];
            if (stat) {
                const countEl = document.getElementById(`${severity}Count`);
                const vprEl = document.getElementById(`${severity}VPR`);
                
                if (countEl) {
                    countEl.textContent = stat.count;
                }
                
                if (vprEl) {
                    vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
                }
                
                const totalVprEl = document.getElementById(`${severity}TotalVPR`);
                const avgVprEl = document.getElementById(`${severity}AvgVPR`);
                
                if (totalVprEl) {
                    totalVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (avgVprEl) {
                    const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                    avgVprEl.textContent = `${average} avg`;
                }
                
                const legacyCountEl = document.getElementById(`${severity}-count`);
                const legacyVprEl = document.getElementById(`${severity}-vpr`);
                
                if (legacyCountEl) {
                    legacyCountEl.textContent = stat.count;
                }
                
                if (legacyVprEl) {
                    legacyVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                const trendEl = document.getElementById(`${severity}Trend`);
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
                const trendBucket = trendsSource && trendsSource[severityKey] ? trendsSource[severityKey] : null;
                const trendData = trendBucket ? trendBucket.trend : null;
                
                if (trendEl && trendData) {
                    const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
                    const current = this.currentMetricType === "vpr" ? trendBucket.current.total_vpr : trendBucket.current.count;
                    const previous = current - change;
                    const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";

                    let percentage = 0;
                    if (previous !== 0) {
                        percentage = Math.abs((change / previous) * 100);
                    }

                    const iconEl = trendEl.querySelector("i");
                    const badgeEl = trendEl.querySelector(".trend-value");

                    if (iconEl && badgeEl) {
                        if (direction === "up") {
                            iconEl.className = "ti ti-trending-up fs-3";
                            badgeEl.textContent = `+${percentage.toFixed(1)}%`;
                        } else if (direction === "down") {
                            iconEl.className = "ti ti-trending-down fs-3";
                            badgeEl.textContent = `-${percentage.toFixed(1)}%`;
                        } else {
                            iconEl.className = "ti ti-minus fs-3";
                            badgeEl.textContent = "0%";
                        }
                    }
                }
            }
        });
        
        const totalVulns = Object.values(statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }

        // HEX-144: Setup VPR export shortcut after stats are rendered
        this.setupVprExportShortcut();

        this.dispatchEvent(new CustomEvent("statisticsDisplayUpdated", {
            detail: { statistics, totalVulns }
        }));
    }

    /**
     * Calculates trend between two values
     */
    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }
        
        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }
        
        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    /**
     * Updates chart with current metric type and data
     * HEX-117: Modified to use cached backend trends endpoint
     */
    async updateChart(chart) {
        if (!chart) {
            return;
        }

        // HEX-117: Fetch trends from cached backend endpoint
        let historicalData;
        try {
            const response = await authState.authenticatedFetch("/api/vulnerabilities/trends");
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            historicalData = await response.json();
            console.log("✅ Chart trends loaded from cached backend endpoint");
        } catch (error) {
            console.error("Failed to fetch trends from backend, falling back to dataManager:", error);
            // Fallback to dataManager if API fails
            historicalData = this.dataManager.getHistoricalData();
        }

        if (!historicalData || historicalData.length === 0) {
            return;
        }

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        this.currentMetricType = metricType;

        const extendedData = this.dataManager.extendTimelineData(historicalData);
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date).getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        chart.updateSeries(series);

        setTimeout(() => {
            if (chart && chart.resetSeries) {
                chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date).toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        if (value && value > 0) {
                            const color = colors[index];
                            tooltipContent += `
                                <div class="tooltip-row">
                                    <span class="color-indicator" style="background-color: ${color}"></span>
                                    <span class="severity-name">${severity}:</span>
                                    <span class="severity-value">${metricType === "vpr" ? value.toFixed(2) : value.toFixed(0)}</span>
                                </div>`;
                        }
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        this.dispatchEvent(new CustomEvent("chartUpdated", {
            detail: { series, metricType, extendedData }
        }));
    }

    /**
     * Get current metric type
     */
    getCurrentMetricType() {
        return this.currentMetricType;
    }

    /**
     * Set current metric type
     */
    setCurrentMetricType(metricType) {
        this.currentMetricType = metricType;
        this.dispatchEvent(new CustomEvent("metricTypeChanged", {
            detail: { metricType }
        }));
    }

    /**
     * Get current trends data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Set trends data
     */
    setTrends(trends) {
        this.trends = trends;
        this.dispatchEvent(new CustomEvent("trendsSet", {
            detail: { trends }
        }));
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Simple instant toggle for all 4 severity levels
     */
    flipStatCards() {
        const severities = ["critical", "high", "medium", "low"];

        severities.forEach(severity => {
            const statCard = document.querySelector(`.stat-card-enhanced[data-severity="${severity}"]`);
            if (!statCard) {return;}

            const cardFront = statCard.querySelector(".card-front");
            const cardBack = statCard.querySelector(".card-back");

            if (!cardFront || !cardBack) {return;}

            // Simple instant toggle - no animation
            if (cardFront.style.display !== "none") {
                cardFront.style.display = "none";
                cardBack.style.display = "block";
            } else {
                cardFront.style.display = "block";
                cardBack.style.display = "none";
            }
        });

        // Dispatch event for tracking/testing
        this.dispatchEvent(new CustomEvent("cardsFlipped", {
            detail: { timestamp: new Date().toISOString() }
        }));
    }

    /**
     * Setup keyboard shortcut for VPR weekly summary export (HEX-144)
     * Attaches Cmd+Shift+Click (Mac) or Ctrl+Shift+Click (Windows) listeners to all 4 VPR cards
     * Hidden power user feature for quick CSV export of weekly VPR totals
     *
     * @returns {void}
     *
     * @example
     * // Called after statistics update to ensure cards are rendered
     * statisticsManager.setupVprExportShortcut();
     */
    setupVprExportShortcut() {
        // Security check: Only enable for authenticated users
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("VPR export shortcut not enabled - user not authenticated");
            return;
        }

        const cards = document.querySelectorAll(".stat-card-enhanced[data-severity]");

        cards.forEach(card => {
            // Remove existing listener if any (prevent duplicates)
            card.removeEventListener("click", this._handleCardClick);

            // Bind context and store reference for removal
            this._handleCardClick = this._handleCardClick.bind(this);

            // Add event listener
            card.addEventListener("click", this._handleCardClick);
        });

        console.log("✅ VPR export shortcut enabled (Cmd+Shift+Click or Ctrl+Shift+Click)");
    }

    /**
     * Handle card click event for export shortcut (HEX-144)
     * Internal method bound to card click events
     *
     * @private
     * @param {MouseEvent} event - Click event
     * @returns {void}
     */
    _handleCardClick(event) {
        // Check for Cmd+Shift (Mac) or Ctrl+Shift (Windows)
        if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            event.preventDefault();
            event.stopPropagation(); // Prevent card flip
            this.exportVprWeeklySummary();
        }
    }

    /**
     * Export VPR weekly summary to CSV (HEX-144)
     * Extracts current VPR values and percentage changes from stat cards,
     * calculates previous week values, and generates CSV download
     *
     * CSV Format:
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * PREV WEEK,148.0,23222.0,18689.9,1484.9,43544.8
     * THIS WEEK,203.2,23216.7,24452.7,1483.9,49356.5
     * CHANGE,55.2,-5.3,5762.8,-1.0,5811.7
     *
     * @returns {void}
     *
     * @example
     * statisticsManager.exportVprWeeklySummary();
     * // Downloads: vpr-weekly-summary-2025-10-07.csv
     */
    exportVprWeeklySummary() {
        // Security check
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("Export aborted - user not authenticated");
            return;
        }

        const severities = ["critical", "high", "medium", "low"];
        const data = {};

        // Extract current VPR values and percentage changes
        severities.forEach(severity => {
            const totalVprEl = document.getElementById(`${severity}TotalVPR`);
            const trendBadgeEl = document.querySelector(`#${severity}Trend .trend-value`);

            if (!totalVprEl || !trendBadgeEl) {
                console.error(`Missing elements for ${severity} severity`);
                return;
            }

            const thisWeek = parseFloat(totalVprEl.textContent) || 0;
            const percentText = trendBadgeEl.textContent.trim();
            const percentChange = parseFloat(percentText.replace('%', '')) || 0;

            // Calculate previous week: thisWeek = prevWeek * (1 + percentChange/100)
            // Therefore: prevWeek = thisWeek / (1 + percentChange/100)
            const prevWeek = percentChange !== -100
                ? thisWeek / (1 + (percentChange / 100))
                : 0;

            const change = thisWeek - prevWeek;

            data[severity] = {
                thisWeek: thisWeek,
                prevWeek: prevWeek,
                change: change
            };
        });

        // Calculate totals
        const thisWeekTotal = severities.reduce((sum, s) => sum + data[s].thisWeek, 0);
        const prevWeekTotal = severities.reduce((sum, s) => sum + data[s].prevWeek, 0);
        const changeTotal = thisWeekTotal - prevWeekTotal;

        // Generate CSV data
        const csvData = [
            ["PERIOD", "CRITICAL", "HIGH", "MEDIUM", "LOW", "TOTAL"],
            [
                "PREV WEEK",
                data.critical.prevWeek.toFixed(1),
                data.high.prevWeek.toFixed(1),
                data.medium.prevWeek.toFixed(1),
                data.low.prevWeek.toFixed(1),
                prevWeekTotal.toFixed(1)
            ],
            [
                "THIS WEEK",
                data.critical.thisWeek.toFixed(1),
                data.high.thisWeek.toFixed(1),
                data.medium.thisWeek.toFixed(1),
                data.low.thisWeek.toFixed(1),
                thisWeekTotal.toFixed(1)
            ],
            [
                "CHANGE",
                data.critical.change.toFixed(1),
                data.high.change.toFixed(1),
                data.medium.change.toFixed(1),
                data.low.change.toFixed(1),
                changeTotal.toFixed(1)
            ]
        ];

        // Download CSV
        this.downloadCSV(csvData, "vpr-weekly-summary");

        console.log("✅ VPR weekly summary exported");
    }

    /**
     * Download data as CSV file (HEX-144)
     * Generates CSV from 2D array and triggers browser download
     *
     * @param {Array<Array<string|number>>} data - 2D array of CSV data
     * @param {string} filename - Base filename (without extension or timestamp)
     * @returns {void}
     *
     * @example
     * statisticsManager.downloadCSV([
     *   ["Name", "Value"],
     *   ["Item 1", 100],
     *   ["Item 2", 200]
     * ], "my-data");
     * // Downloads: my-data-2025-10-07.csv
     */
    downloadCSV(data, filename) {
        // Convert 2D array to CSV string
        const csvContent = data.map(row => row.join(',')).join('\n');

        // Create Blob with UTF-8 BOM for Excel compatibility
        const BOM = '\uFEFF';
        const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });

        // Create download link
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        link.href = URL.createObjectURL(blob);
        link.download = `${filename}-${timestamp}.csv`;

        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Clean up object URL
        URL.revokeObjectURL(link.href);
    }
}

if (typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityStatisticsManager;
}
