/**
 * @fileoverview VulnerabilityStatisticsManager
 * Manages vulnerability statistics, trends, and chart data processing
 */

/* global CustomEvent, module, EventTarget, console, document, setTimeout, authState */

class VulnerabilityStatisticsManager extends EventTarget {
    constructor(dataManager) {
        super();
        this.dataManager = dataManager;
        this.trends = {};
        this.currentMetricType = "vpr";
    }

    /**
     * Updates statistics display in the UI
     * HEX-117: Modified to use cached backend endpoint for performance
     * HEX-144: Sets up VPR export shortcut after stats update
     */
    async updateStatisticsDisplay() {
        // HEX-117: Use cached backend endpoint instead of client-side calculation
        let statistics;
        try {
            const response = await authState.authenticatedFetch("/api/vulnerabilities/stats");
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            statistics = await response.json();
            console.log("✅ Stats loaded from cached backend endpoint");
        } catch (error) {
            console.error("Failed to fetch stats from backend, falling back to dataManager:", error);
            // Fallback to dataManager if API fails
            statistics = this.dataManager.getStatistics();
        }

        if (!statistics) {
            console.warn("Statistics data not available");
            return;
        }

        const trendsSource = (this.trends && Object.keys(this.trends).length > 0)
            ? this.trends
            : (this.dataManager && this.dataManager.getTrends ? this.dataManager.getTrends() : {});

        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            const stat = statistics[severity];
            if (stat) {
                const countEl = document.getElementById(`${severity}Count`);
                const vprEl = document.getElementById(`${severity}VPR`);
                
                if (countEl) {
                    countEl.textContent = stat.count;
                }
                
                if (vprEl) {
                    vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
                }
                
                const totalVprEl = document.getElementById(`${severity}TotalVPR`);
                const avgVprEl = document.getElementById(`${severity}AvgVPR`);
                
                if (totalVprEl) {
                    totalVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (avgVprEl) {
                    const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                    avgVprEl.textContent = `${average} avg`;
                }
                
                const legacyCountEl = document.getElementById(`${severity}-count`);
                const legacyVprEl = document.getElementById(`${severity}-vpr`);
                
                if (legacyCountEl) {
                    legacyCountEl.textContent = stat.count;
                }
                
                if (legacyVprEl) {
                    legacyVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                const trendEl = document.getElementById(`${severity}Trend`);
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
                const trendBucket = trendsSource && trendsSource[severityKey] ? trendsSource[severityKey] : null;
                const trendData = trendBucket ? trendBucket.trend : null;
                
                if (trendEl && trendData) {
                    const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
                    const current = this.currentMetricType === "vpr" ? trendBucket.current.total_vpr : trendBucket.current.count;
                    const previous = current - change;
                    const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";

                    let percentage = 0;
                    if (previous !== 0) {
                        percentage = Math.abs((change / previous) * 100);
                    }

                    const iconEl = trendEl.querySelector("i");
                    const badgeEl = trendEl.querySelector(".trend-value");

                    if (iconEl && badgeEl) {
                        if (direction === "up") {
                            iconEl.className = "ti ti-trending-up fs-3";
                            badgeEl.textContent = `+${percentage.toFixed(1)}%`;
                        } else if (direction === "down") {
                            iconEl.className = "ti ti-trending-down fs-3";
                            badgeEl.textContent = `-${percentage.toFixed(1)}%`;
                        } else {
                            iconEl.className = "ti ti-minus fs-3";
                            badgeEl.textContent = "0%";
                        }
                    }
                }
            }
        });
        
        const totalVulns = Object.values(statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }

        // HEX-144: Setup VPR export shortcut after stats are rendered
        this.setupVprExportShortcut();

        this.dispatchEvent(new CustomEvent("statisticsDisplayUpdated", {
            detail: { statistics, totalVulns }
        }));
    }

    /**
     * Calculates trend between two values
     */
    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }
        
        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }
        
        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    /**
     * Updates chart with current metric type and data
     * HEX-117: Modified to use cached backend trends endpoint
     * @param {Object} chart - ApexCharts instance to update
     * @param {boolean} bustCache - If true, append timestamp to bypass cache
     */
    async updateChart(chart, bustCache = false) {
        if (!chart) {
            return;
        }

        // HEX-117: Fetch trends from cached backend endpoint
        let historicalData;
        try {
            // Add cache-busting timestamp if requested
            const cacheBustParam = bustCache ? `?_t=${Date.now()}` : "";
            const trendsUrl = `/api/vulnerabilities/trends${cacheBustParam}`;
            
            const response = await authState.authenticatedFetch(trendsUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            historicalData = await response.json();
            console.log(`✅ Chart trends loaded from ${bustCache ? "fresh" : "cached"} backend endpoint`);
        } catch (error) {
            console.error("Failed to fetch trends from backend, falling back to dataManager:", error);
            // Fallback to dataManager if API fails
            historicalData = this.dataManager.getHistoricalData();
        }

        if (!historicalData || historicalData.length === 0) {
            return;
        }

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        this.currentMetricType = metricType;

        const extendedData = this.dataManager.extendTimelineData(historicalData);
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date).getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        chart.updateSeries(series);

        setTimeout(() => {
            if (chart && chart.resetSeries) {
                chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date).toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        if (value && value > 0) {
                            const color = colors[index];
                            tooltipContent += `
                                <div class="tooltip-row">
                                    <span class="color-indicator" style="background-color: ${color}"></span>
                                    <span class="severity-name">${severity}:</span>
                                    <span class="severity-value">${metricType === "vpr" ? value.toFixed(2) : value.toFixed(0)}</span>
                                </div>`;
                        }
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        this.dispatchEvent(new CustomEvent("chartUpdated", {
            detail: { series, metricType, extendedData }
        }));
    }

    /**
     * Get current metric type
     */
    getCurrentMetricType() {
        return this.currentMetricType;
    }

    /**
     * Set current metric type
     */
    setCurrentMetricType(metricType) {
        this.currentMetricType = metricType;
        this.dispatchEvent(new CustomEvent("metricTypeChanged", {
            detail: { metricType }
        }));
    }

    /**
     * Get current trends data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Set trends data
     */
    setTrends(trends) {
        this.trends = trends;
        this.dispatchEvent(new CustomEvent("trendsSet", {
            detail: { trends }
        }));
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Simple instant toggle for all 4 severity levels
     */
    flipStatCards() {
        const severities = ["critical", "high", "medium", "low"];

        severities.forEach(severity => {
            const statCard = document.querySelector(`.stat-card-enhanced[data-severity="${severity}"]`);
            if (!statCard) {return;}

            const cardFront = statCard.querySelector(".card-front");
            const cardBack = statCard.querySelector(".card-back");

            if (!cardFront || !cardBack) {return;}

            // Simple instant toggle - no animation
            if (cardFront.style.display !== "none") {
                cardFront.style.display = "none";
                cardBack.style.display = "block";
            } else {
                cardFront.style.display = "block";
                cardBack.style.display = "none";
            }
        });

        // Dispatch event for tracking/testing
        this.dispatchEvent(new CustomEvent("cardsFlipped", {
            detail: { timestamp: new Date().toISOString() }
        }));
    }

    /**
     * Setup keyboard shortcut for VPR weekly summary export (HEX-144)
     * Attaches Cmd+Shift+Click (Mac) or Ctrl+Shift+Click (Windows) listeners to all 4 VPR cards
     * Hidden power user feature for quick CSV export of weekly VPR totals
     *
     * @returns {void}
     *
     * @example
     * // Called after statistics update to ensure cards are rendered
     * statisticsManager.setupVprExportShortcut();
     */
    setupVprExportShortcut() {
        // Security check: Only enable for authenticated users
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("VPR export shortcut not enabled - user not authenticated");
            return;
        }

        const cards = document.querySelectorAll(".stat-card-enhanced[data-severity]");

        cards.forEach(card => {
            // Remove existing listener if any (prevent duplicates)
            card.removeEventListener("click", this._handleCardClick);

            // Bind context and store reference for removal
            this._handleCardClick = this._handleCardClick.bind(this);

            // Add event listener
            card.addEventListener("click", this._handleCardClick);
        });

        console.log("✅ VPR export shortcut enabled (Cmd+Shift+Click or Ctrl+Shift+Click)");
    }

    /**
     * Handle card click event for export shortcut (HEX-144)
     * Internal method bound to card click events
     *
     * @private
     * @param {MouseEvent} event - Click event
     * @returns {void}
     */
    _handleCardClick(event) {
        // Check for Cmd+Shift (Mac) or Ctrl+Shift (Windows)
        if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            event.preventDefault();
            event.stopPropagation(); // Prevent card flip
            this.exportVprWeeklySummary();
        }
    }

    /**
     * Aggregate VPR totals by vendor category from vulnerability dataset
     * Uses deduplication logic matching backend stats API to avoid counting
     * the same CVE multiple times on the same hostname
     *
     * @param {string} vendorFilter - 'CISCO', 'Palo Alto', or 'Other'
     * @returns {Object} VPR totals by severity {critical, high, medium, low}
     * @private
     */
    _aggregateVprByVendor(vendorFilter) {
        // Access pre-filtered vulnerabilities from data manager
        const vulnerabilities = this.dataManager.vulnerabilities || [];

        // Filter by vendor (vendor field pre-normalized at import time via helpers.js:normalizeVendor)
        const filtered = vulnerabilities.filter(v => v.vendor === vendorFilter);

        // Deduplicate by severity + hostname + dedup_key (matches backend logic)
        // Backend uses: GROUP BY severity, hostname, COALESCE(plugin_id, SUBSTR(description, 1, 100))
        const deduped = new Map();

        filtered.forEach(vuln => {
            const severity = (vuln.severity || "").toLowerCase();
            const hostname = vuln.hostname || "";
            const dedupKey = vuln.plugin_id || (vuln.description || "").substring(0, 100);
            const vprScore = parseFloat(vuln.vpr_score) || 0;

            // Create composite key: severity|hostname|dedupKey
            const compositeKey = `${severity}|${hostname}|${dedupKey}`;

            // Keep the maximum VPR score for each unique vulnerability (matches backend MAX(vpr_score))
            if (!deduped.has(compositeKey) || deduped.get(compositeKey).vprScore < vprScore) {
                deduped.set(compositeKey, {
                    severity: severity,
                    vprScore: vprScore
                });
            }
        });

        // Aggregate VPR scores by severity from deduplicated set
        const totals = {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0
        };

        deduped.forEach(vuln => {
            if (totals.hasOwnProperty(vuln.severity)) {
                totals[vuln.severity] += vuln.vprScore;
            }
        });

        // Validation logging (HEX-149 Task 1.1)
        console.log(`[Vendor Aggregation] ${vendorFilter}:`, {
            totalVulns: filtered.length,
            uniqueVulns: deduped.size,
            totals: totals
        });

        return totals;
    }

    /**
     * Format vendor VPR totals into CSV table rows (PREV WEEK, THIS WEEK, CHANGE)
     * @param {Object} currentTotals - Current period VPR totals by severity
     * @param {Object} percentChanges - Percentage changes from trend badges
     * @returns {string} Three CSV rows with vendor table data
     * @private
     */
    _formatVendorTable(currentTotals, percentChanges) {
        const severities = ["critical", "high", "medium", "low"];

        // Calculate previous week values using reverse percentage formula
        const prevTotals = {};
        severities.forEach(severity => {
            const current = currentTotals[severity] || 0;
            const pctChange = percentChanges[severity] || 0;
            prevTotals[severity] = current / (1 + (pctChange / 100));
        });

        // Calculate totals
        const currentTotal = severities.reduce((sum, s) => sum + (currentTotals[s] || 0), 0);
        const prevTotal = severities.reduce((sum, s) => sum + (prevTotals[s] || 0), 0);
        const changeTotal = currentTotal - prevTotal;

        // Format as CSV rows
        const prevRow = `PREV WEEK,${severities.map(s => prevTotals[s].toFixed(1)).join(",")},${prevTotal.toFixed(1)}`;
        const currentRow = `THIS WEEK,${severities.map(s => currentTotals[s].toFixed(1)).join(",")},${currentTotal.toFixed(1)}`;
        const changeRow = `CHANGE,${severities.map(s => ((currentTotals[s] || 0) - prevTotals[s]).toFixed(1)).join(",")},${changeTotal.toFixed(1)}`;

        return `${prevRow}\n${currentRow}\n${changeRow}`;
    }

    /**
     * Export VPR weekly summary to CSV with vendor breakdown (HEX-144, HEX-149)
     * Extracts current VPR values and percentage changes from stat cards,
     * calculates previous week values, and generates 4-table CSV download:
     * 1. Overall VPR Totals (all devices)
     * 2. CISCO Devices (vendor-filtered)
     * 3. Palo Alto Devices (vendor-filtered)
     * 4. Other Devices (remaining/unmatched)
     *
     * CSV Format (4 tables separated by blank lines):
     * OVERALL VPR TOTALS
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * PREV WEEK,148.0,23222.0,18689.9,1484.9,43544.8
     * THIS WEEK,203.2,23216.7,24452.7,1483.9,49356.5
     * CHANGE,55.2,-5.3,5762.8,-1.0,5811.7
     *
     * CISCO DEVICES
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * ... (vendor-specific rows)
     *
     * @returns {void}
     *
     * @example
     * statisticsManager.exportVprWeeklySummary();
     * // Downloads: vpr-vendor-breakdown-2025-10-07.csv
     */
    exportVprWeeklySummary() {
        // Security check
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("Export aborted - user not authenticated");
            return;
        }

        const severities = ["critical", "high", "medium", "low"];

        // Extract overall totals and percentage changes from DOM (preserve existing logic)
        const overallTotals = {};
        const percentChanges = {};

        severities.forEach(severity => {
            const totalVprEl = document.getElementById(`${severity}TotalVPR`);
            const trendBadgeEl = document.querySelector(`#${severity}Trend .trend-value`);

            if (!totalVprEl || !trendBadgeEl) {
                console.error(`Missing elements for ${severity} severity`);
                return;
            }

            overallTotals[severity] = parseFloat(totalVprEl.textContent) || 0;

            const percentText = trendBadgeEl.textContent.trim();
            percentChanges[severity] = parseFloat(percentText.replace("%", "")) || 0;
        });

        // Build CSV with 4 tables using string concatenation
        let csvContent = "";

        // Table 1: Overall VPR Totals
        csvContent += "OVERALL VPR TOTALS\n";
        csvContent += "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL\n";
        csvContent += this._formatVendorTable(overallTotals, percentChanges) + "\n\n";

        // Table 2: CISCO Devices
        const ciscoTotals = this._aggregateVprByVendor("CISCO");
        csvContent += "CISCO DEVICES\n";
        csvContent += "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL\n";
        csvContent += this._formatVendorTable(ciscoTotals, percentChanges) + "\n\n";

        // Table 3: Palo Alto Devices
        const paloTotals = this._aggregateVprByVendor("Palo Alto");
        csvContent += "PALO ALTO DEVICES\n";
        csvContent += "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL\n";
        csvContent += this._formatVendorTable(paloTotals, percentChanges) + "\n\n";

        // Table 4: Other Devices
        const otherTotals = this._aggregateVprByVendor("Other");
        csvContent += "OTHER DEVICES\n";
        csvContent += "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL\n";
        csvContent += this._formatVendorTable(otherTotals, percentChanges);

        // Download with updated filename
        const dateStr = new Date().toISOString().split("T")[0];
        this.downloadCSV(csvContent, `vpr-vendor-breakdown-${dateStr}`);

        console.log("✅ VPR vendor breakdown exported");
    }

    /**
     * Download data as CSV file (HEX-144, HEX-149)
     * Generates CSV from 2D array or string and triggers browser download
     *
     * @param {Array<Array<string|number>>|string} data - 2D array of CSV data or pre-formatted CSV string
     * @param {string} filename - Base filename (without extension or timestamp)
     * @returns {void}
     *
     * @example
     * // Array format
     * statisticsManager.downloadCSV([
     *   ["Name", "Value"],
     *   ["Item 1", 100]
     * ], "my-data");
     *
     * // String format
     * statisticsManager.downloadCSV("Name,Value\nItem 1,100", "my-data");
     * // Downloads: my-data-2025-10-07.csv
     */
    downloadCSV(data, filename) {
        // Convert 2D array to CSV string if needed
        const csvContent = Array.isArray(data)
            ? data.map(row => row.join(",")).join("\n")
            : data;

        // Create Blob with UTF-8 BOM for Excel compatibility
        const BOM = "\uFEFF";
        const blob = new Blob([BOM + csvContent], { type: "text/csv;charset=utf-8;" });

        // Create download link
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
        link.href = URL.createObjectURL(blob);
        link.download = `${filename}-${timestamp}.csv`;

        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Clean up object URL
        URL.revokeObjectURL(link.href);
    }
}

if (typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityStatisticsManager;
}
