/**
 * @fileoverview VulnerabilityStatisticsManager
 * Manages vulnerability statistics, trends, and chart data processing
 */

/* global CustomEvent, module, EventTarget, console, document, setTimeout, authState */

class VulnerabilityStatisticsManager extends EventTarget {
    constructor(dataManager) {
        super();
        this.dataManager = dataManager;
        this.trends = {};
        this.currentMetricType = "vpr";
        this._exportShortcutInitialized = false; // Track if export shortcut is set up
    }

    /**
     * Updates statistics display in the UI
     * HEX-117: Modified to use cached backend endpoint for performance
     * HEX-144: Sets up VPR export shortcut after stats update
     * HEX-156: Added vendor parameter for vendor-filtered statistics
     * @param {string|null} vendor - Optional vendor filter ('CISCO', 'Palo Alto', 'Other', or null for all)
     */
    async updateStatisticsDisplay(vendor = null) {
        // HEX-156: Build vendor-aware API URL
        const url = vendor
            ? `/api/vulnerabilities/stats?vendor=${encodeURIComponent(vendor)}`
            : "/api/vulnerabilities/stats";

        let statistics;
        try {
            const response = await authState.authenticatedFetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            statistics = await response.json();

            const vendorLabel = vendor ? ` (${vendor})` : "";
            console.log(`✅ Stats loaded from cached backend endpoint${vendorLabel}`);
        } catch (error) {
            console.error("Failed to fetch stats from backend:", error);
            // No fallback for vendor filtering - show error to user (Task 3.2)
            throw error;
        }

        if (!statistics) {
            console.warn("Statistics data not available");
            return;
        }

        const trendsSource = (this.trends && Object.keys(this.trends).length > 0)
            ? this.trends
            : (this.dataManager && this.dataManager.getTrends ? this.dataManager.getTrends() : {});

        // HEX-183: Collect all trend update promises to await them together
        const trendUpdatePromises = [];

        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            // HEX-183: Handle case where vendor has 0 vulnerabilities for this severity
            // Backend may return null/undefined for severity with 0 count
            // We must still update DOM to clear previous vendor's values
            const stat = statistics[severity] || { count: 0, total_vpr: 0 };

            const countEl = document.getElementById(`${severity}Count`);
            const vprEl = document.getElementById(`${severity}VPR`);

            if (countEl) {
                countEl.textContent = stat.count;
            }

            if (vprEl) {
                vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
            }

            const totalVprEl = document.getElementById(`${severity}TotalVPR`);
            const avgVprEl = document.getElementById(`${severity}AvgVPR`);

            if (totalVprEl) {
                totalVprEl.textContent = stat.total_vpr.toFixed(1);
            }

            if (avgVprEl) {
                const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                avgVprEl.textContent = `${average} avg`;
            }

            const legacyCountEl = document.getElementById(`${severity}-count`);
            const legacyVprEl = document.getElementById(`${severity}-vpr`);

            if (legacyCountEl) {
                legacyCountEl.textContent = stat.count;
            }

            if (legacyVprEl) {
                legacyVprEl.textContent = stat.total_vpr.toFixed(1);
            }

            // HEX-183: Queue trend update promise
            const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
            const trendBucket = trendsSource && trendsSource[severityKey] ? trendsSource[severityKey] : null;

            trendUpdatePromises.push(
                this.updateTrendDisplay(severity, stat, trendBucket, vendor).catch(error => {
                    console.error(`Failed to update trend for ${severity}:`, error);
                })
            );
        });

        // HEX-183: Wait for all trend updates to complete before proceeding
        // This prevents race conditions when rapidly toggling vendor filters
        await Promise.all(trendUpdatePromises);
        
        const totalVulns = Object.values(statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }

        // HEX-144: Setup VPR export shortcut after stats are rendered
        this.setupVprExportShortcut();

        this.dispatchEvent(new CustomEvent("statisticsDisplayUpdated", {
            detail: { statistics, totalVulns }
        }));
    }

    /**
     * Updates the trend display for a specific severity bucket
     * HEX-183: Modified to support vendor-filtered trends
     * @param {string} severity - Severity level (critical, high, medium, low, info)
     * @param {Object} currentStat - Current statistics for this severity
     * @param {Object} trendBucket - Trend data bucket for this severity (may be null)
     * @param {string|null} vendorFilter - Optional vendor filter ('CISCO', 'Palo Alto', 'Other')
     */
    async updateTrendDisplay(severity, currentStat, trendBucket, vendorFilter = null) {
        const trendEl = document.getElementById(`${severity}Trend`);
        if (!trendEl) return;

        let trendData = trendBucket ? trendBucket.trend : null;

        // HEX-183: Fetch vendor-filtered trend data if vendor filter is active
        if (vendorFilter) {
            try {
                const vendorTrends = await this._fetchVendorTrends(vendorFilter);
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);

                if (vendorTrends && vendorTrends[severityKey]) {
                    // Replace trend data with vendor-filtered version
                    trendData = vendorTrends[severityKey].trend;
                }
            } catch (error) {
                console.error(`Failed to fetch vendor trends for ${severity}:`, error);
                // Fall back to global trends on error
            }
        }

        if (!trendData) return;

        const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
        const current = this.currentMetricType === "vpr" ? currentStat.total_vpr : currentStat.count;
        const previous = current - change;

        const iconEl = trendEl.querySelector("i");
        const badgeEl = trendEl.querySelector(".trend-value");

        if (!iconEl || !badgeEl) return;

        // HEX-183: Handle first upload edge case (no previous data)
        // If previous is 0 or very close to 0, show "N/A" instead of calculating percentage
        if (previous === 0 || Math.abs(previous) < 0.01) {
            iconEl.className = "ti ti-minus fs-3";
            badgeEl.textContent = "N/A";
            return;
        }

        // Calculate percentage change
        const percentage = Math.abs((change / previous) * 100);
        const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";

        // Cap percentage at reasonable maximum (999.9%) to prevent display overflow
        const displayPercentage = Math.min(percentage, 999.9);

        if (direction === "up") {
            iconEl.className = "ti ti-trending-up fs-3";
            badgeEl.textContent = `+${displayPercentage.toFixed(1)}%`;
        } else if (direction === "down") {
            iconEl.className = "ti ti-trending-down fs-3";
            badgeEl.textContent = `-${displayPercentage.toFixed(1)}%`;
        } else {
            iconEl.className = "ti ti-minus fs-3";
            badgeEl.textContent = "0%";
        }
    }

    /**
     * Fetches vendor-filtered trend data from backend API
     * HEX-183: Helper method to get vendor-specific trends
     * @param {string} vendorFilter - Vendor filter ('CISCO', 'Palo Alto', 'Other')
     * @returns {Promise<Object>} Trends data object with severity buckets
     * @private
     */
    async _fetchVendorTrends(vendorFilter) {
        const url = `/api/vulnerabilities/trends?vendor=${encodeURIComponent(vendorFilter)}`;
        const response = await authState.authenticatedFetch(url);

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const trends = await response.json();

        // Convert array format to object format matching this.trends structure
        // Backend returns: [{date, Critical: {}, High: {}, ...}, ...]
        // We need: {Critical: {current: {}, trend: {}}, High: {}, ...}

        if (!Array.isArray(trends) || trends.length === 0) {
            return {};
        }

        // HEX-183: Handle single upload case (no previous data to compare)
        if (trends.length === 1) {
            console.log("Only 1 data point - no trend comparison available");
            return {}; // Return empty, will trigger "N/A" display
        }

        const currentWeek = trends[trends.length - 1];
        const previousWeek = trends[trends.length - 2]; // Safe now due to length check above

        const result = {};
        const severities = ["Critical", "High", "Medium", "Low", "Info"];

        severities.forEach(severity => {
            const current = currentWeek[severity];
            const previous = previousWeek ? previousWeek[severity] : null;

            if (current) {
                const vprChange = previous ? (current.total_vpr - previous.total_vpr) : 0;
                const countChange = previous ? (current.count - previous.count) : 0;

                result[severity] = {
                    current: current,
                    trend: {
                        direction: vprChange > 0 ? "up" : vprChange < 0 ? "down" : "stable",
                        vpr_change: vprChange,
                        count_change: countChange
                    }
                };
            }
        });

        return result;
    }

    /**
     * Calculates trend between two values
     */
    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }

        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }

        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    /**
     * Updates chart with current metric type and data
     * HEX-117: Modified to use cached backend trends endpoint
     * HEX-156: Added vendor parameter for vendor-filtered trends
     * @param {Object} chart - ApexCharts instance to update
     * @param {boolean} bustCache - If true, append timestamp to bypass cache
     * @param {string|null} vendor - Optional vendor filter ('CISCO', 'Palo Alto', 'Other', or null for all)
     */
    async updateChart(chart, bustCache = false, vendor = null) {
        if (!chart) {
            return;
        }

        // HEX-156: Fetch trends from vendor-aware backend endpoint
        let historicalData;
        try {
            // Build vendor-aware API URL
            const vendorParam = vendor ? `vendor=${encodeURIComponent(vendor)}` : "";
            const cacheBustParam = bustCache ? `_t=${Date.now()}` : "";
            const params = [vendorParam, cacheBustParam].filter(p => p).join("&");
            const trendsUrl = `/api/vulnerabilities/trends${params ? "?" + params : ""}`;

            const response = await authState.authenticatedFetch(trendsUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            historicalData = await response.json();

            const vendorLabel = vendor ? ` (${vendor})` : "";
            console.log(`✅ Chart trends loaded from ${bustCache ? "fresh" : "cached"} backend endpoint${vendorLabel}`);
        } catch (error) {
            console.error("Failed to fetch trends from backend:", error);
            throw error;
        }

        if (!historicalData || historicalData.length === 0) {
            return;
        }

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        this.currentMetricType = metricType;

        const extendedData = this.dataManager.extendTimelineData(historicalData);
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date + 'T00:00:00').getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        chart.updateSeries(series);

        setTimeout(() => {
            if (chart && chart.resetSeries) {
                chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date + 'T00:00:00').toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        if (value && value > 0) {
                            const color = colors[index];
                            tooltipContent += `
                                <div class="tooltip-row">
                                    <span class="color-indicator" style="background-color: ${color}"></span>
                                    <span class="severity-name">${severity}:</span>
                                    <span class="severity-value">${metricType === "vpr" ? value.toFixed(2) : value.toFixed(0)}</span>
                                </div>`;
                        }
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        this.dispatchEvent(new CustomEvent("chartUpdated", {
            detail: { series, metricType, extendedData }
        }));
    }

    /**
     * Get current metric type
     */
    getCurrentMetricType() {
        return this.currentMetricType;
    }

    /**
     * Set current metric type
     */
    setCurrentMetricType(metricType) {
        this.currentMetricType = metricType;
        this.dispatchEvent(new CustomEvent("metricTypeChanged", {
            detail: { metricType }
        }));
    }

    /**
     * Get current trends data
     */
    getTrends() {
        return this.trends;
    }

    /**
     * Set trends data
     */
    setTrends(trends) {
        this.trends = trends;
        this.dispatchEvent(new CustomEvent("trendsSet", {
            detail: { trends }
        }));
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Simple instant toggle for all 4 severity levels
     */
    flipStatCards() {
        const severities = ["critical", "high", "medium", "low"];

        severities.forEach(severity => {
            const statCard = document.querySelector(`.stat-card-enhanced[data-severity="${severity}"]`);
            if (!statCard) {return;}

            const cardFront = statCard.querySelector(".card-front");
            const cardBack = statCard.querySelector(".card-back");

            if (!cardFront || !cardBack) {return;}

            // Simple instant toggle - no animation
            if (cardFront.style.display !== "none") {
                cardFront.style.display = "none";
                cardBack.style.display = "block";
            } else {
                cardFront.style.display = "block";
                cardBack.style.display = "none";
            }
        });

        // Dispatch event for tracking/testing
        this.dispatchEvent(new CustomEvent("cardsFlipped", {
            detail: { timestamp: new Date().toISOString() }
        }));
    }

    /**
     * Setup keyboard shortcut for VPR weekly summary export (HEX-144)
     * Attaches Cmd+Shift+Click (Mac) or Ctrl+Shift+Click (Windows) listeners to all 4 VPR cards
     * Hidden power user feature for quick CSV export of weekly VPR totals
     *
     * @returns {void}
     *
     * @example
     * // Called after statistics update to ensure cards are rendered
     * statisticsManager.setupVprExportShortcut();
     */
    setupVprExportShortcut() {
        // BUG FIX: Only set up listeners once to prevent accumulation
        // updateStatisticsDisplay() calls this multiple times during page lifecycle
        if (this._exportShortcutInitialized) {
            return; // Already set up, skip
        }

        // Security check: Only enable for authenticated users
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("VPR export shortcut not enabled - user not authenticated");
            return;
        }

        const cards = document.querySelectorAll(".stat-card-enhanced[data-severity]");

        // Don't set flag if cards don't exist yet (DOM not ready)
        if (cards.length === 0) {
            console.warn("VPR cards not found yet, will retry on next stats update");
            return;
        }

        // BUG FIX: Bind ONCE before the loop, not inside it
        // Each .bind() creates a new function, so binding inside forEach
        // creates 4 different functions that can't be removed properly
        if (!this._handleCardClickBound) {
            this._handleCardClickBound = this._handleCardClick.bind(this);
        }

        cards.forEach(card => {
            // Add event listener using the single bound function
            card.addEventListener("click", this._handleCardClickBound);
        });

        this._exportShortcutInitialized = true; // Mark as initialized ONLY after successful setup
        console.log("✅ VPR export shortcut enabled (Cmd+Shift+Click or Ctrl+Shift+Click)");
    }

    /**
     * Handle card click event for export shortcuts (HEX-144, HEX-235)
     * Internal method bound to card click events
     *
     * Keyboard shortcuts:
     * - Cmd+Alt+Click (Mac) / Ctrl+Alt+Click (Win): Latest vs Previous (1-day)
     * - Cmd+Shift+Click (Mac) / Ctrl+Shift+Click (Win): 7-day comparison
     * - Alt+Shift+Click (opt+shift on Mac): 30-day comparison
     * - Normal click (no modifiers): Toggle card flip
     *
     * @private
     * @param {MouseEvent} event - Click event
     * @returns {void}
     */
    _handleCardClick(event) {
        const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
        const cmdOrCtrl = isMac ? event.metaKey : event.ctrlKey;
        const shift = event.shiftKey;
        const alt = event.altKey;

        // Latest vs Previous (1-day comparison)
        if (cmdOrCtrl && alt && !shift) {
            // Cmd+Alt+Click = latest vs previous
            event.preventDefault();
            event.stopPropagation();
            this.exportVprWeeklySummary();
            return;
        }

        // 7-Day comparison
        if (cmdOrCtrl && shift && !alt) {
            // Cmd+Shift+Click = 7-day comparison
            event.preventDefault();
            event.stopPropagation();
            this.exportVprHistoricalComparison(7);
            return;
        }

        // 30-Day comparison (HEX-235)
        if (alt && shift && !cmdOrCtrl) {
            // Alt+Shift+Click = 30-day comparison (opt+shift on Mac)
            event.preventDefault();
            event.stopPropagation();
            this.exportVprHistoricalComparison(30);
            return;
        }

        // Normal click - toggle metric type (no modifiers)
        // Card flip handled by CSS/HTML
    }

    /**
     * Aggregate VPR totals by vendor category from backend trends API
     * Fetches vendor-filtered trends to get BOTH current totals AND historical data
     * for accurate percentage change calculations (uses vulnerability_snapshots table)
     *
     * CSV EXPORT FIX: Previously used stats endpoint which only provided current totals,
     * forcing CSV export to use "All Vendors" percentage changes. Now fetches trends
     * to calculate vendor-specific percentage changes for accurate historical data.
     *
     * @param {string} vendorFilter - 'CISCO', 'Palo Alto', or 'Other'
     * @returns {Promise<Object>} Object with current totals and percentage changes:
     *   {
     *     current: {critical, high, medium, low},
     *     percentChanges: {critical, high, medium, low}
     *   }
     * @private
     */
    async _aggregateVprByVendor(vendorFilter) {
        try {
            // Fetch trends from backend API (not stats - we need historical data!)
            const url = `/api/vulnerabilities/trends?vendor=${encodeURIComponent(vendorFilter)}`;
            const response = await authState.authenticatedFetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const trends = await response.json();

            // Validate trends data
            if (!Array.isArray(trends) || trends.length === 0) {
                console.warn(`No trends data available for ${vendorFilter}`);
                return {
                    current: { critical: 0, high: 0, medium: 0, low: 0 },
                    currentCounts: { critical: 0, high: 0, medium: 0, low: 0 },
                    percentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                    countPercentChanges: { critical: 0, high: 0, medium: 0, low: 0 }
                };
            }

            // Get most recent (current week) and second most recent (previous week) data points
            const currentWeek = trends[trends.length - 1];
            const previousWeek = trends.length >= 2 ? trends[trends.length - 2] : null;

            // Extract current totals (both VPR and counts)
            const currentTotals = {
                critical: currentWeek.Critical?.total_vpr || 0,
                high: currentWeek.High?.total_vpr || 0,
                medium: currentWeek.Medium?.total_vpr || 0,
                low: currentWeek.Low?.total_vpr || 0
            };

            const currentCounts = {
                critical: currentWeek.Critical?.count || 0,
                high: currentWeek.High?.count || 0,
                medium: currentWeek.Medium?.count || 0,
                low: currentWeek.Low?.count || 0
            };

            // Calculate percentage changes for both VPR and counts
            const percentChanges = {};
            const countPercentChanges = {};
            const severities = ["critical", "high", "medium", "low"];

            severities.forEach(severity => {
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1); // "critical" -> "Critical"

                // VPR percentage changes
                const currentVpr = currentTotals[severity];
                const previousVpr = previousWeek ? (previousWeek[severityKey]?.total_vpr || 0) : 0;

                if (previousVpr === 0) {
                    percentChanges[severity] = currentVpr > 0 ? 100 : 0;
                } else {
                    percentChanges[severity] = ((currentVpr - previousVpr) / previousVpr) * 100;
                }

                // Count percentage changes
                const currentCount = currentCounts[severity];
                const previousCount = previousWeek ? (previousWeek[severityKey]?.count || 0) : 0;

                if (previousCount === 0) {
                    countPercentChanges[severity] = currentCount > 0 ? 100 : 0;
                } else {
                    countPercentChanges[severity] = ((currentCount - previousCount) / previousCount) * 100;
                }
            });

            // Validation logging
            console.log(`[Vendor Aggregation] ${vendorFilter}:`, {
                source: "backend trends API (vulnerability_snapshots)",
                currentTotals: currentTotals,
                currentCounts: currentCounts,
                percentChanges: percentChanges,
                countPercentChanges: countPercentChanges,
                dates: {
                    current: currentWeek.date,
                    previous: previousWeek?.date || "N/A"
                }
            });

            return {
                current: currentTotals,
                currentCounts: currentCounts,
                percentChanges: percentChanges,
                countPercentChanges: countPercentChanges,
                dates: {
                    current: currentWeek.date,
                    previous: previousWeek?.date || "N/A"
                }
            };
        } catch (error) {
            console.error(`Failed to fetch ${vendorFilter} trends from backend:`, error);

            // Return zeros on error (CSV export should not fail silently)
            return {
                current: { critical: 0, high: 0, medium: 0, low: 0 },
                currentCounts: { critical: 0, high: 0, medium: 0, low: 0 },
                percentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                countPercentChanges: { critical: 0, high: 0, medium: 0, low: 0 }
            };
        }
    }

    /**
     * Find historical snapshot within specified timeframe with graceful fallback
     * @param {Array} trends - Array of trend snapshots sorted by date (oldest to newest)
     * @param {number} daysBack - Target days back from current date (7, 30, etc.)
     * @returns {Object} Historical snapshot data with metadata
     * @private
     */
    _findHistoricalSnapshot(trends, daysBack) {
        if (!trends || trends.length === 0) {
            return {
                snapshot: null,
                isFallback: false,
                actualDaysBack: 0,
                note: "No data available"
            };
        }

        // Most recent snapshot (current)
        const currentSnapshot = trends[trends.length - 1];
        const currentDate = new Date(currentSnapshot.date + 'T00:00:00');

        // Calculate target date (current - daysBack)
        const targetDate = new Date(currentDate);
        targetDate.setDate(targetDate.getDate() - daysBack);

        // Find closest snapshot <= target date (search backwards from current)
        let historical = null;
        for (let i = trends.length - 1; i >= 0; i--) {
            const snapshotDate = new Date(trends[i].date + 'T00:00:00');
            if (snapshotDate <= targetDate) {
                historical = trends[i];
                break;
            }
        }

        // Graceful fallback: Use oldest available data if no data within timeframe
        if (!historical) {
            const oldestSnapshot = trends[0];
            const actualDaysBack = Math.floor(
                (currentDate - new Date(oldestSnapshot.date + 'T00:00:00')) / (1000 * 60 * 60 * 24)
            );

            return {
                snapshot: oldestSnapshot,
                isFallback: true,
                actualDaysBack: actualDaysBack,
                note: actualDaysBack > 0
                    ? `Using oldest available data (${actualDaysBack} days)`
                    : "Only one data point available (0 days)"
            };
        }

        // Normal case: Found data within timeframe
        const actualDaysBack = Math.floor(
            (currentDate - new Date(historical.date + 'T00:00:00')) / (1000 * 60 * 60 * 24)
        );

        return {
            snapshot: historical,
            isFallback: false,
            actualDaysBack: actualDaysBack,
            note: null
        };
    }

    /**
     * Aggregate VPR totals by vendor with historical comparison
     * @param {string} vendorFilter - Vendor name to filter by
     * @param {number} daysBack - Days back for historical comparison (7, 30, etc.)
     * @returns {Promise<Object>} VPR aggregation with historical comparison
     * @private
     */
    async _aggregateVprByVendorHistorical(vendorFilter, daysBack) {
        try {
            // Fetch trends from backend API
            const url = `/api/vulnerabilities/trends?vendor=${encodeURIComponent(vendorFilter)}`;
            const response = await authState.authenticatedFetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const trends = await response.json();

            // Validate trends data
            if (!Array.isArray(trends) || trends.length === 0) {
                console.warn(`No trends data available for ${vendorFilter}`);
                return {
                    current: { critical: 0, high: 0, medium: 0, low: 0 },
                    currentCounts: { critical: 0, high: 0, medium: 0, low: 0 },
                    percentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                    countPercentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                    dates: {
                        current: "N/A",
                        previous: "N/A",
                        actualDaysBack: 0,
                        isFallback: false,
                        note: "No data available"
                    }
                };
            }

            // Get most recent (current) snapshot
            const currentWeek = trends[trends.length - 1];

            // Find historical snapshot using timeframe logic
            const historicalData = this._findHistoricalSnapshot(trends, daysBack);
            const previousWeek = historicalData.snapshot;

            // Extract current totals (both VPR and counts)
            const currentTotals = {
                critical: currentWeek.Critical?.total_vpr || 0,
                high: currentWeek.High?.total_vpr || 0,
                medium: currentWeek.Medium?.total_vpr || 0,
                low: currentWeek.Low?.total_vpr || 0
            };

            const currentCounts = {
                critical: currentWeek.Critical?.count || 0,
                high: currentWeek.High?.count || 0,
                medium: currentWeek.Medium?.count || 0,
                low: currentWeek.Low?.count || 0
            };

            // Calculate percentage changes for both VPR and counts
            const percentChanges = {};
            const countPercentChanges = {};
            const severities = ["critical", "high", "medium", "low"];

            severities.forEach(severity => {
                const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);

                // VPR percentage changes
                const currentVpr = currentTotals[severity];
                const previousVpr = previousWeek ? (previousWeek[severityKey]?.total_vpr || 0) : 0;

                if (previousVpr === 0) {
                    percentChanges[severity] = currentVpr > 0 ? 100 : 0;
                } else {
                    percentChanges[severity] = ((currentVpr - previousVpr) / previousVpr) * 100;
                }

                // Count percentage changes
                const currentCount = currentCounts[severity];
                const previousCount = previousWeek ? (previousWeek[severityKey]?.count || 0) : 0;

                if (previousCount === 0) {
                    countPercentChanges[severity] = currentCount > 0 ? 100 : 0;
                } else {
                    countPercentChanges[severity] = ((currentCount - previousCount) / previousCount) * 100;
                }
            });

            return {
                current: currentTotals,
                currentCounts: currentCounts,
                percentChanges: percentChanges,
                countPercentChanges: countPercentChanges,
                dates: {
                    current: currentWeek.date,
                    previous: previousWeek ? previousWeek.date : "N/A",
                    actualDaysBack: historicalData.actualDaysBack,
                    isFallback: historicalData.isFallback,
                    note: historicalData.note
                }
            };
        } catch (error) {
            console.error(`Failed to fetch ${vendorFilter} historical trends:`, error);

            // Return zeros on error
            return {
                current: { critical: 0, high: 0, medium: 0, low: 0 },
                currentCounts: { critical: 0, high: 0, medium: 0, low: 0 },
                percentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                countPercentChanges: { critical: 0, high: 0, medium: 0, low: 0 },
                dates: {
                    current: "N/A",
                    previous: "N/A",
                    actualDaysBack: 0,
                    isFallback: false,
                    note: "Error fetching data"
                }
            };
        }
    }

    /**
     * Format vendor VPR totals into CSV table rows (PREV UPLOAD, CURRENT UPLOAD, CHANGE)
     * @param {Object} currentTotals - Current period VPR totals by severity
     * @param {Object} percentChanges - Percentage changes from trend badges
     * @returns {string} Three CSV rows with vendor table data
     * @private
     */
    _formatVendorTable(currentTotals, percentChanges, dates) {
        const severities = ["critical", "high", "medium", "low"];

        // Calculate previous upload values using reverse percentage formula
        const prevTotals = {};
        severities.forEach(severity => {
            const current = currentTotals[severity] || 0;
            const pctChange = percentChanges[severity] || 0;
            const calculated = current / (1 + (pctChange / 100));

            // HEX-244: Guard against NaN from older CSV formats with missing critical values
            // The || 0 operator doesn't catch NaN (NaN || 0 = NaN), so we need explicit isNaN() check
            prevTotals[severity] = isNaN(calculated) ? 0 : calculated;
        });

        // Calculate totals
        const currentTotal = severities.reduce((sum, s) => sum + (currentTotals[s] || 0), 0);
        const prevTotal = severities.reduce((sum, s) => sum + (prevTotals[s] || 0), 0);
        const changeTotal = currentTotal - prevTotal;

        // Use actual scan dates if available, otherwise fall back to generic labels
        const prevLabel = dates?.previous || "PREV UPLOAD";
        const currentLabel = dates?.current || "CURRENT UPLOAD";

        // Format as CSV rows with date labels
        const prevRow = `${prevLabel},${severities.map(s => prevTotals[s].toFixed(1)).join(",")},${prevTotal.toFixed(1)}`;
        const currentRow = `${currentLabel},${severities.map(s => currentTotals[s].toFixed(1)).join(",")},${currentTotal.toFixed(1)}`;
        const changeRow = `CHANGE,${severities.map(s => ((currentTotals[s] || 0) - prevTotals[s]).toFixed(1)).join(",")},${changeTotal.toFixed(1)}`;

        return `${prevRow}\n${currentRow}\n${changeRow}`;
    }

    /**
     * Export VPR weekly summary to CSV with vendor breakdown (HEX-144, HEX-149)
     * Extracts current VPR values and percentage changes from stat cards,
     * calculates previous upload values, and generates 4-table CSV download:
     * 1. Overall VPR Totals (all devices)
     * 2. CISCO Devices (vendor-filtered)
     * 3. Palo Alto Devices (vendor-filtered)
     * 4. Other Devices (remaining/unmatched)
     *
     * CSV Format (4 tables separated by blank lines):
     * OVERALL VPR TOTALS
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * PREV UPLOAD,148.0,23222.0,18689.9,1484.9,43544.8
     * CURRENT UPLOAD,203.2,23216.7,24452.7,1483.9,49356.5
     * CHANGE,55.2,-5.3,5762.8,-1.0,5811.7
     *
     * CISCO DEVICES
     * PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL
     * ... (vendor-specific rows)
     *
     * @returns {void}
     *
     * @example
     * statisticsManager.exportVprWeeklySummary();
     * // Downloads: vpr-vendor-breakdown-2025-10-07.csv
     */
    async exportVprWeeklySummary() {
        // Security check
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("Export aborted - user not authenticated");
            return;
        }

        const severities = ["critical", "high", "medium", "low"];

        // BUG FIX: Fetch vendor totals from trends API (not dataManager.getStatistics())
        // This ensures we compare scan DATES not upload timestamps
        // Fetching all 3 vendors in parallel for efficiency
        const [ciscoData, paloData, otherData] = await Promise.all([
            this._aggregateVprByVendor("CISCO"),
            this._aggregateVprByVendor("Palo Alto"),
            this._aggregateVprByVendor("Other")
        ]);

        // Destructure vendor-specific totals (VPR and counts), percentage changes, and dates
        const {
            current: ciscoTotals,
            currentCounts: ciscoCounts,
            percentChanges: ciscoPctChanges,
            countPercentChanges: ciscoCountPctChanges,
            dates: ciscoDates
        } = ciscoData;

        const {
            current: paloTotals,
            currentCounts: paloCounts,
            percentChanges: paloPctChanges,
            countPercentChanges: paloCountPctChanges,
            dates: paloDates
        } = paloData;

        const {
            current: otherTotals,
            currentCounts: otherCounts,
            percentChanges: otherPctChanges,
            countPercentChanges: otherCountPctChanges,
            dates: otherDates
        } = otherData;

        // Aggregate overall totals from all three vendors
        const overallTotals = {};
        const overallCounts = {};
        severities.forEach(severity => {
            overallTotals[severity] = (ciscoTotals[severity] || 0) + (paloTotals[severity] || 0) + (otherTotals[severity] || 0);
            overallCounts[severity] = (ciscoCounts[severity] || 0) + (paloCounts[severity] || 0) + (otherCounts[severity] || 0);
        });

        // Calculate overall percentage changes
        const overallPctChanges = {};
        const overallCountPctChanges = {};
        severities.forEach(severity => {
            // For percentage changes, we need to calculate from the aggregated current and previous values
            // Using cisco dates as reference (all vendors should have same dates)
            const currentTotal = overallTotals[severity];
            const currentCount = overallCounts[severity];

            // We can't simply average the percentage changes - need to calculate from totals
            // But we don't have previous totals readily available, so we'll use the aggregated changes
            // This is approximate but sufficient for the CSV report
            const totalCurrentVpr = (ciscoTotals[severity] || 0) + (paloTotals[severity] || 0) + (otherTotals[severity] || 0);
            const totalCurrentCount = (ciscoCounts[severity] || 0) + (paloCounts[severity] || 0) + (otherCounts[severity] || 0);

            // Calculate weighted average of percentage changes
            const vprWeights = [
                ciscoTotals[severity] || 0,
                paloTotals[severity] || 0,
                otherTotals[severity] || 0
            ];
            const countWeights = [
                ciscoCounts[severity] || 0,
                paloCounts[severity] || 0,
                otherCounts[severity] || 0
            ];

            const totalVprWeight = vprWeights.reduce((sum, w) => sum + w, 0);
            const totalCountWeight = countWeights.reduce((sum, w) => sum + w, 0);

            if (totalVprWeight > 0) {
                overallPctChanges[severity] = (
                    (ciscoPctChanges[severity] * vprWeights[0] / totalVprWeight) +
                    (paloPctChanges[severity] * vprWeights[1] / totalVprWeight) +
                    (otherPctChanges[severity] * vprWeights[2] / totalVprWeight)
                );
            } else {
                overallPctChanges[severity] = 0;
            }

            if (totalCountWeight > 0) {
                overallCountPctChanges[severity] = (
                    (ciscoCountPctChanges[severity] * countWeights[0] / totalCountWeight) +
                    (paloCountPctChanges[severity] * countWeights[1] / totalCountWeight) +
                    (otherCountPctChanges[severity] * countWeights[2] / totalCountWeight)
                );
            } else {
                overallCountPctChanges[severity] = 0;
            }
        });

        // Use cisco dates as reference (all vendors should have same scan dates)
        const reportDates = ciscoDates;

        // Build side-by-side CSV with VPR tables on left, Count tables on right (2-cell spacing)
        let csvContent = "";
        const spacing = ",,"; // 2 empty cells

        // Helper to merge VPR and Count table rows side-by-side
        const mergeTables = (vprRows, countRows) => {
            return vprRows.map((vprRow, index) => {
                const countRow = countRows[index] || "";
                return `${vprRow}${spacing}${countRow}`;
            }).join("\n");
        };

        // Table 1: Overall VPR and Count Totals
        const overallVprHeader = "OVERALL VPR TOTALS,,,,," + spacing + "OVERALL VULNERABILITY COUNTS";
        const overallHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const overallVprRows = this._formatVendorTable(overallTotals, overallPctChanges, reportDates).split("\n");
        const overallCountRows = this._formatVendorTable(overallCounts, overallCountPctChanges, reportDates).split("\n");

        csvContent += overallVprHeader + "\n";
        csvContent += overallHeaders + "\n";
        csvContent += mergeTables(overallVprRows, overallCountRows) + "\n\n";

        // Table 2: CISCO Devices VPR and Counts
        const ciscoVprHeader = "CISCO DEVICES (VPR),,,,," + spacing + "CISCO DEVICES (COUNTS)";
        const ciscoHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const ciscoVprRows = this._formatVendorTable(ciscoTotals, ciscoPctChanges, ciscoDates).split("\n");
        const ciscoCountRows = this._formatVendorTable(ciscoCounts, ciscoCountPctChanges, ciscoDates).split("\n");

        csvContent += ciscoVprHeader + "\n";
        csvContent += ciscoHeaders + "\n";
        csvContent += mergeTables(ciscoVprRows, ciscoCountRows) + "\n\n";

        // Table 3: Palo Alto Devices VPR and Counts
        const paloVprHeader = "PALO ALTO DEVICES (VPR),,,,," + spacing + "PALO ALTO DEVICES (COUNTS)";
        const paloHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const paloVprRows = this._formatVendorTable(paloTotals, paloPctChanges, paloDates).split("\n");
        const paloCountRows = this._formatVendorTable(paloCounts, paloCountPctChanges, paloDates).split("\n");

        csvContent += paloVprHeader + "\n";
        csvContent += paloHeaders + "\n";
        csvContent += mergeTables(paloVprRows, paloCountRows) + "\n\n";

        // Table 4: Other Devices VPR and Counts
        const otherVprHeader = "OTHER DEVICES (VPR),,,,," + spacing + "OTHER DEVICES (COUNTS)";
        const otherHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const otherVprRows = this._formatVendorTable(otherTotals, otherPctChanges, otherDates).split("\n");
        const otherCountRows = this._formatVendorTable(otherCounts, otherCountPctChanges, otherDates).split("\n");

        csvContent += otherVprHeader + "\n";
        csvContent += otherHeaders + "\n";
        csvContent += mergeTables(otherVprRows, otherCountRows);

        // Download with updated filename
        const dateStr = new Date().toISOString().split("T")[0];
        this.downloadCSV(csvContent, `vpr-vendor-breakdown-${dateStr}`);

        console.log("✅ VPR vendor breakdown exported with side-by-side counts (using backend API for consistency)");
    }

    /**
     * Export VPR historical comparison (7-day or 30-day trends)
     * @param {number} daysBack - Days back for comparison (7, 30, etc.)
     * @public
     */
    async exportVprHistoricalComparison(daysBack) {
        // Security check
        if (typeof authState === "undefined" || !authState.isAuthenticated()) {
            console.warn("Export aborted - user not authenticated");
            return;
        }

        const severities = ["critical", "high", "medium", "low"];

        // Fetch historical data for all 3 vendors in parallel
        const [ciscoData, paloData, otherData] = await Promise.all([
            this._aggregateVprByVendorHistorical("CISCO", daysBack),
            this._aggregateVprByVendorHistorical("Palo Alto", daysBack),
            this._aggregateVprByVendorHistorical("Other", daysBack)
        ]);

        // Destructure vendor-specific totals (VPR and counts), percentage changes, and dates
        const {
            current: ciscoTotals,
            currentCounts: ciscoCounts,
            percentChanges: ciscoPctChanges,
            countPercentChanges: ciscoCountPctChanges,
            dates: ciscoDates
        } = ciscoData;

        const {
            current: paloTotals,
            currentCounts: paloCounts,
            percentChanges: paloPctChanges,
            countPercentChanges: paloCountPctChanges,
            dates: paloDates
        } = paloData;

        const {
            current: otherTotals,
            currentCounts: otherCounts,
            percentChanges: otherPctChanges,
            countPercentChanges: otherCountPctChanges,
            dates: otherDates
        } = otherData;

        // Aggregate overall totals from all three vendors
        const overallTotals = {};
        const overallCounts = {};
        severities.forEach(severity => {
            overallTotals[severity] = (ciscoTotals[severity] || 0) + (paloTotals[severity] || 0) + (otherTotals[severity] || 0);
            overallCounts[severity] = (ciscoCounts[severity] || 0) + (paloCounts[severity] || 0) + (otherCounts[severity] || 0);
        });

        // Calculate overall percentage changes (weighted average)
        const overallPctChanges = {};
        const overallCountPctChanges = {};
        severities.forEach(severity => {
            const vprWeights = [
                ciscoTotals[severity] || 0,
                paloTotals[severity] || 0,
                otherTotals[severity] || 0
            ];
            const countWeights = [
                ciscoCounts[severity] || 0,
                paloCounts[severity] || 0,
                otherCounts[severity] || 0
            ];

            const totalVprWeight = vprWeights.reduce((sum, w) => sum + w, 0);
            const totalCountWeight = countWeights.reduce((sum, w) => sum + w, 0);

            if (totalVprWeight > 0) {
                overallPctChanges[severity] = (
                    (ciscoPctChanges[severity] * vprWeights[0] / totalVprWeight) +
                    (paloPctChanges[severity] * vprWeights[1] / totalVprWeight) +
                    (otherPctChanges[severity] * vprWeights[2] / totalVprWeight)
                );
            } else {
                overallPctChanges[severity] = 0;
            }

            if (totalCountWeight > 0) {
                overallCountPctChanges[severity] = (
                    (ciscoCountPctChanges[severity] * countWeights[0] / totalCountWeight) +
                    (paloCountPctChanges[severity] * countWeights[1] / totalCountWeight) +
                    (otherCountPctChanges[severity] * countWeights[2] / totalCountWeight)
                );
            } else {
                overallCountPctChanges[severity] = 0;
            }
        });

        // Use cisco dates as reference (all vendors should have same dates)
        const reportDates = ciscoDates;

        // Build CSV header with timeframe info
        const timeframeName = daysBack === 7 ? "WEEKLY" : "MONTHLY";
        const fallbackSuffix = reportDates.isFallback
            ? ` - LIMITED DATA`
            : "";

        let csvContent = `${timeframeName} VPR COMPARISON (${daysBack} DAYS${fallbackSuffix})\n`;
        csvContent += `Date Range: ${reportDates.previous} to ${reportDates.current}\n`;
        if (reportDates.note) {
            csvContent += `Note: ${reportDates.note}\n`;
        }
        csvContent += `\n`; // Blank line before tables

        // Build side-by-side CSV with VPR tables on left, Count tables on right (2-cell spacing)
        const spacing = ",,"; // 2 empty cells

        // Helper to merge VPR and Count table rows side-by-side
        const mergeTables = (vprRows, countRows) => {
            return vprRows.map((vprRow, index) => {
                const countRow = countRows[index] || "";
                return `${vprRow}${spacing}${countRow}`;
            }).join("\n");
        };

        // Table 1: Overall VPR and Count Totals
        const overallVprHeader = "OVERALL VPR TOTALS,,,,," + spacing + "OVERALL VULNERABILITY COUNTS";
        const overallHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const overallVprRows = this._formatVendorTable(overallTotals, overallPctChanges, reportDates).split("\n");
        const overallCountRows = this._formatVendorTable(overallCounts, overallCountPctChanges, reportDates).split("\n");

        csvContent += overallVprHeader + "\n";
        csvContent += overallHeaders + "\n";
        csvContent += mergeTables(overallVprRows, overallCountRows) + "\n\n";

        // Table 2: CISCO Devices VPR and Counts
        const ciscoVprHeader = "CISCO DEVICES (VPR),,,,," + spacing + "CISCO DEVICES (COUNTS)";
        const ciscoHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const ciscoVprRows = this._formatVendorTable(ciscoTotals, ciscoPctChanges, ciscoDates).split("\n");
        const ciscoCountRows = this._formatVendorTable(ciscoCounts, ciscoCountPctChanges, ciscoDates).split("\n");

        csvContent += ciscoVprHeader + "\n";
        csvContent += ciscoHeaders + "\n";
        csvContent += mergeTables(ciscoVprRows, ciscoCountRows) + "\n\n";

        // Table 3: Palo Alto Devices VPR and Counts
        const paloVprHeader = "PALO ALTO DEVICES (VPR),,,,," + spacing + "PALO ALTO DEVICES (COUNTS)";
        const paloHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const paloVprRows = this._formatVendorTable(paloTotals, paloPctChanges, paloDates).split("\n");
        const paloCountRows = this._formatVendorTable(paloCounts, paloCountPctChanges, paloDates).split("\n");

        csvContent += paloVprHeader + "\n";
        csvContent += paloHeaders + "\n";
        csvContent += mergeTables(paloVprRows, paloCountRows) + "\n\n";

        // Table 4: Other Devices VPR and Counts
        const otherVprHeader = "OTHER DEVICES (VPR),,,,," + spacing + "OTHER DEVICES (COUNTS)";
        const otherHeaders = "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL" + spacing + "PERIOD,CRITICAL,HIGH,MEDIUM,LOW,TOTAL";
        const otherVprRows = this._formatVendorTable(otherTotals, otherPctChanges, otherDates).split("\n");
        const otherCountRows = this._formatVendorTable(otherCounts, otherCountPctChanges, otherDates).split("\n");

        csvContent += otherVprHeader + "\n";
        csvContent += otherHeaders + "\n";
        csvContent += mergeTables(otherVprRows, otherCountRows);

        // Download with descriptive filename including timeframe and dates
        const filename = `HexTrackr_VPR_${timeframeName}_${daysBack}day_${reportDates.previous}_to_${reportDates.current}`;
        this.downloadCSV(csvContent, filename);

        console.log(`✅ VPR ${timeframeName} comparison (${daysBack} days) exported: ${reportDates.previous} to ${reportDates.current}`);
    }

    /**
     * Download data as CSV file (HEX-144, HEX-149)
     * Generates CSV from 2D array or string and triggers browser download
     *
     * @param {Array<Array<string|number>>|string} data - 2D array of CSV data or pre-formatted CSV string
     * @param {string} filename - Base filename (without extension or timestamp)
     * @returns {void}
     *
     * @example
     * // Array format
     * statisticsManager.downloadCSV([
     *   ["Name", "Value"],
     *   ["Item 1", 100]
     * ], "my-data");
     *
     * // String format
     * statisticsManager.downloadCSV("Name,Value\nItem 1,100", "my-data");
     * // Downloads: my-data-2025-10-07.csv
     */
    downloadCSV(data, filename) {
        // Convert 2D array to CSV string if needed
        const csvContent = Array.isArray(data)
            ? data.map(row => row.join(",")).join("\n")
            : data;

        // Create Blob with UTF-8 BOM for Excel compatibility
        const BOM = "\uFEFF";
        const blob = new Blob([BOM + csvContent], { type: "text/csv;charset=utf-8;" });

        // Create download link
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
        link.href = URL.createObjectURL(blob);
        link.download = `${filename}-${timestamp}.csv`;

        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Clean up object URL
        URL.revokeObjectURL(link.href);
    }
}

if (typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityStatisticsManager;
}
