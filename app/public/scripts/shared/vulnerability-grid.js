/**
 * @fileoverview VulnerabilityGridManager - Handles all AG Grid operations and configurations
 * Extracted from ModernVulnManager as part of Phase 2 modularization
 * 
 * @version 2.1.0 - Dark Mode Integration (T028)
 * @author Claude
 * @date 2025-09-12
 * @spec 005-dark-mode-theme-system
 */

/* eslint-env browser, es6 */
/* global agGrid, createVulnerabilityGridOptions, document */
/* exported VulnerabilityGridManager */

/**
 * Manages all AG Grid operations for vulnerability data display
 */
class VulnerabilityGridManager {
    constructor(dataManager, componentContext) {
        this.dataManager = dataManager;
        this.componentContext = componentContext; // Reference to parent component for callbacks
        this.gridApi = null;

        // Removed ChartThemeAdapter to fix double registration issue
        // AGGridThemeManager handles all theme management centrally

        this.setupDataManagerListeners();
    }

    /**
     * Setup data manager event listeners for grid updates
     */
    setupDataManagerListeners() {
        // Listen for filtered data changes to update grid
        this.dataManager.on("dataFiltered", (data) => {
            if (this.gridApi) {
                this.gridApi.setGridOption("rowData", data.filteredVulnerabilities);
            }
        });
    }

    /**
     * Detect current theme mode
     * @returns {boolean} True if dark mode is active
     */
    detectCurrentThemeMode() {
        try {
            // Check theme controller first (most reliable)
            if (window.ThemeController && window.ThemeController.getCurrentTheme) {
                return window.ThemeController.getCurrentTheme() === "dark";
            }
            
            // Check document data-bs-theme attribute
            const documentTheme = document.documentElement.getAttribute("data-bs-theme");
            if (documentTheme) {
                return documentTheme === "dark";
            }
            
            // Check for dark class
            if (document.documentElement.classList.contains("theme-dark")) {
                return true;
            }
            
            // Check localStorage as fallback
            const storedTheme = localStorage.getItem("theme");
            if (storedTheme) {
                return storedTheme === "dark";
            }
            
            // Default to light mode
            return false;
        } catch (error) {
            console.warn("Error detecting theme mode:", error);
            return false; // Default to light mode on error
        }
    }

    /**
     * Initialize the main vulnerability grid with theme support - T028
     */
    initializeGrid() {
        // Detect current theme before creating grid options
        const isDarkMode = this.detectCurrentThemeMode();

        console.log(`ðŸŽ¨ Initializing grid with ${isDarkMode ? "dark" : "light"} mode theme`);

        // Pass true for usePagination to enable built-in AG-Grid pagination
        const gridOptions = createVulnerabilityGridOptions(this.componentContext, isDarkMode, true);
        const gridDiv = document.getElementById("vulnGrid");
        
        if (this.gridApi) {
            // Unregister from AGGridThemeManager before destroying
            if (window.agGridThemeManager) {
                window.agGridThemeManager.unregisterGrid("vulnGrid");
            }
            
            this.gridApi.destroy();
        }

        this.gridApi = agGrid.createGrid(gridDiv, gridOptions);

        // Register grid with centralized AGGridThemeManager only (fixed double registration)
        if (this.gridApi && window.agGridThemeManager) {
            window.agGridThemeManager.registerGrid("vulnGrid", this.gridApi, gridDiv);
        }
    }

    /**
     * Update grid data for the current view
     * @param {string} viewType - The current view type ('table', 'devices', 'vulnerabilities')
     */
    updateForCurrentView(viewType) {
        if (viewType === "table") {
            if (this.gridApi) {
                this.gridApi.setGridOption("rowData", this.dataManager.getFilteredVulnerabilities());
            }
        }
    }

    /**
     * Create and render assets grid in vulnerability details modal
     * @param {Object} vulnerability - The vulnerability object
     */
    createAssetsGrid(vulnerability) {
        const affectedAssets = this.dataManager.getAllVulnerabilities().filter(v => v.cve === vulnerability.cve);
        document.getElementById("affectedAssetsCount").textContent = `${affectedAssets.length} assets`;

        const assetsGridDiv = document.getElementById("vulnerabilityAssetsGrid");
        assetsGridDiv.innerHTML = "";

        const assetsColumnDefs = this.createAssetsColumnDefinitions();
        const assetsGridOptions = this.createAssetsGridOptions(assetsColumnDefs, affectedAssets);

        agGrid.createGrid(assetsGridDiv, assetsGridOptions);
    }

    /**
     * Create column definitions for the assets grid
     * @returns {Array} Array of column definitions
     */
    createAssetsColumnDefinitions() {
        return [
            {
                headerName: "Hostname",
                field: "hostname",
                width: 200,
                cellRenderer: (params) => {
                    const hostname = params.value;
                    return `<a href="#" class="text-primary text-decoration-none fw-bold" onclick="vulnManager.viewDeviceDetails('${hostname}'); return false;">${hostname}</a>`;
                }
            },
            {
                headerName: "Port",
                field: "port",
                width: 100,
                cellRenderer: (params) => {
                    return `<span class="badge bg-secondary">${params.value || "N/A"}</span>`;
                }
            },
            {
                headerName: "First Seen",
                field: "first_seen",
                width: 150,
                cellRenderer: (params) => {
                    return params.value ? new Date(params.value).toLocaleDateString() : "N/A";
                }
            },
            {
                headerName: "Last Seen",
                field: "last_seen",
                width: 150,
                cellRenderer: (params) => {
                    const lastSeen = params.data.last_seen;
                    const scanDate = params.data.scan_date;
                    
                    if (lastSeen && lastSeen.trim() !== "") {
                        return new Date(lastSeen).toLocaleDateString();
                    } else if (scanDate && scanDate.trim() !== "") {
                        return new Date(scanDate).toLocaleDateString();
                    }
                    return "N/A";
                }
            },
            { 
                headerName: "Plugin Output", 
                field: "plugin_output", 
                flex: 1 
            }
        ];
    }

    /**
     * Create grid options for the assets grid
     * @param {Array} columnDefs - Column definitions
     * @param {Array} rowData - Row data
     * @returns {Object} Grid options object
     */
    createAssetsGridOptions(columnDefs, rowData) {
        // Get current theme for assets grid
        const isDarkMode = this.detectCurrentThemeMode();
        
        // Create proper AG-Grid v33 Quartz theme configuration
        let quartzTheme = null;
        if (typeof window.agGrid !== "undefined" && window.agGrid.themeQuartz) {
            if (isDarkMode) {
                // Updated dark theme to match user's navy design with EXACT colors
                quartzTheme = window.agGrid.themeQuartz.withParams({
                    backgroundColor: "#0F1C31", // Dark navy background - EXACT
                    foregroundColor: "#FFF", // Pure white text for better contrast
                    browserColorScheme: "dark",
                    chromeBackgroundColor: "#202c3f", // EXACT header color (no mixing function)
                    headerBackgroundColor: "#202c3f", // EXACT header color #202c3f as specified
                    headerTextColor: "#FFF",
                    headerFontSize: 14,
                    oddRowBackgroundColor: "rgba(255, 255, 255, 0.02)",
                    rowBorder: false,
                    headerRowBorder: false,
                    columnBorder: false,
                    borderColor: "#2a3f5f", // Subtle navy border
                    selectedRowBackgroundColor: "#2563eb", // Bright blue for selection
                    rowHoverColor: "rgba(37, 99, 235, 0.15)", // Blue hover effect
                    rangeSelectionBackgroundColor: "rgba(37, 99, 235, 0.2)"
                });
            } else {
                quartzTheme = window.agGrid.themeQuartz.withParams({
                    backgroundColor: "#ffffff",
                    foregroundColor: "#2d3748",
                    chromeBackgroundColor: "#f7fafc",
                    headerBackgroundColor: "#edf2f7",
                    headerTextColor: "#2d3748",
                    oddRowBackgroundColor: "rgba(0, 0, 0, 0.02)",
                    rowBorder: false,
                    headerRowBorder: false,
                    columnBorder: false,
                    borderColor: "#e2e8f0",
                    selectedRowBackgroundColor: "#3182ce",
                    rowHoverColor: "rgba(49, 130, 206, 0.1)",
                    rangeSelectionBackgroundColor: "rgba(49, 130, 206, 0.2)"
                });
            }
        }

        return {
            theme: quartzTheme, // AG-Grid v33 proper Quartz theme configuration
            columnDefs: columnDefs,
            rowData: rowData,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 15,
            animateRows: true
        };
    }


    /**
     * Forces a redraw of the grid to apply theme changes.
     */
    forceGridRedraw() {
        if (this.gridApi) {
            this.gridApi.redrawRows();
            this.gridApi.refreshHeader();
        }
    }

    /**
     * Get the current grid API instance
     * @returns {Object} The AG Grid API instance
     */
    getGridApi() {
        return this.gridApi;
    }

    /**
     * Destroy the current grid instance
     */
    destroy() {
        if (this.gridApi) {
            this.gridApi.destroy();
            this.gridApi = null;
        }
    }

    /**
     * Refresh grid data
     */
    refreshData() {
        if (this.gridApi) {
            this.gridApi.setGridOption("rowData", this.dataManager.getFilteredVulnerabilities());
        }
    }

    /**
     * Update pagination information (called by AG Grid events)
     * @param {number} totalRows - Total number of rows
     * @param {number} currentPage - Current page number (0-indexed) 
     * @param {number} pageSize - Number of rows per page
     */
    updatePaginationInfo(totalRows, currentPage, pageSize) {
        // This method is called by the AG Grid pagination handler
        // to update any custom pagination displays with actual counts
        console.log(`Pagination updated: ${totalRows} total rows, page ${currentPage + 1}, ${pageSize} per page`);
        
        // The AG Grid handles the pagination display automatically
        // This method is here for future custom pagination implementations
    }

    /**
     * Update grid theme dynamically - T028
     * @param {string} newTheme - New theme to apply ('light' | 'dark')
     * @returns {boolean} Success status
     */
    updateTheme(newTheme) {
        try {
            console.log(`ðŸŽ¨ Updating grid theme to ${newTheme} mode`);
            
            // Store current data
            const currentData = [];
            if (this.gridApi) {
                const rowCount = this.gridApi.getDisplayedRowCount();
                for (let i = 0; i < rowCount; i++) {
                    const rowNode = this.gridApi.getDisplayedRowAtIndex(i);
                    if (rowNode) {
                        currentData.push(rowNode.data);
                    }
                }
            }
            
            // Recreate grid with new theme - this is the proper v33 approach
            this.initializeGrid();
            
            // Restore data
            if (currentData.length > 0 && this.gridApi) {
                this.gridApi.setGridOption("rowData", currentData);
            }
            
            console.log(`âœ… Grid theme successfully updated to ${newTheme}`);
            return true;
        } catch (error) {
            console.error("Error updating grid theme:", error);
            return false;
        }
    }

    /**
     * Get current theme adapter instance - DEPRECATED
     * @returns {null} Always returns null (adapter removed to fix double registration)
     * @deprecated Use AGGridThemeManager instead
     */
    getThemeAdapter() {
        return null;  // Removed to fix double registration issue
    }

    /**
     * Check if grid has theme support - uses AGGridThemeManager
     * @returns {boolean} True if theme manager is available
     */
    hasThemeSupport() {
        return window.agGridThemeManager !== null && window.agGridThemeManager !== undefined;
    }
}

// Global export for browser usage
window.VulnerabilityGridManager = VulnerabilityGridManager;

// ES6 module export (dual export pattern for compatibility)
try {
  if (typeof module !== "undefined" && module.exports) {
    module.exports = { VulnerabilityGridManager };
  }
  // ES6 export for import statements
  if (typeof exports !== "undefined") {
    exports.VulnerabilityGridManager = VulnerabilityGridManager;
  }
} catch (_error) {
  // Silently ignore if module system not available
  console.debug("Module export not available, using global window export");
}