/**
 * @fileoverview VulnerabilityCardsManager - Handles device and vulnerability card rendering
 * Extracted from ModernVulnManager as part of Phase 2 modularization
 * @version 2.0.0
 * @author HexTrackr Team
 * @date 2025-09-08
 */

/* eslint-env browser, es6 */
/* global window, document, Sortable, CVEUtilities */
/* exported VulnerabilityCardsManager */

/**
 * Manages device cards and vulnerability cards rendering with pagination
 */
class VulnerabilityCardsManager {
    constructor(dataManager, devicePagination, vulnerabilityPagination, componentContext) {
        this.dataManager = dataManager;
        this.devicePagination = devicePagination;
        this.vulnerabilityPagination = vulnerabilityPagination;
        this.componentContext = componentContext; // Reference to parent component for callbacks
        this.deviceSortMode = "vpr-first"; // HEX-204: Default sort mode (VPR First)
        this.vulnerabilitySortMode = "vpr-first"; // HEX-204: Default sort mode for vulnerabilities (VPR First)
    }

    /**
     * Check ticket state for a device hostname
     * HEX-203: Bidirectional device-to-ticket navigation
     * @param {string} hostname - Device hostname to check
     * @returns {Promise<Object>} {count: number, tickets: Array, mostRecentStatus: string}
     * @since 1.0.57
     */
    async checkTicketState(hostname) {
        try {
            const response = await fetch(`/api/tickets/by-device/${encodeURIComponent(hostname)}`);
            if (!response.ok) {
                logger.warn(`Failed to fetch tickets for ${hostname}:`, response.statusText);
                return { count: 0, tickets: [], mostRecentStatus: null };
            }

            const data = await response.json();
            return {
                count: data.count || 0,
                tickets: data.tickets || [],
                mostRecentStatus: data.tickets && data.tickets.length > 0 ? data.tickets[0].status : null
            };
        } catch (error) {
            logger.error(`Error checking ticket state for ${hostname}:`, error);
            return { count: 0, tickets: [], mostRecentStatus: null };
        }
    }

    /**
     * Get button configuration based on ticket count, status, and job type
     * HEX-203: Dynamic button states (0/1/2+ tickets) with proper color mapping
     * @param {number} count - Number of open tickets
     * @param {string} status - Most recent ticket status
     * @param {string} jobType - Job type for color coding
     * @returns {Object} {text: string, colorClass: string, icon: string, textColorClass: string}
     * @since 1.0.57
     */
    getButtonConfig(count, status, jobType = null) {
        // Status to Bootstrap color mapping (matches tickets.css actual statuses)
        const statusColors = {
            "Pending": "warning",      // Amber yellow
            "Staged": "info",          // Purple (using info as closest Bootstrap match)
            "Open": "primary",         // Blue
            "Overdue": "danger",       // Red
            "Completed": "success",    // Green
            "Failed": "danger",        // Orange-red
            "Closed": "secondary"      // Gray
        };

        // Job type to status-label class mapping (for text color)
        const jobTypeTextColors = {
            "Upgrade": "status-open",      // Blue
            "Replace": "status-overdue",   // Orange/red
            "Refresh": "status-pending",   // Purple
            "Mitigate": "status-failed",   // Red
            "Other": "status-generic"      // Gray
        };

        if (count === 0) {
            return {
                text: "Create Ticket",
                colorClass: "btn-outline-success",
                icon: "fas fa-ticket-alt",
                textColorClass: ""
            };
        } else if (count === 1) {
            const colorClass = `btn-outline-${statusColors[status] || "primary"}`;
            const textColorClass = jobType ? `status-label ${jobTypeTextColors[jobType] || "status-generic"}` : "";
            return {
                text: "Open Ticket",
                colorClass: colorClass,
                icon: "fas fa-folder-open",
                textColorClass: textColorClass
            };
        } else {
            const colorClass = `btn-outline-${statusColors[status] || "primary"}`;
            const textColorClass = jobType ? `status-label ${jobTypeTextColors[jobType] || "status-generic"}` : "";
            return {
                text: `View Tickets (${count})`,
                colorClass: colorClass,
                icon: "fas fa-layer-group",
                textColorClass: textColorClass
            };
        }
    }

    /**
     * Generate cryptographically secure ID for vulnerability data storage.
     * Uses crypto.getRandomValues() for true randomness, with fallback for older browsers.
     * @param {string} prefix - ID prefix (e.g., 'vuln', 'device')
     * @returns {string} Secure ID in format: prefix-timestamp-secureRandom
     * @since 1.0.30
     */
    generateSecureVulnId(prefix) {
        // Check for crypto API availability (requires HTTPS or localhost)
        if (!window.crypto || !window.crypto.getRandomValues) {
            logger.warn("crypto.getRandomValues not available, using timestamp fallback");
            const timestamp = Date.now();
            const random = performance.now().toString(36).replace(".", "");
            return `${prefix}-${timestamp}-${random}`;
        }

        // Generate cryptographically secure random bytes
        const randomBytes = new Uint8Array(9);
        window.crypto.getRandomValues(randomBytes);
        const randomString = Array.from(randomBytes, byte =>
            byte.toString(36).padStart(2, "0")
        ).join("").substr(0, 9);

        return `${prefix}-${Date.now()}-${randomString}`;
    }

    /**
     * Handle create ticket button click with ticket state awareness (HEX-203)
     * Supports multiple modes:
     * - 0 tickets: Create new ticket (supports bulk creation with keyboard modifiers)
     * - 1 ticket: Open existing ticket directly
     * - 2+ tickets: Show picker modal
     *
     * Bulk creation modes (only when ticketCount === 0):
     * - Single click: Create ticket for one device
     * - Cmd+Shift+Click (Mac) or Ctrl+Shift+Click (Windows): Create ticket for KEV devices at location
     * - Alt+Shift+Click: Create ticket for all devices at location
     *
     * @param {MouseEvent} event - Click event with keyboard modifiers
     * @param {HTMLElement} button - The button element that was clicked
     * @returns {void}
     * @since v1.0.57
     */
    handleCreateTicketClick(event, button) {
        // Stop event propagation to prevent card click
        event.stopPropagation();

        // Read data from button attributes
        const hostname = button.dataset.hostname;
        const ticketCount = parseInt(button.dataset.ticketCount) || 0;
        const tickets = button.dataset.tickets ? JSON.parse(button.dataset.tickets) : [];

        logger.debug(`[Ticket Click] hostname=${hostname}, count=${ticketCount}, tickets=`, tickets);

        // HEX-203: Handle existing tickets first
        if (ticketCount === 1) {
            // Open the single ticket directly by navigating to tickets.html
            const ticketId = tickets[0].id;
            logger.debug(`[Ticket Navigation] Opening ticket ${ticketId} for device ${hostname}`);
            // Navigate to tickets page and open the ticket modal
            window.location.href = `/tickets.html?openTicket=${ticketId}`;
            return;
        } else if (ticketCount > 1) {
            // Show picker modal for multiple tickets
            logger.debug(`[Ticket Navigation] Showing picker for ${ticketCount} tickets on device ${hostname}`);
            this.showTicketPickerModal(hostname, tickets);
            return;
        }

        // Original behavior: Create new ticket (ticketCount === 0)

        // Parse hostname to extract SITE and Location (ALL CAPS)
        const site = hostname.substring(0, 4).toUpperCase();       // First 4 characters
        const location = hostname.substring(0, 5).toUpperCase();   // First 5 characters

        // Detect keyboard modifiers to determine mode
        let mode = "single";
        let deviceList = [hostname.toUpperCase()];

        // Mode 2: KEV devices at location (Cmd/Ctrl + Shift)
        if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            mode = "bulk-kev";

            // Get all filtered devices
            const allDevices = this.dataManager.getFilteredDevices();

            // Filter for KEV devices at same location (case-insensitive comparison)
            deviceList = allDevices
                .filter(device => device.hostname.toLowerCase().startsWith(location.toLowerCase()) && device.hasKev === true)
                .map(device => device.hostname.toUpperCase());
        }
        // Mode 3: All devices at location (Alt + Shift)
        else if (event.altKey && event.shiftKey) {
            mode = "bulk-all";

            // Get all filtered devices
            const allDevices = this.dataManager.getFilteredDevices();

            // Filter for all devices at same location (case-insensitive comparison)
            deviceList = allDevices
                .filter(device => device.hostname.toLowerCase().startsWith(location.toLowerCase()))
                .map(device => device.hostname.toUpperCase());
        }
        // Mode 1: Single device (default - no modifiers)

        // Console logging for debugging
        logger.debug("[Power Tool] Mode:", mode);
        logger.debug("[Power Tool] Site:", site);
        logger.debug("[Power Tool] Location:", location);
        logger.debug("[Power Tool] Devices:", deviceList);
        logger.debug("[Power Tool] Total Count:", deviceList.length);

        // Build options object for all modes
        const options = {
            devices: deviceList,
            site: site,
            location: location,
            mode: mode
        };

        // Call createTicketFromDevice with options for all modes
        if (this.componentContext && typeof this.componentContext.createTicketFromDevice === "function") {
            this.componentContext.createTicketFromDevice(hostname, options);
        } else {
            logger.error("[Power Tool] createTicketFromDevice method not found on componentContext");
        }
    }

    /**
     * Show ticket picker modal for devices with multiple open tickets
     * HEX-203: Handle edge case of 2+ tickets for one device
     * @param {string} hostname - Device hostname
     * @param {Array<Object>} tickets - Array of ticket objects (already fetched)
     * @returns {void}
     * @since 1.0.57
     */
    async showTicketPickerModal(hostname, tickets) {
        logger.debug(`[Ticket Picker] Opening picker for ${hostname} with ${tickets.length} tickets:`, tickets);

        const validTickets = tickets.filter(t => t !== null && t.id);
        logger.debug(`[Ticket Picker] Valid tickets: ${validTickets.length}`, validTickets);

        if (validTickets.length === 0) {
            logger.error(`[Ticket Picker] No valid tickets found for ${hostname}`);
            return;
        }

        // Build modal content
        const modalBody = document.getElementById("ticketPickerModalBody");
        if (!modalBody) {
            logger.error(`[Ticket Picker] Modal body element not found!`);
            return;
        }

        modalBody.innerHTML = `
            <p class="mb-3">
                <strong>${hostname}</strong> has <strong>${validTickets.length}</strong> open tickets. Which would you like to view?
            </p>
            <div class="list-group">
                ${validTickets.map(ticket => `
                    <button type="button" class="list-group-item list-group-item-action"
                            onclick="window.location.href='/tickets.html?openTicket=${ticket.id}';">
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-1">XT-${ticket.xt_number}</h6>
                                <small class="text-muted">${ticket.job_type || "Unknown"} â€¢ ${new Date(ticket.created_at).toLocaleDateString()}</small>
                            </div>
                            <span class="badge bg-${this.getStatusBadgeColor(ticket.status)}">${ticket.status}</span>
                        </div>
                    </button>
                `).join("")}
            </div>
            <hr>
            <button type="button" class="btn btn-success w-100"
                    onclick="vulnManager.cardsManager.componentContext.createTicketFromDevice('${hostname}'); bootstrap.Modal.getInstance(document.getElementById('ticketPickerModal')).hide();">
                <i class="fas fa-plus me-1"></i>Create New Ticket Anyway
            </button>
        `;

        // Show the modal
        const modalElement = document.getElementById("ticketPickerModal");
        if (!modalElement) {
            logger.error(`[Ticket Picker] Modal element not found!`);
            return;
        }

        logger.debug(`[Ticket Picker] Showing modal...`);
        if (typeof bootstrap === "undefined") {
            logger.error(`[Ticket Picker] Bootstrap is not loaded!`);
            return;
        }

        const modal = new bootstrap.Modal(modalElement);
        modal.show();
        logger.debug(`[Ticket Picker] Modal shown successfully`);
    }

    /**
     * Get Bootstrap badge color class for ticket status
     * Matches actual status values from tickets.html
     * @param {string} status - Ticket status
     * @returns {string} Bootstrap color class
     * @since 1.0.57
     */
    getStatusBadgeColor(status) {
        const colors = {
            "Pending": "warning",      // Amber yellow
            "Staged": "info",          // Purple (info closest match)
            "Open": "primary",         // Blue
            "Overdue": "danger",       // Red
            "Completed": "success",    // Green
            "Failed": "danger",        // Orange-red
            "Closed": "secondary"      // Gray
        };
        return colors[status] || "secondary";
    }

    /**
     * Sort devices based on selected mode
     * HEX-204: Supports KEV First, VPR First, Tickets First, A-Z, Z-A
     * @param {Array} devices - Array of device objects
     * @returns {Array} Sorted devices array
     */
    sortDevices(devices) {
        const sorted = [...devices]; // Create copy to avoid mutating original

        switch (this.deviceSortMode) {
            case "kev-first":
                sorted.sort((a, b) => {
                    // Primary: KEV status
                    const aIsKev = a.hasKev === true ? 1 : 0;
                    const bIsKev = b.hasKev === true ? 1 : 0;
                    if (bIsKev !== aIsKev) {return bIsKev - aIsKev;}
                    // Secondary: VPR score
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    return bTotalVPR - aTotalVPR;
                });
                break;

            case "vpr-first":
                sorted.sort((a, b) => {
                    // Primary: VPR score (highest first)
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    return bTotalVPR - aTotalVPR;
                });
                break;

            case "tickets-first":
                // Note: This requires ticket counts to be fetched first
                // For now, sort by hostname (will be enhanced when ticket data is available)
                sorted.sort((a, b) => a.hostname.localeCompare(b.hostname));
                break;

            case "a-z":
                sorted.sort((a, b) => a.hostname.localeCompare(b.hostname));
                break;

            case "z-a":
                sorted.sort((a, b) => b.hostname.localeCompare(a.hostname));
                break;

            default:
                // Default to VPR First
                sorted.sort((a, b) => {
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    return bTotalVPR - aTotalVPR;
                });
        }

        return sorted;
    }

    /**
     * Set device sort mode
     * HEX-204: Changes sort order and re-renders
     * @param {string} mode - Sort mode (kev-first, vpr-first, tickets-first, a-z, z-a)
     */
    setSortMode(mode) {
        this.deviceSortMode = mode;
        this.renderDeviceCards();
    }

    /**
     * Render device cards with VPR scoring and pagination.
     * Filters devices based on search input, sorts by selected mode,
     * and renders paginated results with sortable functionality.
     *
     * @returns {void}
     */
    async renderDeviceCards() {
        const container = document.getElementById("deviceCards");
        const filteredDevices = this.dataManager.getFilteredDevices().filter(device => {
            const searchTerm = document.getElementById("searchInput").value.toLowerCase();
            return !searchTerm || device.hostname.toLowerCase().includes(searchTerm);
        });

        // HEX-204: Sort devices using selected mode
        const sortedDevices = this.sortDevices(filteredDevices);

        // Update pagination with filtered count
        this.devicePagination.setTotalItems(sortedDevices.length);

        // Get current page data
        const paginatedDevices = this.devicePagination.getCurrentPageData(sortedDevices);

        // Generate cards HTML with async ticket state checking
        container.innerHTML = await this.generateDeviceCardsHTML(paginatedDevices);

        // HEX-204: Render top controls (sort + items per page) above cards
        const sortOptions = [
            { value: "vpr-first", label: "Sort by: VPR First" },
            { value: "kev-first", label: "Sort by: KEV First" },
            { value: "tickets-first", label: "Sort by: Tickets First" },
            { value: "a-z", label: "Sort by: A-Z" },
            { value: "z-a", label: "Sort by: Z-A" }
        ];

        this.devicePagination.renderTopControls(
            "deviceControlsTop",
            () => this.renderDeviceCards(),
            {
                sortOptions: sortOptions,
                currentSort: this.deviceSortMode,
                onSortChange: (mode) => this.setSortMode(mode)
            }
        );

        // HEX-204: Render bottom pagination (arrows/numbers + showing text)
        this.devicePagination.renderPaginationControls(
            "devicePaginationControls",
            () => this.renderDeviceCards()
        );

        // Update footer with database stats
        this.updatePaginationInfo("devicePaginationInfo");

        this.initializeSortable(container);
    }

    /**
     * Generate HTML for device cards with theme-aware styling and dynamic ticket state
     * HEX-203: Now async to check ticket state before rendering buttons
     * @param {Array} devices - Array of device objects
     * @returns {Promise<string>} HTML string for device cards
     *
     * @description Generates device cards with VPR scoring mini-cards and click functionality.
     * Uses CSS classes that integrate with HexTrackr's theme system:
     * - `.device-card`: Card styling from shared/cards.css
     * - `.device-hostname`: Typography using --hextrackr-text-primary
     * - `.vpr-mini-card`: VPR severity indicators using --vpr-* variables
     * - `.text-red`, `.text-orange`, etc.: Semantic color classes
     *
     * @example
     * // CSS variables used in styling:
     * // --hextrackr-surface-base (card background)
     * // --hextrackr-border-color (card borders)
     * // --vpr-critical, --vpr-high, --vpr-medium, --vpr-low (severity colors)
     */
    async generateDeviceCardsHTML(devices) {
        // Check ticket state for all devices in parallel
        const ticketStates = await Promise.all(
            devices.map(device => this.checkTicketState(device.hostname))
        );

        return devices.map((device, index) => {
            const ticketState = ticketStates[index];
            const mostRecentJobType = ticketState.tickets && ticketState.tickets.length > 0 ? ticketState.tickets[0].job_type : null;
            const buttonConfig = this.getButtonConfig(ticketState.count, ticketState.mostRecentStatus, mostRecentJobType);
            const criticalVPR = device.criticalVPR || 0;
            const highVPR = device.highVPR || 0;
            const mediumVPR = device.mediumVPR || 0;
            const lowVPR = device.lowVPR || 0;
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            // HEX-120 Fix: Escape hostname for JavaScript string
            const escapedHostname = (device.hostname || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, "\\\"");

            // Check if device has any KEV vulnerabilities
            const hasKev = device.hasKev === true;
            const kevBadge = hasKev ? `
                <div class="kev-indicator" role="button" tabindex="0"
                     onclick="event.stopPropagation(); showKevDetails('${device.kevCve}')"
                     onkeydown="if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); event.stopPropagation(); showKevDetails('${device.kevCve}'); }">
                    <span class="badge kev-badge">
                        <i class="fas fa-shield-halved me-1"></i>
                        KEV
                    </span>
                </div>
            ` : "";

            // HEX-204: Generate vendor badge with standardized color coding
            const vendorBadgeColors = {
                "CISCO": "primary",       // Blue
                "Palo Alto": "warning",   // Orange
                "Other": "secondary"      // Gray
            };
            const vendorColor = vendorBadgeColors[device.vendor] || "secondary";
            const vendorBadge = device.vendor ? `<span class="badge bg-${vendorColor}">${device.vendor}</span>` : "";

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card device-card" style="cursor: pointer; position: relative;" onclick="window.openDeviceModal('${escapedHostname}')">
                    ${kevBadge}
                    <div class="card-body">
                        <div class="device-hostname" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <i class="fas fa-server me-2 text-primary"></i>
                                ${device.hostname}
                            </div>
                            ${vendorBadge}
                        </div>

                        <div class="device-version-info" style="display: flex; justify-content: space-between; margin-top: 0.5rem; padding: 0.5rem 0; border-bottom: 1px solid var(--bs-border-color);">
                            <div style="text-align: left;">
                                <div class="font-monospace ${device.operating_system ? "text-primary" : "text-muted"}" style="font-size: 0.9rem;">${device.operating_system || "Undetermined"}</div>
                                <div class="text-muted small">Installed</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="font-monospace text-muted" style="font-size: 0.9rem;">Undetermined</div>
                                <div class="text-muted small">Fixed</div>
                            </div>
                        </div>
                        
                        <div class="device-stats">
                            <div>
                                <div class="text-muted small">Total Vulnerabilities</div>
                                <div class="fw-bold">${device.totalCount}</div>
                            </div>
                            <div class="text-end">
                                <div class="text-muted small">Total VPR</div>
                                <div class="device-total-vpr">${totalVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${device.criticalCount}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${device.highCount}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${device.mediumCount}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${device.lowCount}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="card-actions">
                            <button class="btn ${buttonConfig.colorClass}"
                                    data-hostname="${device.hostname}"
                                    data-ticket-count="${ticketState.count}"
                                    data-tickets='${JSON.stringify(ticketState.tickets)}'
                                    onclick="event.stopPropagation(); vulnManager.cardsManager.handleCreateTicketClick(event, this)">
                                <i class="${buttonConfig.icon} me-1"></i><span class="${buttonConfig.textColorClass}">${buttonConfig.text}</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            `;
        }).join("");
    }

    /**
     * Sort vulnerabilities based on selected mode
     * HEX-204: Supports KEV First, VPR First, Devices First, A-Z, Z-A
     * @param {Array} vulnEntries - Array of [cve, vulns] tuples
     * @returns {Array} Sorted vulnerability entries array
     */
    sortVulnerabilities(vulnEntries) {
        const sorted = [...vulnEntries]; // Create copy to avoid mutating original

        switch (this.vulnerabilitySortMode) {
            case "kev-first":
                sorted.sort(([,vulnsA], [,vulnsB]) => {
                    // Primary: KEV status
                    const aIsKev = vulnsA[0].isKev === "Yes" ? 1 : 0;
                    const bIsKev = vulnsB[0].isKev === "Yes" ? 1 : 0;
                    if (bIsKev !== aIsKev) {return bIsKev - aIsKev;}
                    // Secondary: VPR score
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    return totalVPRB - totalVPRA;
                });
                break;

            case "vpr-first":
                sorted.sort(([,vulnsA], [,vulnsB]) => {
                    // Primary: Total VPR score (highest first)
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    return totalVPRB - totalVPRA;
                });
                break;

            case "devices-first":
                sorted.sort(([,vulnsA], [,vulnsB]) => {
                    // Primary: Number of affected devices (most widespread first)
                    return vulnsB.length - vulnsA.length;
                });
                break;

            case "a-z":
                sorted.sort(([cveA], [cveB]) => {
                    // Alphabetical by CVE ID
                    return (cveA || "").localeCompare(cveB || "");
                });
                break;

            case "z-a":
                sorted.sort(([cveA], [cveB]) => {
                    // Reverse alphabetical by CVE ID
                    return (cveB || "").localeCompare(cveA || "");
                });
                break;

            default:
                // Default to VPR First
                sorted.sort(([,vulnsA], [,vulnsB]) => {
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    return totalVPRB - totalVPRA;
                });
        }

        return sorted;
    }

    /**
     * Set vulnerability sort mode
     * HEX-204: Changes sort order and re-renders
     * @param {string} mode - Sort mode (kev-first, vpr-first, devices-first, a-z, z-a)
     */
    setVulnerabilitySortMode(mode) {
        this.vulnerabilitySortMode = mode;
        this.renderVulnerabilityCards();
    }

    /**
     * Render vulnerability cards grouped by CVE with VPR scoring.
     * Groups vulnerabilities by CVE, sorts by selected mode,
     * and renders paginated results with sortable functionality.
     *
     * @returns {void}
     */
    renderVulnerabilityCards() {
        const container = document.getElementById("vulnerabilityCards");
        const groupedVulns = this.dataManager.groupVulnerabilitiesByCVE();

        // HEX-204: Sort vulnerability groups using selected mode
        const sortedVulnEntries = this.sortVulnerabilities(Object.entries(groupedVulns));

        // HEX-101 Section 5: Use server total if in pagination mode
        // In legacy mode, sortedVulnEntries.length is accurate
        // In pagination mode, use server total count
        const totalCount = this.dataManager.isPaginationEnabled()
            ? this.dataManager.getTotalCount()
            : sortedVulnEntries.length;
        this.vulnerabilityPagination.setTotalItems(totalCount);
        
        // Get current page data
        const paginatedVulnEntries = this.vulnerabilityPagination.getCurrentPageData(sortedVulnEntries);

        container.innerHTML = this.generateVulnerabilityCardsHTML(paginatedVulnEntries);

        // HEX-204: Render top controls (sort + items per page) above cards
        const sortOptions = [
            { value: "vpr-first", label: "Sort by: VPR First" },
            { value: "kev-first", label: "Sort by: KEV First" },
            { value: "devices-first", label: "Sort by: Devices First" },
            { value: "a-z", label: "Sort by: A-Z" },
            { value: "z-a", label: "Sort by: Z-A" }
        ];

        this.vulnerabilityPagination.renderTopControls(
            "vulnerabilityControlsTop",
            () => this.renderVulnerabilityCards(),
            {
                sortOptions: sortOptions,
                currentSort: this.vulnerabilitySortMode,
                onSortChange: (mode) => this.setVulnerabilitySortMode(mode)
            }
        );

        // HEX-204: Render bottom pagination (arrows/numbers + showing text)
        this.vulnerabilityPagination.renderPaginationControls(
            "vulnerabilityPaginationControls",
            () => this.renderVulnerabilityCards()
        );

        // Update footer with database stats
        this.updatePaginationInfo("vulnerabilityPaginationInfo");

        this.initializeSortable(container);
    }

    /**
     * Generate HTML for vulnerability cards with severity-based styling
     * @param {Array} vulnEntries - Array of [cve, vulns] tuples
     * @returns {string} HTML string for vulnerability cards
     *
     * @description Generates vulnerability cards grouped by CVE with VPR scoring and
     * external link functionality. Integrates with HexTrackr's theme system:
     * - `.vulnerability-card`: Card styling from shared/cards.css
     * - `.vulnerability-title`: Title typography using --hextrackr-text-primary
     * - `.vulnerability-cve`: CVE link styling with external link behavior
     * - `.severity-*`: Severity badges using --vpr-* color variables
     * - `.vpr-mini-card`: VPR score indicators with theme-aware colors
     *
     * @example
     * // CSS variables used in vulnerability card styling:
     * // --hextrackr-surface-base (card background)
     * // --hextrackr-border-color (card borders)
     * // --vpr-critical, --vpr-high, --vpr-medium, --vpr-low (severity colors)
     * // --hextrackr-text-primary, --hextrackr-text-muted (text colors)
     */
    generateVulnerabilityCardsHTML(vulnEntries) {
        return vulnEntries.map(([cve, vulns]) => {
            const criticalVulns = vulns.filter(v => v.severity === "Critical");
            const highVulns = vulns.filter(v => v.severity === "High");
            const mediumVulns = vulns.filter(v => v.severity === "Medium");
            const lowVulns = vulns.filter(v => v.severity === "Low");
            
            const criticalVPR = criticalVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const highVPR = highVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const mediumVPR = mediumVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const lowVPR = lowVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            const primaryVuln = vulns[0];
            const description = primaryVuln.description || primaryVuln.plugin_name || "No description available";

            // Create a cryptographically secure ID for vulnerability data
            const vulnDataId = this.generateSecureVulnId("vuln");
            // Store the vulnerability data temporarily for modal access
            window.vulnModalData = window.vulnModalData || {};
            window.vulnModalData[vulnDataId] = primaryVuln;

            // Check if this vulnerability is in KEV catalog
            const isKev = primaryVuln.isKev === "Yes";
            // const kevBadge = isKev ? `<span class="kev-badge" onclick="event.stopPropagation(); showKevDetails('${cve}')">ðŸ”¥ KEV</span>` : '';
            const kevBadge = isKev ? `
                <div class="kev-indicator" role="button" tabindex="0"
                     onclick="event.stopPropagation(); showKevDetails('${cve}')"
                     onkeydown="if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); event.stopPropagation(); showKevDetails('${cve}'); }">
                    <span class="badge kev-badge">
                        <i class="fas fa-shield-halved me-1"></i>
                        KEV
                    </span>
                </div>
            ` : "";

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card vulnerability-card" style="cursor: pointer; position: relative;" data-vuln-id="${vulnDataId}" onclick="vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                    ${kevBadge}
                    <div class="card-body">
                        <div class="vulnerability-title">
                            ${description.substring(0, 100)}${description.length > 100 ? "..." : ""}
                        </div>
                        
                        <div class="vulnerability-meta">
                            <div class="vulnerability-identifiers">
                                <span class="badge severity-${primaryVuln.severity.toLowerCase()} me-2">
                                    ${primaryVuln.severity}
                                </span>
                                ${this.generateVulnerabilityLinkHTML(cve, primaryVuln)}
                            </div>
                            <div class="text-end">
                                <div class="vulnerability-vpr text-primary">
                                    ${totalVPR.toFixed(1)}
                                </div>
                                <div class="text-muted small">Total VPR</div>
                            </div>
                        </div>

                        <div class="device-display-enhanced">
                            <i class="fas fa-server fs-4 text-primary"></i>
                            <span class="device-count-large">
                                ${vulns.length} device${vulns.length !== 1 ? "s" : ""}
                            </span>
                        </div>

                        ${this.generateVulnerabilityActionsHTML(cve, primaryVuln, vulnDataId)}
                    </div>
                </div>
            </div>
            `;
        }).join("");
    }

    /**
     * Generate vulnerability link HTML (CVE or Cisco SA)
     * Handles multiple CVEs with proper individual link creation
     * @param {string} cve - CVE identifier(s) - may be comma/space separated
     * @param {Object} primaryVuln - Primary vulnerability object
     * @returns {string} HTML string for vulnerability link(s)
     */
    generateVulnerabilityLinkHTML(cve, primaryVuln) {
        // Use CVE utilities for multiple CVE handling
        if (cve && (cve.includes("CVE-") || cve.includes("cisco-sa-"))) {
            // Check if CVEUtilities is available
            if (typeof CVEUtilities !== "undefined" && CVEUtilities.createMultipleCVELinks) {
                return CVEUtilities.createMultipleCVELinks(cve, {
                    cssClass: "vulnerability-cve",
                    external: true
                });
            } else {
                // Fallback for single CVE (backward compatibility) - open in popup
                if (cve.startsWith("CVE-")) {
                    const cveUrl = `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve}`;
                    return `<a href="#" class="vulnerability-cve"
                               onclick="event.stopPropagation(); window.open('${cveUrl}', 'cve_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes'); return false;"
                               title="View CVE details on MITRE">
                                ${cve}
                            </a>`;
                }
            }
        }
        
        // Check for Cisco SA ID in plugin name as fallback
        if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
            const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
            if (ciscoSaMatch) {
                const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                const ciscoUrl = `https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/${ciscoId}`;
                return `<a href="#" class="vulnerability-cve text-warning"
                           onclick="event.stopPropagation(); window.open('${ciscoUrl}', 'cisco_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes'); return false;"
                           title="View Cisco Security Advisory">
                            ${ciscoId}
                        </a>`;
            }
        }
        
        return `<span class="text-muted">Plugin ${primaryVuln.plugin_id}</span>`;
    }

    /**
     * Generate vulnerability card actions HTML
     * @param {string} cve - CVE identifier
     * @param {Object} primaryVuln - Primary vulnerability object
     * @param {string} vulnDataId - Vulnerability data ID
     * @returns {string} HTML string for card actions
     */
    generateVulnerabilityActionsHTML(cve, primaryVuln, vulnDataId) {
        // Check if we have CVE - open external CVE link in popup
        if (cve && cve.startsWith("CVE-")) {
            const cveUrl = `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve}`;
            return `<div class="card-actions">
                        <button class="btn btn-primary"
                                onclick="event.stopPropagation(); window.open('${cveUrl}', 'cve_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes');">
                            <i class="fas fa-external-link-alt me-1"></i>View CVE Details
                        </button>
                    </div>`;
        }
        
        // Check for Cisco SA ID in plugin name
        if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
            const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
            if (ciscoSaMatch) {
                const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                const ciscoUrl = `https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/${ciscoId}`;
                return `<div class="card-actions">
                            <button class="btn btn-primary"
                                    onclick="event.stopPropagation(); window.open('${ciscoUrl}', 'cisco_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes');">
                                <i class="fas fa-external-link-alt me-1"></i>View Cisco Advisory
                            </button>
                        </div>`;
            }
        }
        
        // Default action for no external reference
        return `<div class="card-actions">
                    <button class="btn btn-primary" onclick="event.stopPropagation(); vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                        <i class="fas fa-eye me-1"></i>View Vulnerability Details
                    </button>
                </div>`;
    }

    /**
     * Initialize Sortable.js for drag-and-drop functionality with theme-aware CSS classes
     * @param {HTMLElement} container - Container element to make sortable
     *
     * @description Applies Sortable.js with CSS classes that work with HexTrackr's theme system:
     * - `.sortable-ghost`: Semi-transparent placeholder during drag (from shared/animations.css)
     * - `.sortable-chosen`: Selected item styling using --hextrackr-primary colors
     * - `.sortable-drag`: Active drag state styling with theme-aware shadows
     *
     * @example
     * // CSS classes applied during sorting:
     * // .sortable-ghost { opacity: 0.5; background: var(--hextrackr-surface-2); }
     * // .sortable-chosen { transform: scale(1.02); box-shadow: var(--hextrackr-shadow-md); }
     */
    initializeSortable(container) {
        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }

    /**
     * Update pagination info footer with database statistics
     * @param {string} elementId - ID of the pagination info element to update
     * @returns {void}
     */
    updatePaginationInfo(elementId) {
        const paginationDisplay = document.getElementById(elementId);
        if (!paginationDisplay) {return;}

        // Don't overwrite 50k limit warnings
        if (paginationDisplay.querySelector(".alert-warning")) {
            logger.debug("âš ï¸ Preserving 50k limit warning, not updating footer");
            return;
        }

        // Get all vulnerabilities for metadata calculation
        const allVulns = this.dataManager.getAllVulnerabilities();
        const totalCount = this.dataManager.getTotalCount();

        // Calculate vendor breakdown
        const vendorCounts = { CISCO: 0, "Palo Alto": 0, Other: 0 };
        let lastImportDate = null;

        allVulns.forEach(vuln => {
            // Vendor counting using dataManager's normalization logic
            const vendor = this.dataManager.normalizeVendor(vuln.plugin_name || "", vuln.hostname || "");
            if (vendorCounts.hasOwnProperty(vendor)) {
                vendorCounts[vendor]++;
            }

            // Track most recent import date
            if (vuln.scan_date) {
                const scanDate = new Date(vuln.scan_date);
                if (!lastImportDate || scanDate > lastImportDate) {
                    lastImportDate = scanDate;
                }
            }
        });

        // Format last import date
        const lastImport = lastImportDate
            ? lastImportDate.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" })
            : "Unknown";

        // Build database metadata footer
        paginationDisplay.innerHTML = `
            <span class="text-muted small">
                <strong>Database:</strong> ${totalCount.toLocaleString()} total |
                <strong>Last import:</strong> ${lastImport} |
                <strong>CISCO:</strong> ${vendorCounts.CISCO.toLocaleString()} |
                <strong>Palo Alto:</strong> ${vendorCounts["Palo Alto"].toLocaleString()} |
                <strong>Other:</strong> ${vendorCounts.Other.toLocaleString()}
            </span>
        `;
    }

    /**
     * Update cards for current view type.
     * Renders either device cards or vulnerability cards based on the current view mode.
     *
     * @param {string} viewType - Current view type ("devices" or "vulnerabilities")
     * @returns {void}
     */
    updateForCurrentView(viewType) {
        switch (viewType) {
            case "devices":
                this.renderDeviceCards();
                break;
            case "vulnerabilities":
                this.renderVulnerabilityCards();
                break;
        }
    }
}