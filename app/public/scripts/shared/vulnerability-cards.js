/**
 * @fileoverview VulnerabilityCardsManager - Handles device and vulnerability card rendering
 * Extracted from ModernVulnManager as part of Phase 2 modularization
 * @version 2.0.0
 * @author HexTrackr Team
 * @date 2025-09-08
 */

/* eslint-env browser, es6 */
/* global window, document, Sortable, CVEUtilities */
/* exported VulnerabilityCardsManager */

/**
 * Manages device cards and vulnerability cards rendering with pagination
 */
class VulnerabilityCardsManager {
    constructor(dataManager, devicePagination, vulnerabilityPagination, componentContext) {
        this.dataManager = dataManager;
        this.devicePagination = devicePagination;
        this.vulnerabilityPagination = vulnerabilityPagination;
        this.componentContext = componentContext; // Reference to parent component for callbacks
        this.deviceSortMode = "kev-priority"; // Default sort mode (KEV Priority)
        this.vulnerabilitySortMode = "kev-priority"; // Default sort mode for vulnerabilities (KEV Priority)

        // HEX-204: Cache for fixed versions (persists across device rebuilds)
        // Key: hostname, Value: fixed version string
        this.fixedVersionCache = new Map();
    }

    /**
     * Check ticket state for a device hostname
     * HEX-203: Bidirectional device-to-ticket navigation
     * HEX-215: Standardized API return format
     * @param {string} hostname - Device hostname to check
     * @returns {Promise<Object>} Ticket state object
     * @returns {number} return.count - Number of tickets for this device
     * @returns {Array<Object>} return.tickets - Array of ticket objects
     * @returns {string|null} return.status - Most recent ticket status (Pending, Open, Completed, etc.)
     * @returns {string|null} return.jobType - Most recent job type (Upgrade, Replace, Refresh, Mitigate, Other)
     * @since 1.0.57
     * @updated 1.0.66 (HEX-215) - Standardized return format
     */
    async checkTicketState(hostname) {
        try {
            const response = await fetch(`/api/tickets/by-device/${encodeURIComponent(hostname)}`);
            if (!response.ok) {
                logger.warn(`Failed to fetch tickets for ${hostname}:`, response.statusText);
                return { count: 0, tickets: [], status: null, jobType: null };
            }

            const data = await response.json();
            return {
                count: data.count || 0,
                tickets: data.tickets || [],
                status: data.tickets && data.tickets.length > 0 ? data.tickets[0].status : null,
                jobType: data.tickets && data.tickets.length > 0 ? data.tickets[0].job_type : null
            };
        } catch (error) {
            logger.error(`Error checking ticket state for ${hostname}:`, error);
            return { count: 0, tickets: [], status: null, jobType: null };
        }
    }

    /**
     * Check ticket state for multiple devices in a single batch request
     * HEX-216: Performance optimization to replace N+1 HTTP requests
     * Reduces 100 individual requests to 1 batch request (50x faster)
     * @param {Array<string>} hostnames - Array of device hostnames
     * @returns {Promise<Object>} Map of hostname to ticket summary {count, status, jobType}
     * @since 1.0.66
     */
    async checkTicketStateBatch(hostnames) {
        try {
            // Get CSRF token first (required for POST requests)
            const csrfResponse = await fetch("/api/auth/csrf", {
                credentials: "include"
            });
            const { csrfToken } = await csrfResponse.json();

            // Make batch request with CSRF token
            const response = await fetch("/api/tickets/batch-device-lookup", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "x-csrf-token": csrfToken
                },
                credentials: "include",
                body: JSON.stringify({ hostnames })
            });

            if (!response.ok) {
                logger.error("Failed to fetch batch ticket data:", response.statusText);
                // Return empty map on error
                const emptyMap = {};
                hostnames.forEach(hostname => {
                    emptyMap[hostname.toLowerCase()] = { count: 0, status: null, jobType: null };
                });
                return emptyMap;
            }

            const result = await response.json();
            return result.data || {};
        } catch (error) {
            logger.error("Error checking ticket state batch:", error);
            // Return empty map on error
            const emptyMap = {};
            hostnames.forEach(hostname => {
                emptyMap[hostname.toLowerCase()] = { count: 0, status: null, jobType: null };
            });
            return emptyMap;
        }
    }

    /**
     * Get button configuration based on ticket count, status, and job type
     * HEX-203: Dynamic button states (0/1/2+ tickets) with proper color mapping
     * @param {number} count - Number of open tickets
     * @param {string} status - Most recent ticket status
     * @param {string} jobType - Job type for color coding
     * @returns {Object} {text: string, colorClass: string, icon: string, textColorClass: string}
     * @since 1.0.57
     */
    getButtonConfig(count, status, jobType = null) {
        // Status to Bootstrap color mapping (matches tickets.css actual statuses)
        const statusColors = {
            "Pending": "warning",      // Amber yellow
            "Staged": "info",          // Purple (using info as closest Bootstrap match)
            "Open": "primary",         // Blue
            "Overdue": "danger",       // Red
            "Completed": "success",    // Green
            "Failed": "danger",        // Orange-red
            "Closed": "secondary"      // Gray
        };

        // Job type to status-label class mapping (for text color)
        const jobTypeTextColors = {
            "Upgrade": "status-open",      // Blue
            "Replace": "status-overdue",   // Orange/red
            "Refresh": "status-pending",   // Purple
            "Mitigate": "status-failed",   // Red
            "Other": "status-generic"      // Gray
        };

        if (count === 0) {
            return {
                text: "Create Ticket",
                colorClass: "btn-outline-success",
                icon: "fas fa-ticket-alt",
                textColorClass: ""
            };
        } else if (count === 1) {
            const colorClass = `btn-outline-${statusColors[status] || "primary"}`;
            const textColorClass = jobType ? `status-label ${jobTypeTextColors[jobType] || "status-generic"}` : "";
            return {
                text: "View Ticket",
                colorClass: colorClass,
                icon: "fas fa-folder-open",
                textColorClass: textColorClass
            };
        } else {
            const colorClass = `btn-outline-${statusColors[status] || "primary"}`;
            const textColorClass = jobType ? `status-label ${jobTypeTextColors[jobType] || "status-generic"}` : "";
            return {
                text: `View Tickets (${count})`,
                colorClass: colorClass,
                icon: "fas fa-layer-group",
                textColorClass: textColorClass
            };
        }
    }

    /**
     * Generate cryptographically secure ID for vulnerability data storage.
     * Uses crypto.getRandomValues() for true randomness, with fallback for older browsers.
     * @param {string} prefix - ID prefix (e.g., 'vuln', 'device')
     * @returns {string} Secure ID in format: prefix-timestamp-secureRandom
     * @since 1.0.30
     */
    generateSecureVulnId(prefix) {
        // Check for crypto API availability (requires HTTPS or localhost)
        if (!window.crypto || !window.crypto.getRandomValues) {
            logger.warn("crypto.getRandomValues not available, using timestamp fallback");
            const timestamp = Date.now();
            const random = performance.now().toString(36).replace(".", "");
            return `${prefix}-${timestamp}-${random}`;
        }

        // Generate cryptographically secure random bytes
        const randomBytes = new Uint8Array(9);
        window.crypto.getRandomValues(randomBytes);
        const randomString = Array.from(randomBytes, byte =>
            byte.toString(36).padStart(2, "0")
        ).join("").substr(0, 9);

        return `${prefix}-${Date.now()}-${randomString}`;
    }

    /**
     * Handle create ticket button click with ticket state awareness (HEX-203)
     * Supports multiple modes:
     * - 0 tickets: Create new ticket (supports bulk creation with keyboard modifiers)
     * - 1 ticket: Open existing ticket directly
     * - 2+ tickets: Show picker modal
     *
     * Bulk creation modes (only when ticketCount === 0):
     * - Single click: Create ticket for one device
     * - Cmd+Shift+Click (Mac) or Ctrl+Shift+Click (Windows): Create ticket for KEV devices at location
     * - Alt+Shift+Click: Create ticket for all devices at location
     *
     * @param {MouseEvent} event - Click event with keyboard modifiers
     * @param {HTMLElement} button - The button element that was clicked
     * @returns {void}
     * @since v1.0.57
     */
    handleCreateTicketClick(event, button) {
        // Stop event propagation to prevent card click
        event.stopPropagation();

        // Read data from button attributes
        const hostname = button.dataset.hostname;
        const ticketCount = parseInt(button.dataset.ticketCount) || 0;
        const tickets = button.dataset.tickets ? JSON.parse(button.dataset.tickets) : [];

        logger.debug(`[Ticket Click] hostname=${hostname}, count=${ticketCount}, tickets=`, tickets);

        // HEX-203: Handle existing tickets first
        if (ticketCount === 1) {
            // Open the single ticket directly by navigating to tickets.html
            const ticketId = tickets[0].id;
            logger.debug(`[Ticket Navigation] Opening ticket ${ticketId} for device ${hostname}`);
            // Navigate to tickets page and open the ticket modal
            window.location.href = `/tickets.html?openTicket=${ticketId}`;
            return;
        } else if (ticketCount > 1) {
            // Show picker modal for multiple tickets
            logger.debug(`[Ticket Navigation] Showing picker for ${ticketCount} tickets on device ${hostname}`);
            this.showTicketPickerModal(hostname, tickets);
            return;
        }

        // Original behavior: Create new ticket (ticketCount === 0)

        // Parse hostname to extract SITE and Location (ALL CAPS)
        const site = hostname.substring(0, 4).toUpperCase();       // First 4 characters
        const location = hostname.substring(0, 5).toUpperCase();   // First 5 characters

        // Detect keyboard modifiers to determine mode
        let mode = "single";
        let deviceList = [hostname.toUpperCase()];

        // Mode 2: KEV devices at location (Cmd/Ctrl + Shift)
        if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            mode = "bulk-kev";

            // Get all filtered devices
            const allDevices = this.dataManager.getFilteredDevices();

            // Filter for KEV devices at same location (case-insensitive comparison)
            deviceList = allDevices
                .filter(device => device.hostname.toLowerCase().startsWith(location.toLowerCase()) && device.hasKev === true)
                .map(device => device.hostname.toUpperCase());
        }
        // Mode 3: All devices at location (Alt + Shift)
        else if (event.altKey && event.shiftKey) {
            mode = "bulk-all";

            // Get all filtered devices
            const allDevices = this.dataManager.getFilteredDevices();

            // Filter for all devices at same location (case-insensitive comparison)
            deviceList = allDevices
                .filter(device => device.hostname.toLowerCase().startsWith(location.toLowerCase()))
                .map(device => device.hostname.toUpperCase());
        }
        // Mode 1: Single device (default - no modifiers)

        // Console logging for debugging
        logger.debug("[Power Tool] Mode:", mode);
        logger.debug("[Power Tool] Site:", site);
        logger.debug("[Power Tool] Location:", location);
        logger.debug("[Power Tool] Devices:", deviceList);
        logger.debug("[Power Tool] Total Count:", deviceList.length);

        // Build options object for all modes
        const options = {
            devices: deviceList,
            site: site,
            location: location,
            mode: mode
        };

        // Call createTicketFromDevice with options for all modes
        if (this.componentContext && typeof this.componentContext.createTicketFromDevice === "function") {
            this.componentContext.createTicketFromDevice(hostname, options);
        } else {
            logger.error("[Power Tool] createTicketFromDevice method not found on componentContext");
        }
    }

    /**
     * Show ticket picker modal for devices with multiple open tickets
     * HEX-203: Handle edge case of 2+ tickets for one device
     * @param {string} hostname - Device hostname
     * @param {Array<Object>} tickets - Array of ticket objects (already fetched)
     * @returns {void}
     * @since 1.0.57
     */
    async showTicketPickerModal(hostname, tickets) {
        logger.debug(`[Ticket Picker] Opening picker for ${hostname} with ${tickets.length} tickets:`, tickets);

        const validTickets = tickets.filter(t => t !== null && t.id);
        logger.debug(`[Ticket Picker] Valid tickets: ${validTickets.length}`, validTickets);

        if (validTickets.length === 0) {
            logger.error(`[Ticket Picker] No valid tickets found for ${hostname}`);
            return;
        }

        // Build modal content
        const modalBody = document.getElementById("ticketPickerModalBody");
        if (!modalBody) {
            logger.error(`[Ticket Picker] Modal body element not found!`);
            return;
        }

        modalBody.innerHTML = `
            <p class="mb-3">
                <strong>${hostname}</strong> has <strong>${validTickets.length}</strong> open tickets. Which would you like to view?
            </p>
            <div class="list-group">
                ${validTickets.map(ticket => `
                    <button type="button" class="list-group-item list-group-item-action"
                            onclick="window.location.href='/tickets.html?openTicket=${ticket.id}';">
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-1">XT-${ticket.xt_number}</h6>
                                <small class="text-muted">${ticket.job_type || "Unknown"} • ${new Date(ticket.created_at).toLocaleDateString()}</small>
                            </div>
                            <span class="badge bg-${this.getStatusBadgeColor(ticket.status)}">${ticket.status}</span>
                        </div>
                    </button>
                `).join("")}
            </div>
            <hr>
            <button type="button" class="btn btn-success w-100"
                    onclick="vulnManager.cardsManager.componentContext.createTicketFromDevice('${hostname}'); bootstrap.Modal.getInstance(document.getElementById('ticketPickerModal')).hide();">
                <i class="fas fa-plus me-1"></i>Create New Ticket Anyway
            </button>
        `;

        // Show the modal
        const modalElement = document.getElementById("ticketPickerModal");
        if (!modalElement) {
            logger.error(`[Ticket Picker] Modal element not found!`);
            return;
        }

        logger.debug(`[Ticket Picker] Showing modal...`);
        if (typeof bootstrap === "undefined") {
            logger.error(`[Ticket Picker] Bootstrap is not loaded!`);
            return;
        }

        const modal = new bootstrap.Modal(modalElement);
        modal.show();
        logger.debug(`[Ticket Picker] Modal shown successfully`);
    }

    /**
     * Get Bootstrap badge color class for ticket status
     * Matches actual status values from tickets.html
     * @param {string} status - Ticket status
     * @returns {string} Bootstrap color class
     * @since 1.0.57
     */
    getStatusBadgeColor(status) {
        const colors = {
            "Pending": "warning",      // Amber yellow
            "Staged": "info",          // Purple (info closest match)
            "Open": "primary",         // Blue
            "Overdue": "danger",       // Red
            "Completed": "success",    // Green
            "Failed": "danger",        // Orange-red
            "Closed": "secondary"      // Gray
        };
        return colors[status] || "secondary";
    }

    /**
     * Count KEV vulnerabilities for a device
     * @param {Object} device - Device object
     * @returns {number} Number of KEV vulnerabilities
     * @private
     */
    _countKevVulns(device) {
        if (!device.vulnerabilities) {return 0;}
        return device.vulnerabilities.filter(v => v.isKev === "Yes").length;
    }

    /**
     * Parse software version for sorting
     * Extracts numeric components for version comparison
     * @param {string} version - Version string (e.g., "16.9.3")
     * @returns {Array<number>} Array of version numbers [major, minor, patch]
     * @private
     */
    _parseVersion(version) {
        if (!version) {return [0, 0, 0];}
        const parts = version.split(".").map(p => parseInt(p, 10) || 0);
        return [parts[0] || 0, parts[1] || 0, parts[2] || 0];
    }

    /**
     * Compare two software versions
     * @param {Array<number>} vA - Parsed version A
     * @param {Array<number>} vB - Parsed version B
     * @returns {number} -1 if A < B, 1 if A > B, 0 if equal
     * @private
     */
    _compareVersions(vA, vB) {
        for (let i = 0; i < 3; i++) {
            if (vA[i] !== vB[i]) {
                return vA[i] - vB[i];
            }
        }
        return 0;
    }

    /**
     * Sort devices based on selected mode
     * Supports: KEV Priority, VPR Priority, Tickets Priority, A-Z, Z-A, Version High-Low, Version Low-High
     * @param {Array} devices - Array of device objects
     * @returns {Array} Sorted devices array
     */
    sortDevices(devices) {
        const sorted = [...devices]; // Create copy to avoid mutating original

        switch (this.deviceSortMode) {
            case "kev-priority":
                // KEV count (high to low) → VPR (high to low) → Alphabetical
                sorted.sort((a, b) => {
                    // Primary: KEV count
                    const aKevCount = this._countKevVulns(a);
                    const bKevCount = this._countKevVulns(b);
                    if (bKevCount !== aKevCount) {
                        return bKevCount - aKevCount;
                    }
                    // Secondary: VPR score
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    if (bTotalVPR !== aTotalVPR) {
                        return bTotalVPR - aTotalVPR;
                    }
                    // Tertiary: Alphabetical
                    return a.hostname.localeCompare(b.hostname);
                });
                break;

            case "vpr-priority":
                // VPR (high to low) → Alphabetical
                sorted.sort((a, b) => {
                    // Primary: VPR score
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    if (bTotalVPR !== aTotalVPR) {
                        return bTotalVPR - aTotalVPR;
                    }
                    // Secondary: Alphabetical
                    return a.hostname.localeCompare(b.hostname);
                });
                break;

            case "tickets-priority":
                // Ticket count → VPR (high to low) → Alphabetical
                sorted.sort((a, b) => {
                    // Primary: Ticket count
                    const aTicketCount = a.ticketCount || 0;
                    const bTicketCount = b.ticketCount || 0;
                    if (bTicketCount !== aTicketCount) {
                        return bTicketCount - aTicketCount;
                    }
                    // Secondary: VPR score
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    if (bTotalVPR !== aTotalVPR) {
                        return bTotalVPR - aTotalVPR;
                    }
                    // Tertiary: Alphabetical
                    return a.hostname.localeCompare(b.hostname);
                });
                break;

            case "version-high-low":
                // Software version (high to low) → Alphabetical
                sorted.sort((a, b) => {
                    const aVersion = this._parseVersion(a.operating_system);
                    const bVersion = this._parseVersion(b.operating_system);
                    const versionCompare = this._compareVersions(bVersion, aVersion); // Reversed for high-to-low
                    if (versionCompare !== 0) {
                        return versionCompare;
                    }
                    // Secondary: Alphabetical
                    return a.hostname.localeCompare(b.hostname);
                });
                break;

            case "version-low-high":
                // Software version (low to high) → Alphabetical
                sorted.sort((a, b) => {
                    const aVersion = this._parseVersion(a.operating_system);
                    const bVersion = this._parseVersion(b.operating_system);
                    const versionCompare = this._compareVersions(aVersion, bVersion);
                    if (versionCompare !== 0) {
                        return versionCompare;
                    }
                    // Secondary: Alphabetical
                    return a.hostname.localeCompare(b.hostname);
                });
                break;

            case "hostname-a-z":
                sorted.sort((a, b) => a.hostname.localeCompare(b.hostname));
                break;

            case "hostname-z-a":
                sorted.sort((a, b) => b.hostname.localeCompare(a.hostname));
                break;

            default:
                // Default to KEV Priority
                sorted.sort((a, b) => {
                    const aKevCount = this._countKevVulns(a);
                    const bKevCount = this._countKevVulns(b);
                    if (bKevCount !== aKevCount) {
                        return bKevCount - aKevCount;
                    }
                    const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
                    const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
                    if (bTotalVPR !== aTotalVPR) {
                        return bTotalVPR - aTotalVPR;
                    }
                    return a.hostname.localeCompare(b.hostname);
                });
        }

        return sorted;
    }

    /**
     * Set device sort mode
     * HEX-204: Changes sort order and re-renders
     * @param {string} mode - Sort mode (kev-first, vpr-first, tickets-first, a-z, z-a)
     */
    setSortMode(mode) {
        this.deviceSortMode = mode;
        this.renderDeviceCards();
    }

    /**
     * Render device cards with VPR scoring and pagination.
     * Filters devices based on search input, sorts by selected mode,
     * and renders paginated results with sortable functionality.
     *
     * @returns {void}
     */
    async renderDeviceCards() {
        const container = document.getElementById("deviceCards");

        // HEX-234: Use all devices when there's a search term, since device-level search
        // includes fixed_version which is not available at vulnerability level
        const searchTerm = document.getElementById("searchInput")?.value.toLowerCase() || "";
        const baseDevices = searchTerm ? this.dataManager.getDevices() : this.dataManager.getFilteredDevices();

        const filteredDevices = baseDevices.filter(device => {
            // HEX-234: When using all devices, ensure device-level fields are populated from vulnerabilities
            if (searchTerm && device.vulnerabilities && device.vulnerabilities.length > 0) {
                // Populate operating_system from most recent vulnerability
                const vulnWithOS = device.vulnerabilities.find(v => v.operating_system && v.operating_system.trim() !== "");
                if (vulnWithOS) {
                    device.operating_system = vulnWithOS.operating_system;
                }

                // Populate vendor from first vulnerability with vendor data
                const vulnWithVendor = device.vulnerabilities.find(v => v.vendor && v.vendor.trim() !== "");
                if (vulnWithVendor) {
                    device.vendor = vulnWithVendor.vendor;
                }

                // Populate ip_address from first vulnerability with IP data
                const vulnWithIP = device.vulnerabilities.find(v => v.ip_address && v.ip_address.trim() !== "");
                if (vulnWithIP) {
                    device.ip_address = vulnWithIP.ip_address;
                }
            }

            // HEX-204: Restore fixed version from cache (persists across device rebuilds)
            if (this.fixedVersionCache.has(device.hostname)) {
                device.fixed_version = this.fixedVersionCache.get(device.hostname);
            }

            // HEX-234: When using all devices (search active), apply severity/vendor filters manually
            if (searchTerm) {
                const severityFilter = document.getElementById("severityFilter")?.value || "";
                const vendorFilterValue = document.getElementById("vendorFilter")?.value || "";

                // Apply severity filter (including KEV)
                if (severityFilter) {
                    const hasMatchingSeverity = device.vulnerabilities && device.vulnerabilities.some(vuln => {
                        if (severityFilter === "KEV") {
                            return vuln.isKev === "Yes";
                        }
                        return vuln.severity === severityFilter;
                    });
                    if (!hasMatchingSeverity) return false;
                }

                // Apply vendor filter
                if (vendorFilterValue && device.vendor !== vendorFilterValue) {
                    return false;
                }
            }

            if (!searchTerm) return true;

            // HEX-204: Search device hostname, vendor, IP address, fixed version, and all vulnerability fields
            const hostnameMatch = device.hostname.toLowerCase().includes(searchTerm);
            const vendorMatch = device.vendor && device.vendor.toLowerCase().includes(searchTerm);
            const osMatch = device.operating_system && device.operating_system.toLowerCase().includes(searchTerm);
            const ipMatch = device.ip_address && device.ip_address.toLowerCase().includes(searchTerm);
            const fixedVersionMatch = device.fixed_version && device.fixed_version.toLowerCase().includes(searchTerm);

            // Also check if ANY vulnerability on this device matches
            const vulnMatch = device.vulnerabilities && device.vulnerabilities.some(vuln =>
                (vuln.cve && vuln.cve.toLowerCase().includes(searchTerm)) ||
                (vuln.operating_system && vuln.operating_system.toLowerCase().includes(searchTerm)) ||
                (vuln.vendor && vuln.vendor.toLowerCase().includes(searchTerm)) ||
                (vuln.description && vuln.description.toLowerCase().includes(searchTerm)) ||
                (vuln.solution_text && vuln.solution_text.toLowerCase().includes(searchTerm))
            );

            return hostnameMatch || vendorMatch || osMatch || ipMatch || fixedVersionMatch || vulnMatch;
        });

        // Fetch ticket data BEFORE sorting if needed for tickets-priority sort
        // HEX-216: Use batch API to reduce N+1 requests (100 requests → 1 request)
        if (this.deviceSortMode === "tickets-priority") {
            const hostnames = filteredDevices.map(device => device.hostname);
            const ticketMap = await this.checkTicketStateBatch(hostnames);

            // Attach ticket data to device objects for sorting
            filteredDevices.forEach(device => {
                const ticketData = ticketMap[device.hostname.toLowerCase()] || { count: 0, status: null, jobType: null };
                device.ticketCount = ticketData.count;
                device.ticketStatus = ticketData.status;
            });
        }

        // Sort devices using selected mode
        const sortedDevices = this.sortDevices(filteredDevices);

        // Update pagination with filtered count
        this.devicePagination.setTotalItems(sortedDevices.length);

        // Get current page data
        const paginatedDevices = this.devicePagination.getCurrentPageData(sortedDevices);

        // Generate cards HTML with async ticket state checking
        container.innerHTML = await this.generateDeviceCardsHTML(paginatedDevices);

        // Render top controls (sort + items per page) above cards
        const sortOptions = [
            { value: "kev-priority", label: "KEV Priority" },
            { value: "vpr-priority", label: "VPR Priority" },
            { value: "tickets-priority", label: "Tickets Priority" },
            { value: "hostname-a-z", label: "Hostname A-Z" },
            { value: "hostname-z-a", label: "Hostname Z-A" },
            { value: "version-high-low", label: "Software Version (High-Low)" },
            { value: "version-low-high", label: "Software Version (Low-High)" }
        ];

        this.devicePagination.renderTopControls(
            "deviceControlsTop",
            () => this.renderDeviceCards(),
            {
                sortOptions: sortOptions,
                currentSort: this.deviceSortMode,
                onSortChange: (mode) => this.setSortMode(mode),
                itemType: "Devices"
            }
        );

        // HEX-204: Render bottom pagination (arrows/numbers + showing text)
        this.devicePagination.renderPaginationControls(
            "devicePaginationControls",
            () => this.renderDeviceCards()
        );

        // Update footer with database stats
        this.updatePaginationInfo("devicePaginationInfo");

        this.initializeSortable(container);

        // HEX-204 Phase 2: Load Cisco fixed versions asynchronously (non-blocking)
        this.loadFixedVersionsForCards(paginatedDevices);
    }

    /**
     * Generate HTML for device cards with theme-aware styling and dynamic ticket state
     * HEX-203: Now async to check ticket state before rendering buttons
     * @param {Array} devices - Array of device objects
     * @returns {Promise<string>} HTML string for device cards
     *
     * @description Generates device cards with VPR scoring mini-cards and click functionality.
     * Uses CSS classes that integrate with HexTrackr's theme system:
     * - `.device-card`: Card styling from shared/cards.css
     * - `.device-hostname`: Typography using --hextrackr-text-primary
     * - `.vpr-mini-card`: VPR severity indicators using --vpr-* variables
     * - `.text-red`, `.text-orange`, etc.: Semantic color classes
     *
     * @example
     * // CSS variables used in styling:
     * // --hextrackr-surface-base (card background)
     * // --hextrackr-border-color (card borders)
     * // --vpr-critical, --vpr-high, --vpr-medium, --vpr-low (severity colors)
     */
    async generateDeviceCardsHTML(devices) {
        // Check ticket state for all devices in parallel
        const ticketStates = await Promise.all(
            devices.map(device => this.checkTicketState(device.hostname))
        );

        return devices.map((device, index) => {
            const ticketState = ticketStates[index];
            const buttonConfig = this.getButtonConfig(ticketState.count, ticketState.status, ticketState.jobType);
            const criticalVPR = device.criticalVPR || 0;
            const highVPR = device.highVPR || 0;
            const mediumVPR = device.mediumVPR || 0;
            const lowVPR = device.lowVPR || 0;
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            // HEX-120 Fix: Escape hostname for JavaScript string
            const escapedHostname = (device.hostname || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, "\\\"");

            // Check if device has any KEV vulnerabilities
            const hasKev = device.hasKev === true;
            let kevBadge = "";

            if (hasKev) {
                // Get ALL KEV vulnerabilities for this device
                const kevVulns = device.vulnerabilities?.filter(v => v.isKev === "Yes") || [];
                const kevCount = kevVulns.length;

                // Store KEV data for click handler
                const kevDataId = `kev-data-${device.hostname.replace(/[^a-zA-Z0-9]/g, "")}-${Date.now()}`;
                if (!window.kevModalData) {
                    window.kevModalData = {};
                }
                window.kevModalData[kevDataId] = kevVulns;

                // Determine click handler based on KEV count
                const clickHandler = kevCount === 1
                    ? `showKevDetails('${kevVulns[0].cve}')`
                    : `showKevPickerModal('${escapedHostname}', window.kevModalData['${kevDataId}'])`;

                kevBadge = `
                    <div class="kev-indicator" role="button" tabindex="0"
                         onclick="event.stopPropagation(); ${clickHandler}"
                         onkeydown="if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); event.stopPropagation(); ${clickHandler}; }">
                        <span class="badge kev-badge">
                            <i class="fas fa-shield-halved me-1"></i>
                            KEV${kevCount > 1 ? ` (${kevCount})` : ""}
                        </span>
                    </div>
                `;
            }

            // HEX-204: Generate vendor badge with standardized color coding
            const vendorBadgeColors = {
                "CISCO": "primary",       // Blue
                "Palo Alto": "warning",   // Orange
                "Other": "secondary"      // Gray
            };
            const vendorColor = vendorBadgeColors[device.vendor] || "secondary";
            const vendorBadge = device.vendor ? `<span class="badge bg-${vendorColor}">${device.vendor}</span>` : "";

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card device-card" style="cursor: pointer; position: relative;" onclick="window.openDeviceModal('${escapedHostname}')">
                    ${kevBadge}
                    <div class="card-body">
                        <div class="device-hostname" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <i class="fas fa-server me-2 text-primary"></i>
                                ${device.hostname}
                            </div>
                            ${vendorBadge}
                        </div>

                        <div class="device-version-info" style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid var(--bs-border-color);">
                            <div style="text-align: left;">
                                <div class="font-monospace ${device.operating_system ? "text-primary" : "text-muted"}" style="font-size: 0.9rem;">${device.operating_system || "Undetermined"}</div>
                                <div class="text-muted small">Installed</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="font-monospace device-fixed-version text-muted"
                                     style="font-size: 0.9rem;"
                                     data-device-hostname="${device.hostname}"
                                     data-device-vendor="${device.vendor || ''}">
                                    <span class="spinner-border spinner-border-sm" role="status"></span>
                                </div>
                                <div class="text-muted small">Fixed</div>
                            </div>
                        </div>
                        
                        <div class="device-stats">
                            <div>
                                <div class="text-muted small">Total Vulnerabilities</div>
                                <div class="fw-bold">${device.totalCount}</div>
                            </div>
                            <div class="text-end">
                                <div class="text-muted small">Total VPR</div>
                                <div class="device-total-vpr">${totalVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${device.criticalCount}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${device.highCount}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${device.mediumCount}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${device.lowCount}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="card-actions">
                            ${device.ip_address ? `
                            <span class="text-info font-monospace" style="font-size: 0.875rem;">${device.ip_address}</span>
                            ` : ""}
                            <button class="btn ${buttonConfig.colorClass}"
                                    data-hostname="${device.hostname}"
                                    data-ticket-count="${ticketState.count}"
                                    data-tickets='${JSON.stringify(ticketState.tickets)}'
                                    onclick="event.stopPropagation(); vulnManager.cardsManager.handleCreateTicketClick(event, this)">
                                <i class="${buttonConfig.icon} me-1"></i><span class="${buttonConfig.textColorClass}">${buttonConfig.text}</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            `;
        }).join("");
    }

    /**
     * Load Cisco fixed versions for device cards (async, non-blocking)
     * HEX-204 Phase 2: Queries Cisco advisory API for fixed versions
     *
     * @param {Array} devices - Array of device objects to load fixed versions for
     */
    async loadFixedVersionsForCards(devices) {
        // Check if any advisory helpers are loaded
        if (!window.ciscoAdvisoryHelper && !window.paloAdvisoryHelper) {
            console.warn('No advisory helpers loaded');
            return;
        }

        // Find all fixed version elements on the page
        const fixedVersionElements = document.querySelectorAll('.device-fixed-version');

        // Load fixed versions for each device (parallel for performance)
        await Promise.all(Array.from(fixedVersionElements).map(async (el) => {
            const hostname = el.dataset.deviceHostname;
            const vendor = el.dataset.deviceVendor;

            // Find device object
            const device = devices.find(d => d.hostname === hostname);

            if (!device) {
                el.textContent = 'N/A';
                return;
            }

            // Determine which advisory helper to use based on vendor
            let advisoryHelper = null;
            if (vendor?.toLowerCase().includes('cisco')) {
                advisoryHelper = window.ciscoAdvisoryHelper;
            } else if (vendor?.toLowerCase().includes('palo')) {
                advisoryHelper = window.paloAdvisoryHelper;
            }

            // Unsupported vendor - show N/A
            if (!advisoryHelper) {
                const fixedVersionValue = 'N/A';
                el.textContent = fixedVersionValue;
                device.fixed_version = fixedVersionValue;
                // Store in persistent cache for search filtering
                this.fixedVersionCache.set(hostname, fixedVersionValue);
                return;
            }

            try {
                const fixedVersion = await advisoryHelper.getDeviceFixedVersion(device);

                if (fixedVersion) {
                    // Show fixed version in green with "+" to indicate "or higher"
                    el.innerHTML = `<span class="text-success">${fixedVersion}+</span>`;
                    el.classList.remove('text-muted');
                    // Store in device object AND persistent cache for search filtering
                    device.fixed_version = fixedVersion;
                    this.fixedVersionCache.set(hostname, fixedVersion);
                } else {
                    // Cisco device but no fix available yet (may still be syncing)
                    const fixedVersionValue = 'No Fix Available';
                    el.textContent = fixedVersionValue;
                    device.fixed_version = fixedVersionValue;
                    this.fixedVersionCache.set(hostname, fixedVersionValue);
                }
            } catch (error) {
                console.error(`Failed to load fixed version for ${hostname}:`, error);
                const fixedVersionValue = 'Error';
                el.textContent = fixedVersionValue;
                device.fixed_version = fixedVersionValue;
                this.fixedVersionCache.set(hostname, fixedVersionValue);
            }
        }));
    }

    /**
     * Sort vulnerabilities based on selected mode
     * Updated with multi-level sorting to match device cards pattern
     * @param {Array} vulnEntries - Array of [cve, vulns] tuples
     * @returns {Array} Sorted vulnerability entries array
     */
    sortVulnerabilities(vulnEntries) {
        const sorted = [...vulnEntries]; // Create copy to avoid mutating original

        switch (this.vulnerabilitySortMode) {
            case "kev-priority":
                // KEV Priority: KEV status (high→low) → VPR (high→low) → Alphabetical
                sorted.sort(([cveA, vulnsA], [cveB, vulnsB]) => {
                    // Primary: KEV status
                    const aIsKev = vulnsA[0].isKev === "Yes" ? 1 : 0;
                    const bIsKev = vulnsB[0].isKev === "Yes" ? 1 : 0;
                    if (bIsKev !== aIsKev) {
                        return bIsKev - aIsKev;
                    }
                    // Secondary: VPR score
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    if (totalVPRB !== totalVPRA) {
                        return totalVPRB - totalVPRA;
                    }
                    // Tertiary: Alphabetical by CVE
                    return (cveA || "").localeCompare(cveB || "");
                });
                break;

            case "vpr-priority":
                // VPR Priority: VPR score (high→low) → Alphabetical
                sorted.sort(([cveA, vulnsA], [cveB, vulnsB]) => {
                    // Primary: Total VPR score (highest first)
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    if (totalVPRB !== totalVPRA) {
                        return totalVPRB - totalVPRA;
                    }
                    // Secondary: Alphabetical by CVE
                    return (cveA || "").localeCompare(cveB || "");
                });
                break;

            case "device-priority":
                // Device Priority: # devices (high→low) → VPR (high→low) → Alphabetical
                sorted.sort(([cveA, vulnsA], [cveB, vulnsB]) => {
                    // Primary: Number of affected devices (most widespread first)
                    if (vulnsB.length !== vulnsA.length) {
                        return vulnsB.length - vulnsA.length;
                    }
                    // Secondary: VPR score
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    if (totalVPRB !== totalVPRA) {
                        return totalVPRB - totalVPRA;
                    }
                    // Tertiary: Alphabetical by CVE
                    return (cveA || "").localeCompare(cveB || "");
                });
                break;

            case "vulnerability-a-z":
                // Alphabetical by CVE ID (ascending)
                sorted.sort(([cveA], [cveB]) => {
                    return (cveA || "").localeCompare(cveB || "");
                });
                break;

            case "vulnerability-z-a":
                // Reverse alphabetical by CVE ID (descending)
                sorted.sort(([cveA], [cveB]) => {
                    return (cveB || "").localeCompare(cveA || "");
                });
                break;

            default:
                // Default to KEV Priority
                sorted.sort(([cveA, vulnsA], [cveB, vulnsB]) => {
                    const aIsKev = vulnsA[0].isKev === "Yes" ? 1 : 0;
                    const bIsKev = vulnsB[0].isKev === "Yes" ? 1 : 0;
                    if (bIsKev !== aIsKev) {
                        return bIsKev - aIsKev;
                    }
                    const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
                    if (totalVPRB !== totalVPRA) {
                        return totalVPRB - totalVPRA;
                    }
                    return (cveA || "").localeCompare(cveB || "");
                });
        }

        return sorted;
    }

    /**
     * Set vulnerability sort mode
     * Updated with comprehensive multi-level sorting options
     * @param {string} mode - Sort mode (kev-priority, vpr-priority, device-priority, vulnerability-a-z, vulnerability-z-a)
     */
    setVulnerabilitySortMode(mode) {
        this.vulnerabilitySortMode = mode;
        this.renderVulnerabilityCards();
    }

    /**
     * Render vulnerability cards grouped by CVE with VPR scoring.
     * Groups vulnerabilities by CVE, sorts by selected mode,
     * and renders paginated results with sortable functionality.
     *
     * @returns {void}
     */
    renderVulnerabilityCards() {
        const container = document.getElementById("vulnerabilityCards");
        const groupedVulns = this.dataManager.groupVulnerabilitiesByCVE();

        // HEX-204: Sort vulnerability groups using selected mode
        const sortedVulnEntries = this.sortVulnerabilities(Object.entries(groupedVulns));

        // HEX-101 Section 5: Use server total if in pagination mode
        // In legacy mode, sortedVulnEntries.length is accurate
        // In pagination mode, use server total count
        const totalCount = this.dataManager.isPaginationEnabled()
            ? this.dataManager.getTotalCount()
            : sortedVulnEntries.length;
        this.vulnerabilityPagination.setTotalItems(totalCount);
        
        // Get current page data
        const paginatedVulnEntries = this.vulnerabilityPagination.getCurrentPageData(sortedVulnEntries);

        container.innerHTML = this.generateVulnerabilityCardsHTML(paginatedVulnEntries);

        // Render top controls (sort + items per page) above cards
        const sortOptions = [
            { value: "kev-priority", label: "KEV Priority" },
            { value: "vpr-priority", label: "VPR Priority" },
            { value: "device-priority", label: "Device Priority" },
            { value: "vulnerability-a-z", label: "Vulnerability A-Z" },
            { value: "vulnerability-z-a", label: "Vulnerability Z-A" }
        ];

        this.vulnerabilityPagination.renderTopControls(
            "vulnerabilityControlsTop",
            () => this.renderVulnerabilityCards(),
            {
                sortOptions: sortOptions,
                currentSort: this.vulnerabilitySortMode,
                onSortChange: (mode) => this.setVulnerabilitySortMode(mode),
                itemType: "Vulnerabilities"
            }
        );

        // HEX-204: Render bottom pagination (arrows/numbers + showing text)
        this.vulnerabilityPagination.renderPaginationControls(
            "vulnerabilityPaginationControls",
            () => this.renderVulnerabilityCards()
        );

        // Update footer with database stats
        this.updatePaginationInfo("vulnerabilityPaginationInfo");

        this.initializeSortable(container);
    }

    /**
     * Generate HTML for vulnerability cards with severity-based styling
     * @param {Array} vulnEntries - Array of [cve, vulns] tuples
     * @returns {string} HTML string for vulnerability cards
     *
     * @description Generates vulnerability cards grouped by CVE with VPR scoring and
     * external link functionality. Integrates with HexTrackr's theme system:
     * - `.vulnerability-card`: Card styling from shared/cards.css
     * - `.vulnerability-title`: Title typography using --hextrackr-text-primary
     * - `.vulnerability-cve`: CVE link styling with external link behavior
     * - `.severity-*`: Severity badges using --vpr-* color variables
     * - `.vpr-mini-card`: VPR score indicators with theme-aware colors
     *
     * @example
     * // CSS variables used in vulnerability card styling:
     * // --hextrackr-surface-base (card background)
     * // --hextrackr-border-color (card borders)
     * // --vpr-critical, --vpr-high, --vpr-medium, --vpr-low (severity colors)
     * // --hextrackr-text-primary, --hextrackr-text-muted (text colors)
     */
    generateVulnerabilityCardsHTML(vulnEntries) {
        return vulnEntries.map(([cve, vulns]) => {
            const criticalVulns = vulns.filter(v => v.severity === "Critical");
            const highVulns = vulns.filter(v => v.severity === "High");
            const mediumVulns = vulns.filter(v => v.severity === "Medium");
            const lowVulns = vulns.filter(v => v.severity === "Low");
            
            const criticalVPR = criticalVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const highVPR = highVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const mediumVPR = mediumVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const lowVPR = lowVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            const primaryVuln = vulns[0];
            const description = primaryVuln.description || primaryVuln.plugin_name || "No description available";

            // Create a cryptographically secure ID for vulnerability data
            const vulnDataId = this.generateSecureVulnId("vuln");
            // Store the vulnerability data temporarily for modal access
            window.vulnModalData = window.vulnModalData || {};
            window.vulnModalData[vulnDataId] = primaryVuln;

            // Check if this vulnerability is in KEV catalog
            const isKev = primaryVuln.isKev === "Yes";
            // const kevBadge = isKev ? `<span class="kev-badge" onclick="event.stopPropagation(); showKevDetails('${cve}')">🔥 KEV</span>` : '';
            const kevBadge = isKev ? `
                <div class="kev-indicator" role="button" tabindex="0"
                     onclick="event.stopPropagation(); showKevDetails('${cve}')"
                     onkeydown="if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); event.stopPropagation(); showKevDetails('${cve}'); }">
                    <span class="badge kev-badge">
                        <i class="fas fa-shield-halved me-1"></i>
                        KEV
                    </span>
                </div>
            ` : "";

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card vulnerability-card" style="cursor: pointer; position: relative;" data-vuln-id="${vulnDataId}" onclick="vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                    ${kevBadge}
                    <div class="card-body">
                        <div class="vulnerability-title">
                            ${description.substring(0, 100)}${description.length > 100 ? "..." : ""}
                        </div>
                        
                        <div class="vulnerability-meta">
                            <div class="vulnerability-identifiers">
                                <span class="badge severity-${primaryVuln.severity.toLowerCase()} me-2">
                                    ${primaryVuln.severity}
                                </span>
                                ${this.generateVulnerabilityLinkHTML(cve, primaryVuln)}
                            </div>
                            <div class="text-end">
                                <div class="vulnerability-vpr text-primary">
                                    ${totalVPR.toFixed(1)}
                                </div>
                                <div class="text-muted small">Total VPR</div>
                            </div>
                        </div>

                        <div class="device-display-enhanced">
                            <i class="fas fa-server fs-4 text-primary"></i>
                            <span class="device-count-large">
                                ${vulns.length} device${vulns.length !== 1 ? "s" : ""}
                            </span>
                        </div>

                        ${this.generateVulnerabilityActionsHTML(cve, primaryVuln, vulnDataId)}
                    </div>
                </div>
            </div>
            `;
        }).join("");
    }

    /**
     * Generate vulnerability link HTML (CVE or Cisco SA)
     * Handles multiple CVEs with proper individual link creation
     * @param {string} cve - CVE identifier(s) - may be comma/space separated
     * @param {Object} primaryVuln - Primary vulnerability object
     * @returns {string} HTML string for vulnerability link(s)
     */
    generateVulnerabilityLinkHTML(cve, primaryVuln) {
        // Use CVE utilities for multiple CVE handling
        if (cve && (cve.includes("CVE-") || cve.includes("cisco-sa-"))) {
            // Check if CVEUtilities is available
            if (typeof CVEUtilities !== "undefined" && CVEUtilities.createMultipleCVELinks) {
                return CVEUtilities.createMultipleCVELinks(cve, {
                    cssClass: "vulnerability-cve",
                    external: true
                });
            } else {
                // Fallback for single CVE (backward compatibility) - open in popup
                if (cve.startsWith("CVE-")) {
                    const cveUrl = `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve}`;
                    return `<a href="#" class="vulnerability-cve"
                               onclick="event.stopPropagation(); window.open('${cveUrl}', 'cve_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes'); return false;"
                               title="View CVE details on MITRE">
                                ${cve}
                            </a>`;
                }
            }
        }
        
        // Check for Cisco SA ID in plugin name as fallback
        if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
            const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
            if (ciscoSaMatch) {
                const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                const ciscoUrl = `https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/${ciscoId}`;
                return `<a href="#" class="vulnerability-cve text-warning"
                           onclick="event.stopPropagation(); window.open('${ciscoUrl}', 'cisco_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes'); return false;"
                           title="View Cisco Security Advisory">
                            ${ciscoId}
                        </a>`;
            }
        }
        
        return `<span class="text-muted">Plugin ${primaryVuln.plugin_id}</span>`;
    }

    /**
     * Generate vulnerability card actions HTML
     * @param {string} cve - CVE identifier
     * @param {Object} primaryVuln - Primary vulnerability object
     * @param {string} vulnDataId - Vulnerability data ID
     * @returns {string} HTML string for card actions
     */
    generateVulnerabilityActionsHTML(cve, primaryVuln, vulnDataId) {
        // Check if we have CVE - open external CVE link in popup
        if (cve && cve.startsWith("CVE-")) {
            const cveUrl = `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve}`;
            return `<div class="card-actions">
                        <button class="btn btn-primary"
                                onclick="event.stopPropagation(); window.open('${cveUrl}', 'cve_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes');">
                            <i class="fas fa-external-link-alt me-1"></i>View CVE Details
                        </button>
                    </div>`;
        }
        
        // Check for Cisco SA ID in plugin name
        if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
            const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
            if (ciscoSaMatch) {
                const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                const ciscoUrl = `https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/${ciscoId}`;
                return `<div class="card-actions">
                            <button class="btn btn-primary"
                                    onclick="event.stopPropagation(); window.open('${ciscoUrl}', 'cisco_popup', 'width=1200,height=1200,scrollbars=yes,resizable=yes');">
                                <i class="fas fa-external-link-alt me-1"></i>View Cisco Advisory
                            </button>
                        </div>`;
            }
        }
        
        // Default action for no external reference
        return `<div class="card-actions">
                    <button class="btn btn-primary" onclick="event.stopPropagation(); vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                        <i class="fas fa-eye me-1"></i>View Vulnerability Details
                    </button>
                </div>`;
    }

    /**
     * Initialize Sortable.js for drag-and-drop functionality with theme-aware CSS classes
     * @param {HTMLElement} container - Container element to make sortable
     *
     * @description Applies Sortable.js with CSS classes that work with HexTrackr's theme system:
     * - `.sortable-ghost`: Semi-transparent placeholder during drag (from shared/animations.css)
     * - `.sortable-chosen`: Selected item styling using --hextrackr-primary colors
     * - `.sortable-drag`: Active drag state styling with theme-aware shadows
     *
     * @example
     * // CSS classes applied during sorting:
     * // .sortable-ghost { opacity: 0.5; background: var(--hextrackr-surface-2); }
     * // .sortable-chosen { transform: scale(1.02); box-shadow: var(--hextrackr-shadow-md); }
     */
    initializeSortable(container) {
        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }

    /**
     * Update pagination info footer with database statistics
     * @param {string} elementId - ID of the pagination info element to update
     * @returns {void}
     */
    updatePaginationInfo(elementId) {
        const paginationDisplay = document.getElementById(elementId);
        if (!paginationDisplay) {return;}

        // Don't overwrite 50k limit warnings
        if (paginationDisplay.querySelector(".alert-warning")) {
            logger.debug("⚠️ Preserving 50k limit warning, not updating footer");
            return;
        }

        // Get all vulnerabilities for metadata calculation
        const allVulns = this.dataManager.getAllVulnerabilities();
        const totalCount = this.dataManager.getTotalCount();

        // Calculate vendor breakdown
        const vendorCounts = { CISCO: 0, "Palo Alto": 0, Other: 0 };
        let lastImportDate = null;

        allVulns.forEach(vuln => {
            // Vendor counting using dataManager's normalization logic
            const vendor = this.dataManager.normalizeVendor(vuln.plugin_name || "", vuln.hostname || "");
            if (vendorCounts.hasOwnProperty(vendor)) {
                vendorCounts[vendor]++;
            }

            // Track most recent import date
            if (vuln.scan_date) {
                const scanDate = new Date(vuln.scan_date + 'T00:00:00');
                if (!lastImportDate || scanDate > lastImportDate) {
                    lastImportDate = scanDate;
                }
            }
        });

        // Format last import date
        const lastImport = lastImportDate
            ? lastImportDate.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" })
            : "Unknown";

        // Build database metadata footer
        paginationDisplay.innerHTML = `
            <span class="text-muted small">
                <strong>Database:</strong> ${totalCount.toLocaleString()} total |
                <strong>Last import:</strong> ${lastImport} |
                <strong>CISCO:</strong> ${vendorCounts.CISCO.toLocaleString()} |
                <strong>Palo Alto:</strong> ${vendorCounts["Palo Alto"].toLocaleString()} |
                <strong>Other:</strong> ${vendorCounts.Other.toLocaleString()}
            </span>
        `;
    }

    /**
     * Update cards for current view type.
     * Renders either device cards or vulnerability cards based on the current view mode.
     *
     * @param {string} viewType - Current view type ("devices" or "vulnerabilities")
     * @returns {void}
     */
    updateForCurrentView(viewType) {
        switch (viewType) {
            case "devices":
                this.renderDeviceCards();
                break;
            case "vulnerabilities":
                this.renderVulnerabilityCards();
                break;
        }
    }
}