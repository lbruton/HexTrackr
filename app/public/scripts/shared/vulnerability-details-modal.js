/**
 * Focused Vulnerability Details Modal Module for HexTrackr
 * 
 * This module provides a network admin-friendly vulnerability details modal with essential information,
 * matching the Device Security Modal design patterns and focusing on quick diagnosis and remediation.
 * 
 * @fileoverview Simplified vulnerability details modal for network administrators
 * @author HexTrackr Development Team
 * @version 2.0.0
 */

/* global window, document, bootstrap, agGrid, console */

class VulnerabilityDetailsModal {
    constructor() {
        this.currentVulnerability = null;
        this.affectedAssetsGrid = null;
        this.affectedAssetsGridApi = null;
        
        // T018: Race condition protection
        this.currentOperationId = null;
        this.isModalOperationInProgress = false;
        
        this.init();
    }

    /**
     * Initialize the vulnerability details modal
     */
    init() {
        this.bindEventListeners();
        console.log("VulnerabilityDetailsModal initialized (Network Admin Focused v2.0)");
    }

    /**
     * Bind event listeners for modal interactions
     */
    bindEventListeners() {
        // Export vulnerability CSV button
        const exportVulnCSV = document.getElementById("exportVulnCSV");
        if (exportVulnCSV) {
            exportVulnCSV.addEventListener("click", () => {
                this.exportVulnerabilityCSV();
            });
        }

        // HEX-204: Generate Report button removed (non-functional HTML reports)
    }

    /**
     * Display vulnerability details in the modal with focused UI
     * @param {Object|string} vulnerability - The vulnerability data object or vulnerability ID
     * @param {Object} dataManager - The data manager instance for getting related data
     */
    showVulnerabilityDetails(vulnerability, dataManager) {
        let vulnData;
        
        console.log("üöÄ showVulnerabilityDetails called with:", typeof vulnerability, vulnerability);
        
        // Handle both direct vulnerability object and ID-based lookup
        if (typeof vulnerability === "string") {
            // New approach: get vulnerability from temporary storage
            vulnData = window.vulnModalData && window.vulnModalData[vulnerability];
            if (!vulnData) {
                console.error("Vulnerability data not found for ID:", vulnerability);
                return;
            }
            console.log("üîç Retrieved vulnerability data:", vulnData);
        } else if (typeof vulnerability === "object" && vulnerability !== null) {
            // Legacy approach: direct object passed
            vulnData = vulnerability;
            console.log("üîç Direct vulnerability object:", vulnData);
        } else {
            console.error("Invalid vulnerability parameter:", vulnerability);
            return;
        }

        this.currentVulnerability = vulnData;
        this.populateVulnerabilityInfo(vulnData);
        this.populateRiskSummary(vulnData);
        this.createAffectedAssetsGrid(vulnData, dataManager);
        this.showModal();
    }

    /**
     * Populate vulnerability information section
     * @param {Object} vulnerability - The vulnerability data object
     */
    populateVulnerabilityInfo(vulnerability) {
        const vulnLink = this.getVulnerabilityLink(vulnerability);

        // Add KEV badge to the card title if this is a KEV vulnerability
        this.updateKevBadge(vulnerability);

        document.getElementById("vulnInfo").innerHTML = `
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Vulnerability ID:</div>
                    <div class="col-sm-8">
                        ${vulnLink.url ? 
                            `<a href="#" class="text-primary text-decoration-none fw-bold" 
                               onclick="vulnDetailsModal.lookupVulnerability('${DOMPurify.sanitize(vulnLink.id)}')">${DOMPurify.sanitize(vulnLink.id)}</a>` :
                            `<span class="fw-bold">${DOMPurify.sanitize(vulnLink.id)}</span>`
                        }
                        ${vulnLink.type === "cisco" ? 
                            "<small class=\"badge bg-warning-lt text-warning ms-2\">Cisco Advisory</small>" : 
                            vulnLink.type === "plugin" ? 
                            "<small class=\"badge bg-secondary-lt text-secondary ms-2\">Plugin ID</small>" : ""
                        }
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Plugin Name:</div>
                    <div class="col-sm-8 fw-bold">${DOMPurify.sanitize(vulnerability.plugin_name || vulnerability.description || "N/A")}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Description:</div>
                    <div class="col-sm-8"><small class="text-muted">${DOMPurify.sanitize(this.truncateText(vulnerability.description || "No description available", 200))}</small></div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Solution:</div>
                    <div class="col-sm-8"><small class="text-success">${DOMPurify.sanitize(this.truncateText(vulnerability.solution_text || vulnerability.solution || "No solution provided", 200))}</small></div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Severity:</div>
                    <div class="col-sm-8">
                        <span class="severity-badge severity-${(vulnerability.severity || "Low").toLowerCase()}">${vulnerability.severity || "Low"}</span>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Populate risk summary cards with theme-aware styling
     * @param {Object} vulnerability - The vulnerability data object
     */
    populateRiskSummary(vulnerability) {
        const vprScore = parseFloat(vulnerability.vpr_score) || 0;
        const severity = vulnerability.severity || "Low";

        // Determine VPR and severity colors using our centralized system
        const vprColor = vprScore >= 9 ? "red" : vprScore >= 7 ? "orange" : vprScore >= 4 ? "yellow" : "green";
        const severityColor = severity === "Critical" ? "red" :
                            severity === "High" ? "orange" :
                            severity === "Medium" ? "yellow" : "green";

        // Get device count (mock data for now, will be updated when real data integration is available)
        const affectedDevices = this.getAffectedDevicesCount(vulnerability);

        // HEX-204: Updated to full-width layout (matches Device modal)
        document.getElementById("vulnRiskSummary").innerHTML = `
            <div class="col-lg-3 col-6">
                <div class="card card-sm bg-${vprColor}-lt">
                    <div class="card-body text-center">
                        <div class="text-${vprColor} h3 mb-1">${vprScore.toFixed(1)}</div>
                        <div class="text-muted small">VPR Score</div>
                        <div class="text-${vprColor} fw-bold">${vprScore >= 9 ? "Critical Risk" : vprScore >= 7 ? "High Risk" : vprScore >= 4 ? "Medium Risk" : "Low Risk"}</div>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-6">
                <div class="card card-sm bg-${severityColor}-lt">
                    <div class="card-body text-center">
                        <div class="text-${severityColor} h3 mb-1">${affectedDevices}</div>
                        <div class="text-muted small">Devices</div>
                        <div class="text-${severityColor} fw-bold">${severity} Risk</div>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-6">
                <div class="card card-sm bg-blue-lt">
                    <div class="card-body text-center">
                        <div class="text-blue h3 mb-1">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString("en-US", {month: "short", day: "numeric", year: "numeric"}) : "N/A"}</div>
                        <div class="text-muted small">First Seen</div>
                    </div>
                </div>
            </div>
            <div class="col-lg-3 col-6">
                <div class="card card-sm bg-blue-lt">
                    <div class="card-body text-center">
                        <div class="text-blue h3 mb-1">${vulnerability.last_seen ? new Date(vulnerability.last_seen).toLocaleDateString("en-US", {month: "short", day: "numeric", year: "numeric"}) : vulnerability.scan_date ? new Date(vulnerability.scan_date).toLocaleDateString("en-US", {month: "short", day: "numeric", year: "numeric"}) : "N/A"}</div>
                        <div class="text-muted small">Last Seen</div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Create and configure the affected assets grid with main table styling
     * @param {Object} vulnerability - The vulnerability data object
     * @param {Object} dataManager - The data manager instance
     */
    createAffectedAssetsGrid(vulnerability, dataManager) {
        console.log("üèóÔ∏è createAffectedAssetsGrid called with:", {
            vulnerabilityKeys: Object.keys(vulnerability || {}),
            hasDataManager: !!dataManager,
            hasCurrentData: !!(dataManager && dataManager.currentData),
            hasVulns: !!(dataManager && dataManager.currentData && dataManager.currentData.vulnerabilities),
            totalVulns: dataManager && dataManager.currentData && dataManager.currentData.vulnerabilities ? dataManager.currentData.vulnerabilities.length : 0
        });
        
        const gridDiv = document.getElementById("vuln-affected-assets-grid");
        gridDiv.innerHTML = "";

        // Get affected assets data
        console.log("üèóÔ∏è Calling getAffectedAssets...");
        const affectedAssets = this.getAffectedAssets(vulnerability, dataManager);
        console.log("üèóÔ∏è getAffectedAssets returned:", affectedAssets.length, "assets");
        
        // Update the count
        document.getElementById("affectedAssetsCount").textContent = affectedAssets.length;

        // HEX-204: Updated columns - removed First Seen, added Installed Version and Fixed Version (placeholder)
        const columnDefs = [
            {
                headerName: "Last Seen",
                field: "last_seen",
                width: 120,
                cellRenderer: (params) => {
                    if (params.value && params.value.trim() !== "") {
                        return new Date(params.value).toLocaleDateString();
                    } else if (params.data.scan_date && params.data.scan_date.trim() !== "") {
                        return new Date(params.data.scan_date).toLocaleDateString();
                    }
                    return "N/A";
                }
            },
            {
                headerName: "VPR",
                field: "vpr_score",
                width: 80,
                cellRenderer: (params) => {
                    const score = parseFloat(params.value) || 0;
                    const severityClass = this.getVprSeverityClass(score);
                    return `<span class="severity-badge severity-${severityClass}">${score.toFixed(1)}</span>`;
                }
            },
            {
                headerName: "Hostname",
                field: "hostname",
                width: 160,
                cellRenderer: (params) => {
                    // T020: Context-aware device links that preserve CVE selection
                    return `<a href="#" class="text-primary fw-bold text-decoration-none"
                           onclick="vulnDetailsModal.navigateToDeviceWithCVEContext('${DOMPurify.sanitize(params.value)}')"
                           title="View device details (CVE context preserved)">
                           ${DOMPurify.sanitize(params.value)}</a>`;
                }
            },
            {
                headerName: "Installed Version",
                field: "operating_system",
                width: 180,
                cellRenderer: (params) => {
                    const version = params.value || "N/A";
                    return `<span class="font-monospace text-info">${DOMPurify.sanitize(version)}</span>`;
                }
            },
            {
                headerName: "Fixed Version",
                field: "fixed_version",
                width: 180,
                cellRenderer: (params) => {
                    // HEX-204 Phase 2: Query Cisco advisory for fixed version
                    const cveId = params.data.cve;
                    const vendor = params.data.vendor;
                    const cellId = `fixed-version-cell-${params.node.id}`;

                    // Queue async lookup (non-blocking)
                    setTimeout(async () => {
                        if (!window.ciscoAdvisoryHelper) {
                            const cell = document.getElementById(cellId);
                            if (cell) {
                                cell.innerHTML = `<span class="font-monospace text-muted">N/A</span>`;
                            }
                            return;
                        }

                        try {
                            // Pass operating_system for OS-aware version matching
                            const installedVersion = params.data.operating_system;
                            const fixedVersion = await window.ciscoAdvisoryHelper.getFixedVersion(cveId, vendor, installedVersion);
                            const cell = document.getElementById(cellId);

                            if (cell) {
                                if (fixedVersion) {
                                    cell.innerHTML = `<span class="font-monospace text-success">${DOMPurify.sanitize(fixedVersion)}+</span>`;
                                } else if (vendor && vendor.toLowerCase().includes('cisco')) {
                                    cell.innerHTML = `<span class="font-monospace text-muted">No Fix</span>`;
                                } else {
                                    cell.innerHTML = `<span class="font-monospace text-muted">N/A</span>`;
                                }
                            }
                        } catch (error) {
                            console.error(`Failed to load fixed version for ${cveId}:`, error);
                            const cell = document.getElementById(cellId);
                            if (cell) {
                                cell.innerHTML = `<span class="font-monospace text-muted">Error</span>`;
                            }
                        }
                    }, 0);

                    // Return spinner initially
                    return `<span id="${cellId}" class="font-monospace text-muted"><span class="spinner-border spinner-border-sm"></span></span>`;
                }
            }
        ];

        // Detect current theme for v33 theming
        const currentTheme = this.detectCurrentTheme();
        const _isDarkMode = currentTheme === "dark";  // Prefixed with _ to indicate intentionally unused

        const gridOptions = {
            theme: window.agGridThemeManager ? window.agGridThemeManager.getCurrentTheme() : null, // AG-Grid v33 theme configuration
            columnDefs: columnDefs,
            rowData: affectedAssets,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 25,
            paginationPageSizeSelector: false, // Remove page size dropdown for fixed-height modal
            animateRows: true,
            onGridReady: (params) => {
                this.affectedAssetsGridApi = params.api;

                // Register grid with AGGridThemeManager for dynamic theme updates
                if (window.agGridThemeManager) {
                    window.agGridThemeManager.registerGrid("vulnerabilityDetailsModal", this.affectedAssetsGridApi, gridDiv);
                }

                // Ensure columns fill available width in modal
                setTimeout(() => {
                    if (params.api) {
                        params.api.sizeColumnsToFit();
                    }
                }, 100);
            },
            onGridSizeChanged: (params) => {
                // Resize columns when modal grid size changes
                if (params.api) {
                    params.api.sizeColumnsToFit();
                }
            },
            onFirstDataRendered: (params) => {
                // Ensure columns fill available width when data loads
                if (params.api) {
                    params.api.sizeColumnsToFit();
                }
            }
        };

        this.affectedAssetsGrid = agGrid.createGrid(gridDiv, gridOptions);
    }


    /**
     * Detect current theme from DOM
     * @returns {string} 'dark' or 'light'
     */
    detectCurrentTheme() {
        return document.documentElement.getAttribute("data-bs-theme") === "dark" ? "dark" : "light";
    }

    /**
     * Get affected assets data for the vulnerability
     * @param {Object} vulnerability - The vulnerability data
     * @param {Object} dataManager - The data manager instance
     * @returns {Array} Array of affected asset objects
     */
    getAffectedAssets(vulnerability, dataManager) {
        // Check for VulnerabilityDataManager structure (has vulnerabilities directly)
        const allVulnerabilities = dataManager && dataManager.vulnerabilities ? 
            dataManager.vulnerabilities : 
            (dataManager && dataManager.currentData && dataManager.currentData.vulnerabilities ? 
                dataManager.currentData.vulnerabilities : null);
                
        if (!allVulnerabilities || allVulnerabilities.length === 0) {
            console.log("üîç No vulnerability data available in dataManager");
            console.log("üîç DataManager structure:", {
                hasDataManager: !!dataManager,
                hasVulnerabilities: !!(dataManager && dataManager.vulnerabilities),
                hasCurrentData: !!(dataManager && dataManager.currentData),
                vulnCount: dataManager && dataManager.vulnerabilities ? dataManager.vulnerabilities.length : 0
            });
            // Fallback to single asset if no data manager
            if (vulnerability.hostname && vulnerability.ip_address) {
                return [{
                    hostname: vulnerability.hostname,
                    ip_address: vulnerability.ip_address,
                    vpr_score: vulnerability.vpr_score || 0,
                    severity: vulnerability.severity || "Low",
                    last_seen: vulnerability.last_seen || vulnerability.scan_date,
                    first_seen: vulnerability.first_seen,
                    scan_date: vulnerability.scan_date,
                    operating_system: vulnerability.operating_system || null  // HEX-204: Include device-level OS version
                }];
            }
            return [];
        }

        console.log("üîç Found vulnerability data:", allVulnerabilities.length, "total vulnerabilities");
        
        // Extract the key identifiers from the input vulnerability to match against
        const vulnKey = this.getVulnerabilityMatchingKey(vulnerability);
        
        if (!vulnKey) {
            console.warn("Could not determine vulnerability matching key:", vulnerability);
            return [];
        }
        
        // Find all vulnerabilities that match by the same vulnerability identity
        const matchingVulns = allVulnerabilities.filter(vuln => {
            const currentKey = this.getVulnerabilityMatchingKey(vuln);
            return currentKey && currentKey === vulnKey;
        });

        console.log(`Found ${matchingVulns.length} matching vulnerabilities for key: ${vulnKey}`);
        
        // Debug alert to see if this method is being called
        if (matchingVulns.length > 1) {
            console.log(`üéØ AGGREGATION DEBUG: Found ${matchingVulns.length} matching vulns for key: ${vulnKey}`);
            console.log(`üéØ Sample hostnames: ${matchingVulns.slice(0, 5).map(v => v.hostname).join(", ")}`);
        }

        // Create unique list of affected assets
        const uniqueAssets = new Map();
        
        matchingVulns.forEach(vuln => {
            if (vuln.hostname) {
                const key = vuln.hostname.toLowerCase();
                if (!uniqueAssets.has(key) || (vuln.last_seen && vuln.last_seen > (uniqueAssets.get(key).last_seen || ""))) {
                    uniqueAssets.set(key, {
                        hostname: vuln.hostname,
                        ip_address: vuln.ip_address || "N/A",
                        vpr_score: vuln.vpr_score || 0,
                        severity: vuln.severity || "Low",
                        last_seen: vuln.last_seen || vuln.scan_date,
                        first_seen: vuln.first_seen,
                        scan_date: vuln.scan_date,
                        operating_system: vuln.operating_system || null  // HEX-204: Include device-level OS version
                    });
                }
            }
        });

        return Array.from(uniqueAssets.values());
    }

    /**
     * Get a consistent matching key for vulnerability identity across devices
     * This uses the same priority logic as the main table: CVE > Cisco SA > Description
     * @param {Object} vuln - The vulnerability object
     * @returns {string|null} Matching key or null
     */
    getVulnerabilityMatchingKey(vuln) {
        console.log("üîë Getting matching key for vuln:", {
            hostname: vuln.hostname, 
            cve: vuln.cve, 
            plugin_name: vuln.plugin_name?.substring(0, 50),
            description: vuln.description?.substring(0, 50)
        });
        
        // Priority 1: CVE ID if available
        if (vuln.cve && vuln.cve.startsWith("CVE-")) {
            console.log("üîë Matched by CVE:", vuln.cve);
            return vuln.cve;
        }
        
        // Priority 2: Cisco SA ID extracted from plugin_name
        if (vuln.plugin_name && typeof vuln.plugin_name === "string") {
            const ciscoSaMatch = vuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
            if (ciscoSaMatch) {
                const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                console.log("üîë Matched by Cisco SA:", ciscoId);
                return ciscoId;
            }
        }
        
        // Priority 3: Description as universal fallback (most reliable for grouping)
        if (vuln.description && vuln.description.trim()) {
            console.log("üîë Matched by description:", vuln.description.trim().substring(0, 50));
            return vuln.description.trim();
        }
        
        // Priority 4: Plugin name as final fallback
        if (vuln.plugin_name && vuln.plugin_name.trim()) {
            console.log("üîë Matched by plugin_name:", vuln.plugin_name.trim().substring(0, 50));
            return vuln.plugin_name.trim();
        }
        
        console.log("üîë No matching key found");
        return null;
    }

    /**
     * Get the count of affected devices for this vulnerability
     * @param {Object} vulnerability - The vulnerability data
     * @returns {number} Number of affected devices
     */
    getAffectedDevicesCount(vulnerability) {
        // Use the same logic as getAffectedAssets but just return count
        if (!window.vulnManager || !window.vulnManager.dataManager) {
            return vulnerability.hostname ? 1 : 0;
        }

        const allVulns = window.vulnManager.dataManager.vulnerabilities || [];
        const vulnKey = this.getVulnerabilityMatchingKey(vulnerability);
        
        if (!vulnKey) {
            return vulnerability.hostname ? 1 : 0;
        }
        
        const uniqueHosts = new Set();
        
        allVulns.forEach(vuln => {
            if (vuln.hostname) {
                const currentKey = this.getVulnerabilityMatchingKey(vuln);
                if (currentKey && currentKey === vulnKey) {
                    uniqueHosts.add(vuln.hostname.toLowerCase());
                }
            }
        });

        return uniqueHosts.size;
    }

    /**
     * Get VPR severity class based on score
     * @param {number} score - VPR score
     * @returns {string} Severity class name
     */
    getVprSeverityClass(score) {
        if (score >= 9.0) {return "critical";}
        if (score >= 7.0) {return "high";}
        if (score >= 4.0) {return "medium";}
        return "low";
    }

    /**
     * Truncate text to specified length
     * @param {string} text - Text to truncate
     * @param {number} maxLength - Maximum length
     * @returns {string} Truncated text
     */
    truncateText(text, maxLength) {
        if (!text || text.length <= maxLength) {return text;}
        return text.substring(0, maxLength) + "...";
    }

    /**
     * Update KEV badge in the Vulnerability Information card header
     * Reuses the existing KEV badge component from vulnerability cards for UI consistency
     * @param {Object} vulnerability - The vulnerability data object containing isKev property
     * @since 1.0.30
     */
    updateKevBadge(vulnerability) {
        // Find all card headers in the modal
        const cardHeaders = document.querySelectorAll("#vulnDetailsModal .card-header");

        // Find the specific "Vulnerability Information" card header
        let targetHeader = null;
        cardHeaders.forEach(header => {
            const title = header.querySelector(".card-title");
            if (title && title.textContent.includes("Vulnerability Information")) {
                targetHeader = header;
            }
        });

        if (targetHeader) {
            // Remove any existing KEV badge
            const existingBadge = targetHeader.querySelector(".kev-badge");
            if (existingBadge) {
                existingBadge.remove();
            }

            // Add KEV badge if this is a KEV vulnerability
            if (vulnerability.isKev === "Yes") {
                // Make the card-header a flex container with space-between
                targetHeader.style.display = "flex";
                targetHeader.style.justifyContent = "space-between";
                targetHeader.style.alignItems = "center";

                const cve = vulnerability.cve || vulnerability.vulnerability_id || "";
                // Reuse the exact KEV badge HTML structure from vulnerability-cards.js
                // Uses the same .kev-badge CSS class for consistency across the application
                const kevBadgeHtml = `
                    <span class="badge kev-badge" role="button" tabindex="0"
                          onclick="showKevDetails('${DOMPurify.sanitize(cve)}')"
                          onkeydown="if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); showKevDetails('${DOMPurify.sanitize(cve)}'); }">
                        <i class="fas fa-shield-halved me-1"></i>
                        KEV
                    </span>
                `;
                // Insert the badge as a sibling to the title
                targetHeader.insertAdjacentHTML("beforeend", kevBadgeHtml);
            } else {
                // Reset the header styling if no KEV badge
                targetHeader.style.display = "";
                targetHeader.style.justifyContent = "";
                targetHeader.style.alignItems = "";
            }
        }
    }

    /**
     * Set dynamic modal title based on CVE/vulnerability ID
     * T017: Dynamic title showing specific CVE information
     * @param {string} title - The title to set for the modal
     */
    setModalTitle(title) {
        const modalTitleElement = document.querySelector("#vulnDetailsModal .modal-title");
        if (modalTitleElement) {
            modalTitleElement.textContent = title || "Vulnerability Details";
        } else {
            console.warn("Modal title element not found - title not updated");
        }
    }

    /**
     * Show the vulnerability modal with dynamic title
     * T017: Enhanced with dynamic title support
     * @param {string} [customTitle] - Optional custom title for the modal
     */
    showModal(_customTitle) {  // Prefixed with _ to indicate intentionally unused
        // Add theme detection
        const currentTheme = document.documentElement.getAttribute("data-bs-theme") || "light";
        const modalElement = document.getElementById("vulnDetailsModal");

        // Propagate theme to modal
        if (modalElement) {
            modalElement.setAttribute("data-bs-theme", currentTheme);
        }

        // Close any existing device modal before opening vulnerability modal
        const existingDeviceModal = bootstrap.Modal.getInstance(document.getElementById("deviceModal"));
        if (existingDeviceModal) {
            existingDeviceModal.hide();
        }

        // Also close legacy vulnerability modal if it exists
        const existingVulnModal = bootstrap.Modal.getInstance(document.getElementById("vulnerabilityModal"));
        if (existingVulnModal) {
            existingVulnModal.hide();
        }

        // Always use standard modal title
        this.setModalTitle("Vulnerability Details");

        const modal = new bootstrap.Modal(modalElement);

        // T015: Add memory leak prevention on modal close
        modalElement.addEventListener("hidden.bs.modal", () => {
            this.clearModalStateData();
        }, { once: true }); // Use once: true to prevent multiple listeners

        modal.show();
    }

    /**
     * Export vulnerability data to CSV
     */
    exportVulnerabilityCSV() {
        const modal = document.getElementById("vulnDetailsModal");
        if (!modal.classList.contains("show")) {
            this.showToast("No vulnerability modal is currently open", "warning");
            return;
        }

        if (!this.currentVulnerability) {
            this.showToast("No vulnerability data available for export", "warning");
            return;
        }

        const vulnerability = this.currentVulnerability;
        const csvData = [];
        
        // Add vulnerability header information
        csvData.push(["Vulnerability Information"]);
        csvData.push(["Vulnerability ID", this.getVulnerabilityLink(vulnerability).id]);
        csvData.push(["Plugin Name", vulnerability.plugin_name || "N/A"]);
        csvData.push(["Severity", vulnerability.severity || "Low"]);
        csvData.push(["VPR Score", (vulnerability.vpr_score || 0).toFixed(1)]);
        csvData.push(["CVSS Score", vulnerability.cvss_score || "N/A"]);
        csvData.push(["Description", vulnerability.description || "N/A"]);
        csvData.push(["Solution", vulnerability.solution || "N/A"]);
        csvData.push(["First Seen", vulnerability.first_seen || "N/A"]);
        csvData.push(["Last Seen", vulnerability.last_seen || vulnerability.scan_date || "N/A"]);
        csvData.push([]);

        // Add affected assets data
        const affectedAssets = this.getAffectedAssets(vulnerability, window.vulnManager?.dataManager);
        if (affectedAssets.length > 0) {
            csvData.push(["Affected Assets"]);
            csvData.push(["Hostname", "IP Address", "VPR Score", "Severity", "Last Seen"]);
            
            affectedAssets.forEach(asset => {
                csvData.push([
                    asset.hostname || "N/A",
                    asset.ip_address || "N/A",
                    (asset.vpr_score || 0).toFixed(1),
                    asset.severity || "Low",
                    asset.last_seen ? new Date(asset.last_seen).toLocaleDateString() : "N/A"
                ]);
            });
        }

        // Convert to CSV format
        const csvContent = csvData.map(row => 
            row.map(field => `"${String(field).replace(/"/g, "\"\"")}"`).join(",")
        ).join("\n");

        // Create and download the file
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        const vulnId = this.getVulnerabilityLink(vulnerability).id.replace(/[^a-zA-Z0-9]/g, "_");
        link.href = URL.createObjectURL(blob);
        link.download = `vulnerability-details-${vulnId}-${timestamp}.csv`;
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Vulnerability details exported for ${this.getVulnerabilityLink(vulnerability).id}`, "success");
    }

    /**
     * Generate vulnerability report in a popup window with print capabilities
     */
    generateVulnerabilityReport() {
        const modal = document.getElementById("vulnDetailsModal");
        if (!modal.classList.contains("show")) {
            this.showToast("No vulnerability modal is currently open", "warning");
            return;
        }

        if (!this.currentVulnerability) {
            this.showToast("No vulnerability data available for report generation", "warning");
            return;
        }

        const vulnerability = this.currentVulnerability;
        const reportWindow = window.open("", "_blank", "width=1200,height=800,scrollbars=yes,resizable=yes");
        
        if (!reportWindow) {
            this.showToast("Popup blocked. Please allow popups for this site.", "error");
            return;
        }

        const reportContent = this.generateReportHTML(vulnerability);
        reportWindow.document.write(reportContent);
        reportWindow.document.close();
        
        // Add event listeners after content is loaded
        reportWindow.addEventListener("load", () => {
            this.setupReportWindowControls(reportWindow);
        });

        this.showToast("Vulnerability report generated successfully", "success");
    }

    /**
     * Generate HTML content for the vulnerability report
     * @param {Object} vulnerability - The vulnerability data object
     * @returns {string} HTML content for the report
     */
    generateReportHTML(vulnerability) {
        const timestamp = new Date().toLocaleString();
        const vulnLink = this.getVulnerabilityLink(vulnerability);
        const affectedAssets = this.getAffectedAssets(vulnerability, window.vulnManager?.dataManager);
        
        return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulnerability Report - ${vulnLink.id}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .severity-badge { padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-weight: 500; font-size: 0.75rem; }
        .severity-critical { background-color: #dc3545; color: white; }
        .severity-high { background-color: #fd7e14; color: white; }
        .severity-medium { background-color: #ffc107; color: #000; }
        .severity-low { background-color: #198754; color: white; }
        .no-print { display: block; }
        @media print {
            .no-print { display: none !important; }
            body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        }
        .report-header { border-bottom: 3px solid #dc3545; padding-bottom: 1rem; margin-bottom: 2rem; }
        .summary-card { border-left: 4px solid #dc3545; }
    </style>
    <script>
        function openVulnPopup(url, windowName) {
            const popup = window.open(
                url,
                windowName,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            if (popup) {
                popup.focus();
            }
            return false;
        }
    </script>
</head>
<body>
    <div class="container-fluid">
        <div class="no-print sticky-top bg-white border-bottom p-3 mb-3">
            <div class="d-flex justify-content-between align-items-center">
                <h1 class="h4 mb-0">Vulnerability Report - ${vulnLink.id}</h1>
                <div>
                    <button type="button" class="btn btn-outline-primary me-2" onclick="window.print()">
                        <i class="fas fa-print me-1"></i>Print Report
                    </button>
                    <button type="button" class="btn btn-outline-secondary" onclick="window.close()">
                        <i class="fas fa-times me-1"></i>Close
                    </button>
                </div>
            </div>
        </div>

        <div class="report-header">
            <div class="row">
                <div class="col-md-8">
                    <h1 class="display-6 text-danger">Vulnerability Report</h1>
                    <h2 class="h4 text-muted">${vulnLink.id}</h2>
                </div>
                <div class="col-md-4 text-end">
                    <p class="mb-0"><strong>Generated:</strong> ${timestamp}</p>
                    <p class="mb-0"><strong>Report Type:</strong> Security Vulnerability Analysis</p>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card summary-card h-100">
                    <div class="card-header">
                        <h3 class="card-title">Vulnerability Summary</h3>
                    </div>
                    <div class="card-body">
                        <table class="table table-borderless">
                            <tr><th width="40%">Vulnerability ID:</th><td>
                                ${vulnLink.url ? 
                                    `<a href="#" onclick="openVulnPopup('${DOMPurify.sanitize(vulnLink.url)}', '${DOMPurify.sanitize(vulnLink.id.replace(/[^a-zA-Z0-9]/g, "_"))}')" class="text-primary text-decoration-none fw-bold">${DOMPurify.sanitize(vulnLink.id)} <i class="fas fa-external-link-alt ms-1"></i></a>` :
                                    `<span class="fw-bold">${vulnLink.id}</span>`
                                }
                            </td></tr>
                            <tr><th>Plugin Name:</th><td>${vulnerability.plugin_name || "N/A"}</td></tr>
                            <tr><th>Severity:</th><td><span class="severity-badge severity-${(vulnerability.severity || "low").toLowerCase()}">${vulnerability.severity || "Low"}</span></td></tr>
                            <tr><th>VPR Score:</th><td><span class="severity-badge severity-${this.getVprSeverityClass(vulnerability.vpr_score || 0)}">${(vulnerability.vpr_score || 0).toFixed(1)}</span></td></tr>
                            <tr><th>Affected Devices:</th><td><span class="badge bg-secondary">${affectedAssets.length}</span></td></tr>
                        </table>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card h-100">
                    <div class="card-header">
                        <h3 class="card-title">Timeline</h3>
                    </div>
                    <div class="card-body">
                        <div class="row g-2">
                            <div class="col-12">
                                <div class="card bg-info bg-opacity-10">
                                    <div class="card-body text-center">
                                        <div class="text-info fw-bold">First Seen</div>
                                        <div class="text-muted">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString() : "N/A"}</div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-12">
                                <div class="card bg-warning bg-opacity-10">
                                    <div class="card-body text-center">
                                        <div class="text-warning fw-bold">Last Seen</div>
                                        <div class="text-muted">${vulnerability.last_seen ? new Date(vulnerability.last_seen).toLocaleDateString() : vulnerability.scan_date ? new Date(vulnerability.scan_date).toLocaleDateString() : "N/A"}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Description</h3>
                    </div>
                    <div class="card-body">
                        <p class="border p-3 bg-light">${DOMPurify.sanitize(vulnerability.description || "No description available")}</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Remediation</h3>
                    </div>
                    <div class="card-body">
                        <p class="border p-3 bg-success-lt">${vulnerability.solution || "No solution provided"}</p>
                    </div>
                </div>
            </div>
        </div>

        ${affectedAssets.length > 0 ? `
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">Affected Assets</h3>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-hover mb-0">
                        <thead class="table-dark">
                            <tr>
                                <th>Hostname</th>
                                <th>IP Address</th>
                                <th>VPR Score</th>
                                <th>Severity</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${affectedAssets.map(asset => `
                                <tr>
                                    <td>${asset.hostname || "N/A"}</td>
                                    <td><code>${asset.ip_address || "N/A"}</code></td>
                                    <td><span class="severity-badge severity-${this.getVprSeverityClass(asset.vpr_score || 0)}">${(asset.vpr_score || 0).toFixed(1)}</span></td>
                                    <td><span class="severity-badge severity-${(asset.severity || "low").toLowerCase()}">${asset.severity || "Low"}</span></td>
                                    <td>${asset.last_seen ? new Date(asset.last_seen).toLocaleDateString() : "N/A"}</td>
                                </tr>
                            `).join("")}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        ` : ""}

        <footer class="mt-4 pt-3 border-top text-muted text-center">
            <p>Generated by HexTrackr Security Management Platform</p>
        </footer>
    </div>
</body>
</html>
        `;
    }

    /**
     * Setup controls for the report window
     * @param {Window} reportWindow - The popup report window
     */
    setupReportWindowControls(reportWindow) {
        // Focus the window
        reportWindow.focus();
        
        // Set window title
        const vulnId = this.getVulnerabilityLink(this.currentVulnerability).id;
        reportWindow.document.title = `Vulnerability Report - ${vulnId}`;
    }

    /**
     * Determine vulnerability ID type and create appropriate link
     * @param {Object} vulnData - The vulnerability data
     * @returns {Object} Link object with id, type, and url
     */
    getVulnerabilityLink(vulnData) {
        const { cve, plugin_name, plugin_id } = vulnData;
        
        // Check for CVE first
        if (cve && cve.startsWith("CVE-")) {
            return {
                id: cve,
                type: "cve",
                url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${encodeURIComponent(cve.trim())}`
            };
        }
        
        // Check for Cisco SA ID in plugin name
        const ciscoId = this.extractCiscoVulnId(plugin_name);
        if (ciscoId) {
            return {
                id: ciscoId,
                type: "cisco",
                url: `https://www.cisco.com/c/en/us/support/docs/csa/${encodeURIComponent(ciscoId)}.html`
            };
        }
        
        // Fall back to plugin ID
        return {
            id: plugin_id ? `Plugin ${plugin_id}` : "Unknown",
            type: "plugin",
            url: null
        };
    }

    /**
     * Extract Cisco vulnerability ID from plugin name
     * @param {string} pluginName - The plugin name
     * @returns {string|null} Cisco vulnerability ID or null
     */
    extractCiscoVulnId(pluginName) {
        if (!pluginName || typeof pluginName !== "string") {
            return null;
        }
        
        // Look for cisco-sa- pattern in plugin name
        const ciscoSaMatch = pluginName.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
        if (ciscoSaMatch) {
            return `cisco-sa-${ciscoSaMatch[1]}`;
        }
        
        return null;
    }

    /**
     * Lookup vulnerability in external resources
     * @param {string} vulnId - The vulnerability ID
     */
    async lookupVulnerability(vulnId) {
        // If CVE, use existing CVE lookup
        if (vulnId && vulnId.startsWith("CVE-")) {
            return this.lookupCVE(vulnId);
        }
        
        // If it looks like a Cisco SA ID, open Cisco advisory
        if (vulnId && vulnId.startsWith("cisco-sa-")) {
            const popup = window.open(
                `https://www.cisco.com/c/en/us/support/docs/csa/${vulnId}.html`,
                `Cisco_Advisory_${vulnId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            
            if (popup) {
                popup.focus();
                this.showToast(`Opened Cisco advisory for ${vulnId}`, "success");
            } else {
                this.showToast("Popup blocked - please allow popups for vulnerability lookups", "warning");
            }
            return;
        }
        
        // Default fallback
        this.showToast("No external vulnerability reference available for this item", "info");
    }

    /**
     * Lookup CVE information
     * @param {string} cveId - The CVE ID
     */
    async lookupCVE(cveId) {
        const popup = window.open(
            `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId}`,
            `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
            "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
        );
        
        if (popup) {
            popup.focus();
            this.showToast(`Opened CVE lookup for ${cveId}`, "success");
        } else {
            this.showToast("Popup blocked - please allow popups for CVE lookups", "warning");
        }
    }

    /**
     * Show vulnerability details filtered by CVE ID with optimized data loading
     * T015: Fix modal state to display single CVE instead of all CVEs
     * T016: Update modal data population to filter by clicked CVE ID
     * T017: Enhanced with dynamic title showing specific CVE ID
     * T018: Added race condition protection and enhanced cleanup
     * T019: CVE-specific data loading optimization in modal initialization
     * T020: Modal navigation maintains CVE selection context
     * @param {string} cveId - The specific CVE ID to show
     * @param {Object} dataManager - The data manager instance
     */
    showVulnerabilityDetailsByCVE(cveId, dataManager) {
        console.log("üéØ showVulnerabilityDetailsByCVE called with CVE:", cveId);
        
        // T018: Race condition protection - cancel any ongoing operation
        const operationId = Date.now() + Math.random();
        this.currentOperationId = operationId;
        this.isModalOperationInProgress = true;
        
        // T018: Clear any existing modal state first to prevent contamination
        this.clearModalStateData({ preserveOperationContext: true });
        
        // Validate CVE ID
        if (!cveId || typeof cveId !== "string") {
            console.error("Invalid CVE ID provided:", cveId);
            this.showToast("Invalid vulnerability ID", "error");
            this.isModalOperationInProgress = false;
            return;
        }
        
        // Validate data manager
        if (!dataManager || !dataManager.vulnerabilities) {
            console.error("Data manager not available or has no vulnerabilities");
            this.showToast("Vulnerability data not available", "warning");
            this.isModalOperationInProgress = false;
            return;
        }
        
        // T018: Check if this operation was cancelled by a newer one
        if (this.currentOperationId !== operationId) {
            console.log("üö´ Operation cancelled - newer operation in progress");
            return;
        }
        
        // T019: CVE-specific data loading optimization - intelligent data filtering
        console.log("üöÄ T019: Starting CVE-specific data loading optimization for:", cveId);
        const startTime = performance.now();
        
        // T019: Optimize vulnerability filtering with early exit strategies
        const matchingVulns = this.optimizedCVEFilter(dataManager.vulnerabilities, cveId);
        
        const filterTime = performance.now() - startTime;
        console.log(`‚ö° T019: CVE filtering completed in ${filterTime.toFixed(2)}ms for ${matchingVulns.length} matches`);
        
        if (matchingVulns.length === 0) {
            console.warn(`No vulnerability found for CVE ID: ${cveId}`);
            this.showToast(`No vulnerability data found for ${cveId}`, "warning");
            return;
        }
        
        console.log(`üîç Found ${matchingVulns.length} vulnerabilities matching CVE: ${cveId}`);
        
        // Use the first matching vulnerability as the primary vulnerability
        const primaryVuln = matchingVulns[0];
        
        // T019: Create optimized filtered data manager with lazy-loading capabilities
        const filteredDataManager = this.createOptimizedDataManager(dataManager, matchingVulns, cveId);
        
        // T020: Store CVE context for navigation preservation
        this.currentCVEContext = {
            cveId: cveId,
            originalDataManager: dataManager,
            filteredCount: matchingVulns.length,
            timestamp: Date.now()
        };
        
        console.log("üéØ T020: CVE navigation context established:", this.currentCVEContext);
        
        // T018: Final race condition check before showing modal
        if (this.currentOperationId !== operationId) {
            console.log("üö´ Operation cancelled before modal display");
            return;
        }
        
        // Set current vulnerability for memory leak prevention
        this.currentVulnerability = primaryVuln;
        
        // Show the modal with filtered data and dynamic title
        this.populateVulnerabilityInfo(primaryVuln);
        this.populateRiskSummary(primaryVuln);
        this.createAffectedAssetsGrid(primaryVuln, filteredDataManager);
        
        // T017: Show modal with specific CVE title
        this.showModal(`${cveId} Details`);
        
        // T018: Mark operation as complete
        this.isModalOperationInProgress = false;
        
        console.log("üéØ Modal opened successfully for CVE:", cveId);
        
        // T017: Validate that displayed content matches requested CVE
        this.validateModalContent(cveId);
    }
    
    /**
     * T019: Optimized CVE filter with intelligent matching and performance tracking
     * @param {Array} vulnerabilities - All vulnerability data
     * @param {string} cveId - CVE ID to filter by
     * @returns {Array} Matching vulnerabilities
     */
    optimizedCVEFilter(vulnerabilities, cveId) {
        const upperCveId = cveId.trim().toUpperCase();
        const isCiscoSA = cveId.toLowerCase().startsWith("cisco-sa-");
        
        // T019: Early exit optimization for empty datasets
        if (!vulnerabilities || vulnerabilities.length === 0) {
            console.log("‚ö° T019: Early exit - no vulnerabilities to filter");
            return [];
        }
        
        // T019: Optimized filtering with reduced iterations
        const results = [];
        let exactMatches = 0;
        let ciscoMatches = 0;
        
        for (const vuln of vulnerabilities) {
            // Priority 1: Exact CVE match (most common case)
            if (vuln.cve && vuln.cve.trim().toUpperCase() === upperCveId) {
                results.push(vuln);
                exactMatches++;
                continue;
            }
            
            // Priority 2: Cisco SA match (only if CVE ID indicates Cisco)
            if (isCiscoSA && vuln.plugin_name) {
                const ciscoSaMatch = vuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
                if (ciscoSaMatch) {
                    const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                    if (ciscoId.toLowerCase() === cveId.toLowerCase()) {
                        results.push(vuln);
                        ciscoMatches++;
                    }
                }
            }
        }
        
        console.log(`üéØ T019: Optimized filter results - Exact: ${exactMatches}, Cisco: ${ciscoMatches}, Total: ${results.length}`);
        return results;
    }
    
    /**
     * T019: Create optimized data manager with lazy-loading and context preservation
     * @param {Object} originalDataManager - Original data manager
     * @param {Array} filteredVulns - Pre-filtered vulnerabilities
     * @param {string} cveId - CVE ID for context
     * @returns {Object} Optimized data manager
     */
    createOptimizedDataManager(originalDataManager, filteredVulns, cveId) {
        console.log("üèóÔ∏è T019: Creating optimized data manager with lazy loading");
        
        // T019: Lightweight data manager that only processes filtered data
        return {
            ...originalDataManager,
            vulnerabilities: filteredVulns,
            // T019: Lazy-loaded computed properties for performance
            get devices() {
                if (!this._cachedDevices) {
                    console.log("‚ö° T019: Lazy-loading device aggregation for filtered data");
                    this._cachedDevices = this._computeFilteredDevices();
                }
                return this._cachedDevices;
            },
            // T019: Optimized device computation for filtered dataset
            _computeFilteredDevices() {
                const deviceMap = new Map();
                filteredVulns.forEach(vuln => {
                    if (vuln.hostname && !deviceMap.has(vuln.hostname)) {
                        deviceMap.set(vuln.hostname, {
                            hostname: vuln.hostname,
                            vulnerabilities: filteredVulns.filter(v => v.hostname === vuln.hostname),
                            cveContext: cveId // T020: Preserve CVE context
                        });
                    }
                });
                return Array.from(deviceMap.values());
            },
            // T020: Context-aware filtering that maintains CVE selection
            filterDataWithContext: (searchTerm, severityFilter) => {
                console.log("üîÑ T020: Context-aware filtering maintaining CVE selection");
                return filteredVulns.filter(vuln => {
                    const matchesSearch = !searchTerm || 
                        vuln.hostname.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        vuln.cve.toLowerCase().includes(searchTerm.toLowerCase());
                    // Handle KEV filtering separately from severity filtering
                    let matchesSeverity;
                    if (severityFilter === "KEV") {
                        matchesSeverity = vuln.isKev === "Yes";
                    } else {
                        matchesSeverity = !severityFilter || vuln.severity === severityFilter;
                    }
                    return matchesSearch && matchesSeverity;
                });
            }
        };
    }
    
    /**
     * T020: Navigate to device details while preserving CVE selection context
     * @param {string} hostname - Device hostname to navigate to
     */
    navigateToDeviceWithCVEContext(hostname) {
        console.log("üß≠ T020: Navigating to device with CVE context preservation:", hostname);
        
        if (!this.currentCVEContext) {
            console.warn("‚ö†Ô∏è T020: No CVE context available - falling back to standard navigation");
            // Fallback to standard device details
            if (window.vulnManager && typeof window.vulnManager.viewDeviceDetails === "function") {
                window.vulnManager.viewDeviceDetails(hostname);
            }
            return;
        }
        
        // T020: Create device modal with CVE context preserved
        const cveContextInfo = {
            sourceCVE: this.currentCVEContext.cveId,
            deviceHostname: hostname,
            filteredVulns: this.currentCVEContext.filteredCount,
            navigationTime: Date.now()
        };
        
        console.log("üîó T020: Device navigation with preserved context:", cveContextInfo);
        
        // Show device modal with CVE context indicator
        if (typeof DeviceSecurityModal !== "undefined" && window.deviceSecurityModal) {
            // Store the CVE context for the device modal
            window.deviceSecurityModal.cveNavigationContext = cveContextInfo;
            window.deviceSecurityModal.showDeviceDetails(hostname, this.currentCVEContext.originalDataManager);
        } else {
            this.showToast(`Device details for ${hostname} - Context: ${this.currentCVEContext.cveId}`, "info");
        }
    }

    /**
     * Validate that modal content matches the requested CVE
     * T017: Content validation to ensure modal shows correct information
     * @param {string} expectedCveId - The CVE ID that should be displayed
     */
    validateModalContent(expectedCveId) {
        if (!this.currentVulnerability || !expectedCveId) {
            return;
        }
        
        const vulnLink = this.getVulnerabilityLink(this.currentVulnerability);
        const displayedId = vulnLink.id;
        
        // Check if the displayed content matches the expected CVE
        if (expectedCveId.toUpperCase() !== displayedId.toUpperCase()) {
            console.warn(`‚ö†Ô∏è Modal content mismatch! Expected: ${expectedCveId}, Displayed: ${displayedId}`);
            // Additional validation could trigger re-load if needed
        } else {
            console.log(`‚úÖ Modal content validated - showing correct CVE: ${expectedCveId}`);
        }
    }

    /**
     * Clear modal state data to prevent memory leaks
     * T015: Memory leak prevention for modal state handling
     * T018: Enhanced cleanup with race condition protection  
     * T020: Enhanced to clear CVE navigation context
     */
    clearModalStateData(options = {}) {
        const { preserveOperationContext = false } = options;

        // T018: Cancel any ongoing operations unless explicitly preserved
        if (!preserveOperationContext) {
            this.currentOperationId = null;
            this.isModalOperationInProgress = false;
        }
        
        // Clear current vulnerability reference
        this.currentVulnerability = null;
        
        // T020: Clear CVE navigation context
        this.currentCVEContext = null;
        
        // Destroy existing grid to prevent memory leaks
        if (this.affectedAssetsGrid) {
            try {
                // Unregister from AGGridThemeManager before destroying
                if (window.agGridThemeManager) {
                    window.agGridThemeManager.unregisterGrid("vulnerabilityDetailsModal");
                }
                
                this.affectedAssetsGrid.destroy();
            } catch (error) {
                console.warn("Error destroying assets grid:", error);
            }
            this.affectedAssetsGrid = null;
        }
        
        // Clear grid API reference
        this.affectedAssetsGridApi = null;
        
        // T017: Reset modal title to default
        this.setModalTitle("Vulnerability Details");
        
        // Clean up any temporary modal data entries
        if (window.vulnModalData) {
            const now = Date.now();
            const maxAge = 5 * 60 * 1000; // 5 minutes
            
            Object.keys(window.vulnModalData).forEach(key => {
                // Remove entries older than maxAge (cleanup strategy)
                if (key.includes("_") && key.split("_").length > 2) {
                    const timestamp = parseInt(key.split("_").pop());
                    if (!isNaN(timestamp) && (now - timestamp) > maxAge) {
                        delete window.vulnModalData[key];
                    }
                }
            });
        }
        
        console.log("üßπ Modal state data cleared");
    }

    /**
     * Show toast notification
     * @param {string} message - Toast message
     * @param {string} type - Toast type (success, warning, error, info)
     */
    showToast(message, type = "info") {
        // Integration with existing toast system
        if (window.vulnManager && typeof window.vulnManager.showToast === "function") {
            window.vulnManager.showToast(message, type);
        } else {
            console.log(`${type.toUpperCase()}: ${message}`);
        }
    }
}

// Initialize the vulnerability details modal when the DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
    window.vulnDetailsModal = new VulnerabilityDetailsModal();
});

// Export for module usage (Node.js environment check)
/* global module */
if (typeof window === "undefined" && typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityDetailsModal;
}

