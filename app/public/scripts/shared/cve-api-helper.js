/**
 * CVE.org API Helper Module for HexTrackr
 *
 * Fetches and caches CVE data from the official CVE.org API (cveawg.mitre.org)
 * Supports both CVE 5.0 and CVE 4.0 JSON formats
 * Implements 24-hour localStorage caching to reduce API load
 *
 * @fileoverview CVE API integration with caching and error handling
 * @author HexTrackr Development Team
 * @version 1.0.0
 * @since 1.0.99
 * @spec HEX-273
 */

/* global console, localStorage, fetch, DOMPurify */

class CVEApiHelper {
    constructor() {
        this.apiBaseUrl = "https://cveawg.mitre.org/api/cve";
        this.cachePrefix = "cve_cache_";
        this.cacheTTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
        this.maxCacheSize = 100; // Maximum cached CVEs
        this.fetchTimeout = 5000; // 5 second timeout

        // HEX-273: Reference blacklist (lazy-loaded from config)
        this.referenceBlacklist = null;
        this.blacklistLoaded = false;

        // Initialize cache cleanup on load
        this.clearExpiredCache();

        logger.debug("cve-api", "CVEApiHelper initialized");
    }

    /**
     * Main entry point: Fetch CVE data with caching
     * @param {string} cveId - CVE identifier (e.g., "CVE-2025-20352")
     * @returns {Promise<Object|null>} Parsed CVE data or null on error
     *
     * @example
     * const cveData = await cveApiHelper.fetchCVEData("CVE-2025-20352");
     * if (cveData) {
     *     console.log(cveData.description);
     *     console.log(cveData.cvss);
     * }
     */
    async fetchCVEData(cveId) {
        try {
            // Validate CVE ID format
            if (!this.validateCVEId(cveId)) {
                logger.warn("cve-api", `Invalid CVE ID format: ${cveId}`);
                return null;
            }

            // Normalize CVE ID (uppercase, trimmed)
            const normalizedId = cveId.trim().toUpperCase();

            // Check cache first
            const cachedData = this.getCachedCVE(normalizedId);
            if (cachedData) {
                logger.debug("cve-api", `Cache hit for ${normalizedId}`);
                return cachedData;
            }

            // Cache miss - fetch from API
            logger.debug("cve-api", `Cache miss - fetching ${normalizedId} from API`);
            const rawData = await this.fetchFromAPI(normalizedId);

            if (!rawData) {
                logger.warn("cve-api", `API returned no data for ${normalizedId}`);
                return null;
            }

            // Parse and normalize the response
            const parsedData = this.parseCVEJson(rawData);

            if (!parsedData) {
                logger.error("cve-api", `Failed to parse CVE data for ${normalizedId}`);
                return null;
            }

            // Cache the parsed data
            this.setCachedCVE(normalizedId, parsedData);

            return parsedData;

        } catch (error) {
            logger.error("cve-api", `Error fetching CVE ${cveId}:`, error);
            return null;
        }
    }

    /**
     * Fetch raw CVE data from API with timeout
     * @param {string} cveId - Normalized CVE ID
     * @returns {Promise<Object|null>} Raw API response or null
     * @private
     */
    async fetchFromAPI(cveId) {
        try {
            const url = `${this.apiBaseUrl}/${cveId}`;

            // Fetch with timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.fetchTimeout);

            const response = await fetch(url, {
                signal: controller.signal,
                headers: {
                    "Accept": "application/json"
                }
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                logger.warn("cve-api", `API error ${response.status} for ${cveId}`);
                return null;
            }

            const data = await response.json();
            return data;

        } catch (error) {
            if (error.name === "AbortError") {
                logger.warn("cve-api", `API timeout for ${cveId}`);
            } else {
                logger.error("cve-api", `Network error fetching ${cveId}:`, error);
            }
            return null;
        }
    }

    /**
     * Parse CVE JSON into normalized format
     * Supports both CVE 5.0 and CVE 4.0 formats
     * @param {Object} rawData - Raw API response
     * @returns {Object|null} Normalized CVE data
     * @private
     */
    parseCVEJson(rawData) {
        try {
            // Detect format version
            const isCVE50 = rawData.dataType === "CVE_RECORD" && rawData.dataVersion;
            const isCVE40 = rawData.CVE_data_meta && rawData.CVE_data_meta.ID;

            if (isCVE50) {
                return this.parseCVE50(rawData);
            } else if (isCVE40) {
                return this.parseCVE40(rawData);
            } else {
                logger.warn("cve-api", "Unknown CVE format", rawData);
                return null;
            }

        } catch (error) {
            logger.error("cve-api", "Error parsing CVE JSON:", error);
            return null;
        }
    }

    /**
     * Parse CVE 5.0 format (modern format)
     * @param {Object} data - CVE 5.0 JSON
     * @returns {Object} Normalized CVE data
     * @private
     */
    parseCVE50(data) {
        const cna = data.containers?.cna || {};
        const adp = data.containers?.adp || [];

        // Extract description
        const description = cna.descriptions?.find(d => d.lang === "en")?.value || "No description available";

        // Extract CVSS score (prefer v3.1, fallback to v3.0)
        let cvss = null;
        if (cna.metrics && cna.metrics.length > 0) {
            const cvssV31 = cna.metrics.find(m => m.cvssV3_1);
            const cvssV30 = cna.metrics.find(m => m.cvssV3_0);
            cvss = cvssV31?.cvssV3_1 || cvssV30?.cvssV3_0 || null;
        }

        // Extract CWE classifications
        const cwes = [];
        if (cna.problemTypes && Array.isArray(cna.problemTypes)) {
            cna.problemTypes.forEach(pt => {
                if (pt.descriptions && Array.isArray(pt.descriptions)) {
                    pt.descriptions.forEach(desc => {
                        if (desc.cweId) {
                            cwes.push({
                                id: desc.cweId,
                                description: desc.description || desc.cweId
                            });
                        }
                    });
                }
            });
        }

        // Extract affected products/versions
        const affected = cna.affected || [];

        // Extract references
        const references = cna.references || [];

        // Extract dates
        const datePublished = data.cveMetadata?.datePublished || null;
        const dateUpdated = data.cveMetadata?.dateUpdated || null;

        // Check for KEV status in ADP data
        let isKEV = false;
        if (Array.isArray(adp)) {
            isKEV = adp.some(entry => {
                return entry.title?.toLowerCase().includes("cisa kev") ||
                       entry.title?.toLowerCase().includes("known exploited");
            });
        }

        return {
            cveId: data.cveMetadata?.cveId || "Unknown",
            description: description,
            cvss: cvss,
            cwes: cwes,
            affected: affected,
            references: references,
            datePublished: datePublished,
            dateUpdated: dateUpdated,
            isKEV: isKEV,
            format: "5.0"
        };
    }

    /**
     * Parse CVE 4.0 format (legacy format)
     * @param {Object} data - CVE 4.0 JSON
     * @returns {Object} Normalized CVE data
     * @private
     */
    parseCVE40(data) {
        // Extract description
        const descriptionData = data.description?.description_data || [];
        const description = descriptionData.find(d => d.lang === "en")?.value || "No description available";

        // Extract CVSS (4.0 format has different structure)
        let cvss = null;
        if (data.impact?.cvss) {
            cvss = {
                version: data.impact.cvss.version || "3.0",
                vectorString: data.impact.cvss.vectorString || "",
                baseScore: data.impact.cvss.baseScore || 0,
                baseSeverity: this.calculateSeverity(data.impact.cvss.baseScore || 0)
            };
        }

        // CVE 4.0 format has limited CWE data
        const cwes = [];
        if (data.problemtype?.problemtype_data) {
            data.problemtype.problemtype_data.forEach(pt => {
                if (pt.description && Array.isArray(pt.description)) {
                    pt.description.forEach(desc => {
                        if (desc.value && desc.value.startsWith("CWE-")) {
                            cwes.push({
                                id: desc.value,
                                description: desc.value
                            });
                        }
                    });
                }
            });
        }

        // Extract references
        const references = [];
        if (data.references?.reference_data) {
            data.references.reference_data.forEach(ref => {
                if (ref.url) {
                    references.push({
                        url: ref.url,
                        name: ref.name || ref.url
                    });
                }
            });
        }

        // CVE 4.0 has limited affected data
        const affected = [];

        return {
            cveId: data.CVE_data_meta?.ID || "Unknown",
            description: description,
            cvss: cvss,
            cwes: cwes,
            affected: affected,
            references: references,
            datePublished: null,
            dateUpdated: null,
            isKEV: false, // 4.0 format doesn't include KEV data
            format: "4.0"
        };
    }

    /**
     * Calculate severity label from CVSS score
     * @param {number} score - CVSS base score (0-10)
     * @returns {string} Severity label
     * @private
     */
    calculateSeverity(score) {
        if (score >= 9.0) {return "CRITICAL";}
        if (score >= 7.0) {return "HIGH";}
        if (score >= 4.0) {return "MEDIUM";}
        if (score > 0) {return "LOW";}
        return "NONE";
    }

    /**
     * Validate CVE ID format
     * @param {string} cveId - CVE identifier to validate
     * @returns {boolean} True if valid format
     * @private
     */
    validateCVEId(cveId) {
        if (!cveId || typeof cveId !== "string") {
            return false;
        }
        // CVE format: CVE-YYYY-NNNNN (4+ digits)
        const cvePattern = /^CVE-\d{4}-\d{4,}$/i;
        return cvePattern.test(cveId.trim());
    }

    /**
     * Get cached CVE data if not expired
     * @param {string} cveId - Normalized CVE ID
     * @returns {Object|null} Cached data or null
     */
    getCachedCVE(cveId) {
        try {
            const cacheKey = this.cachePrefix + cveId;
            const cached = localStorage.getItem(cacheKey);

            if (!cached) {
                return null;
            }

            const cacheData = JSON.parse(cached);

            // Check if expired
            const now = Date.now();
            if (now - cacheData.timestamp > this.cacheTTL) {
                logger.debug("cve-api", `Cache expired for ${cveId}`);
                localStorage.removeItem(cacheKey);
                return null;
            }

            return cacheData.data;

        } catch (error) {
            logger.error("cve-api", `Error reading cache for ${cveId}:`, error);
            return null;
        }
    }

    /**
     * Store CVE data in cache with timestamp
     * @param {string} cveId - Normalized CVE ID
     * @param {Object} data - Parsed CVE data
     */
    setCachedCVE(cveId, data) {
        try {
            // Enforce cache size limit (FIFO eviction)
            const cacheKeys = this.getCacheKeys();
            if (cacheKeys.length >= this.maxCacheSize) {
                // Remove oldest entry
                const oldestKey = cacheKeys[0];
                localStorage.removeItem(oldestKey);
                logger.debug("cve-api", `Cache full - evicted ${oldestKey}`);
            }

            const cacheKey = this.cachePrefix + cveId;
            const cacheData = {
                timestamp: Date.now(),
                data: data
            };

            localStorage.setItem(cacheKey, JSON.stringify(cacheData));
            logger.debug("cve-api", `Cached ${cveId} (TTL: 24h)`);

        } catch (error) {
            // Handle quota exceeded
            if (error.name === "QuotaExceededError") {
                logger.warn("cve-api", "localStorage quota exceeded - clearing old cache");
                this.clearExpiredCache();
                // Try again after cleanup
                try {
                    const cacheKey = this.cachePrefix + cveId;
                    localStorage.setItem(cacheKey, JSON.stringify({
                        timestamp: Date.now(),
                        data: data
                    }));
                } catch (retryError) {
                    logger.error("cve-api", "Failed to cache after cleanup:", retryError);
                }
            } else {
                logger.error("cve-api", `Error caching ${cveId}:`, error);
            }
        }
    }

    /**
     * Get all cache keys sorted by timestamp (oldest first)
     * @returns {Array<string>} Sorted cache keys
     * @private
     */
    getCacheKeys() {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.cachePrefix)) {
                keys.push(key);
            }
        }

        // Sort by timestamp (oldest first for FIFO eviction)
        keys.sort((a, b) => {
            try {
                const dataA = JSON.parse(localStorage.getItem(a) || "{}");
                const dataB = JSON.parse(localStorage.getItem(b) || "{}");
                return (dataA.timestamp || 0) - (dataB.timestamp || 0);
            } catch {
                return 0;
            }
        });

        return keys;
    }

    /**
     * Clear expired cache entries
     * Called on initialization and when quota exceeded
     */
    clearExpiredCache() {
        try {
            const now = Date.now();
            let clearedCount = 0;

            const keys = this.getCacheKeys();
            keys.forEach(key => {
                try {
                    const cached = localStorage.getItem(key);
                    if (cached) {
                        const cacheData = JSON.parse(cached);
                        if (now - cacheData.timestamp > this.cacheTTL) {
                            localStorage.removeItem(key);
                            clearedCount++;
                        }
                    }
                } catch (error) {
                    // Remove corrupted cache entry
                    localStorage.removeItem(key);
                    clearedCount++;
                }
            });

            if (clearedCount > 0) {
                logger.debug("cve-api", `Cleared ${clearedCount} expired cache entries`);
            }

        } catch (error) {
            logger.error("cve-api", "Error clearing expired cache:", error);
        }
    }

    /**
     * Clear all CVE cache entries (for testing/debugging)
     * @public
     */
    clearAllCache() {
        try {
            const keys = this.getCacheKeys();
            keys.forEach(key => localStorage.removeItem(key));
            logger.debug("cve-api", `Cleared all cache (${keys.length} entries)`);
        } catch (error) {
            logger.error("cve-api", "Error clearing cache:", error);
        }
    }

    /**
     * Get cache statistics
     * @returns {Object} Cache stats
     * @public
     */
    getCacheStats() {
        const keys = this.getCacheKeys();
        const stats = {
            totalEntries: keys.length,
            maxSize: this.maxCacheSize,
            ttl: this.cacheTTL,
            entries: []
        };

        keys.forEach(key => {
            try {
                const cached = localStorage.getItem(key);
                if (cached) {
                    const data = JSON.parse(cached);
                    const age = Date.now() - data.timestamp;
                    const cveId = key.replace(this.cachePrefix, "");
                    stats.entries.push({
                        cveId: cveId,
                        age: age,
                        expired: age > this.cacheTTL
                    });
                }
            } catch (error) {
                // Skip corrupted entries
            }
        });

        return stats;
    }

    /**
     * Load reference blacklist from config file (lazy-loaded, cached)
     * @returns {Promise<Array<string>>} Array of blacklisted domains
     * @private
     */
    async loadReferenceBlacklist() {
        // Return cached blacklist if already loaded
        if (this.blacklistLoaded && this.referenceBlacklist) {
            return this.referenceBlacklist;
        }

        try {
            const response = await fetch("/config/cve-reference-blacklist.json");
            if (!response.ok) {
                logger.warn("cve-api", "Blacklist config not found, using empty blacklist");
                this.referenceBlacklist = [];
                this.blacklistLoaded = true;
                return [];
            }

            const config = await response.json();
            this.referenceBlacklist = config.blacklistedDomains || [];
            this.blacklistLoaded = true;

            logger.debug("cve-api", `Loaded ${this.referenceBlacklist.length} blacklisted domains`);
            return this.referenceBlacklist;

        } catch (error) {
            logger.error("cve-api", "Error loading blacklist config:", error);
            this.referenceBlacklist = [];
            this.blacklistLoaded = true;
            return [];
        }
    }

    /**
     * Fetch only CVE references (lightweight method for UI display)
     * Uses blacklist to filter out broken/unreliable domains
     * @param {string} cveId - CVE identifier
     * @returns {Promise<Array|null>} Filtered references or null
     * @public
     *
     * @example
     * const refs = await cveApiHelper.fetchCVEReferences("CVE-2025-20352");
     * // Returns: [{url: "https://cisa.gov/...", name: "CISA KEV"}, ...]
     */
    async fetchCVEReferences(cveId) {
        try {
            // Load blacklist (cached after first load)
            const blacklist = await this.loadReferenceBlacklist();

            // Fetch full CVE data (uses cache if available)
            const cveData = await this.fetchCVEData(cveId);

            if (!cveData || !cveData.references) {
                return null;
            }

            // Filter references using blacklist (blocks known-broken domains)
            const filteredRefs = cveData.references.filter(ref => {
                if (!ref.url) {return false;}

                try {
                    const url = new URL(ref.url);
                    const hostname = url.hostname.toLowerCase();

                    // Check if hostname is blacklisted (partial match)
                    const isBlacklisted = blacklist.some(domain =>
                        hostname.includes(domain.toLowerCase())
                    );

                    return !isBlacklisted; // Include if NOT blacklisted

                } catch (error) {
                    // Invalid URL - skip
                    return false;
                }
            });

            return filteredRefs.length > 0 ? filteredRefs : null;

        } catch (error) {
            logger.error("cve-api", `Error fetching references for ${cveId}:`, error);
            return null;
        }
    }
}

// Initialize global instance
if (typeof window !== "undefined") {
    window.cveApiHelper = new CVEApiHelper();
}

// Export for module usage
if (typeof module !== "undefined" && module.exports) {
    module.exports = CVEApiHelper;
}
