/**
 * @fileoverview VulnerabilityCoreOrchestrator - Central coordination and orchestration for vulnerability management
 * Extracted from ModernVulnManager as part of Phase 2 modularization (T004)
 * @version 2.0.0
 * @author HexTrackr Team
 * @date 2025-09-08
 */

/* eslint-env browser, es6 */
/* global bootstrap, fetch, confirm, Blob, URL, FormData, WebSocketClient, ProgressModal, PaginationController, console, document, window, setTimeout, VulnerabilityDataManager, VulnerabilityStatisticsManager, VulnerabilitySearchManager, VulnerabilityCardsManager, generateSecureId */

// Import ES6 modules - converted to global references for browser compatibility
// import { VulnerabilityChartManager } from './vulnerability-chart-manager.js'; // Changed to global reference
// import { VulnerabilityGridManager } from './vulnerability-grid.js'; // Changed to global reference
// Note: The following classes are loaded as global variables via script tags in HTML:
// - VulnerabilityDataManager
// - VulnerabilityStatisticsManager
// - VulnerabilitySearchManager
// - VulnerabilityCardsManager
// - VulnerabilityGridManager
// - VulnerabilityChartManager

/**
 * Central orchestrator for vulnerability management system
 * Coordinates between all extracted modules and handles cross-cutting concerns
 */
class VulnerabilityCoreOrchestrator {
    constructor() {
        this.apiBase = "/api";
        this.currentView = "table";
        
        // Module managers will be injected
        this.dataManager = null;
        this.statisticsManager = null;
        this.chartManager = null;
        this.searchManager = null;
        this.gridManager = null;
        this.cardsManager = null;
        
        // Initialize pagination controllers
        this.devicePagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        this.vulnerabilityPagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        
        // Initialize WebSocket and progress modal
        this.websocketClient = null;
        this.progressModal = null;

        // File import state
        this.pendingFile = null;

        // Data loading state flag
        this.isDataLoading = false;
    }

    /**
     * Initialize all modules and their interconnections (NEW - single initialization point)
     * @param {Object} parentContext - Parent context for callbacks (ModernVulnManager instance)
     */
    async initializeAllModules(parentContext) {
        // Create all modules (single creation point)
        this.dataManager = new VulnerabilityDataManager("/api");
        this.statisticsManager = new VulnerabilityStatisticsManager(this.dataManager);
        this.chartManager = new window.VulnerabilityChartManager("vulnerability-chart", this.statisticsManager, this.dataManager);
        this.searchManager = new VulnerabilitySearchManager("/api", this.dataManager, parentContext);
        this.gridManager = new window.VulnerabilityGridManager(this.dataManager, parentContext);
        this.cardsManager = new VulnerabilityCardsManager(this.dataManager, this.devicePagination, this.vulnerabilityPagination, parentContext);
        
        // Initialize WebSocket and progress modal
        await this.initializeWebSocketAndProgressModal();
        
        // Setup cross-module event coordination
        this.setupDataManagerListeners();
        this.setupEventListeners();
        
        // Setup theme change listeners for all components - T028
        this.setupThemeListeners();

        // Initialize modules in proper order (single initialization point)
        // CRITICAL: Await chart initialization so it's ready before data loads
        this.gridManager.initializeGrid();
        await this.chartManager.initialize();
        console.log("‚úÖ Chart manager initialized and ready");

        // HEX-117 Phase 2 + Navigation Fix: Hybrid caching with instant chart restore
        // Check for lightweight metadata cache (stats + trends only)
        const cacheMetadata = sessionStorage.getItem("hextrackr_cache_metadata");
        const lastLoad = sessionStorage.getItem('hextrackr_last_load');
        const now = Date.now();
        const cacheAge = lastLoad ? (now - parseInt(lastLoad)) : Infinity;

        // Use hybrid cache if data loaded within last 60 seconds (navigation scenario)
        if (cacheMetadata && cacheAge < 60000) {
            console.log(`‚ö° PERF: Navigation cache hit (${Math.round(cacheAge/1000)}s old) - instant charts + KEV-first grid`);
            try {
                const cached = JSON.parse(cacheMetadata);

                // Step 1: Instantly restore statistics, trends, and charts (no network call)
                this.dataManager.statistics = cached.statistics || {};
                this.dataManager.historicalData = cached.historicalData || [];
                this.dataManager.trends = cached.trends || {};
                await this.chartManager.update();
                // CRITICAL: Update VPR cards with restored statistics and trends
                await this.updateStatisticsDisplay();
                console.log("‚úÖ Charts, VPR cards, and trend percentages restored instantly from sessionStorage");

                // Step 2: Load full dataset immediately (HEX-120: disabled split loading)
                // With improved charts and grids, loading all data at once is now faster
                console.log(`üìä Loading full vulnerability dataset...`);
                await this.loadData(false, { limit: 30000 });

            } catch (e) {
                console.error("Failed to restore from cache, loading fresh:", e);
                // Cache corrupted, load fresh with full dataset (HEX-120: disabled split loading)
                await this.loadData(false, { limit: 30000 });
            }
        } else {
            // No cache or stale - load fresh with full dataset (HEX-120: disabled split loading)
            console.log("üöÄ Loading full vulnerability dataset");
            await this.loadData(false, { limit: 30000 });
        }

        // Initialize lazy load flags for card views
        this.devicesDataLoaded = false;
        this.vulnsDataLoaded = false;

        // CRITICAL: Enable bfcache by cleaning up WebSocket on page hide
        // Without this, browser can't use bfcache for instant back button navigation
        window.addEventListener('pagehide', () => {
            if (this.websocketClient && typeof this.websocketClient.disconnect === 'function') {
                console.log("üîå Disconnecting WebSocket for bfcache eligibility");
                this.websocketClient.disconnect();
            }
        });

        // Also listen for pageshow to detect bfcache restore
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                console.log("‚ö° BFCACHE: Page restored from bfcache - instant navigation!");
                // Page was restored from bfcache, reconnect WebSocket if needed
                if (
                    !this.websocketClient ||
                    typeof this.websocketClient.isSocketConnected !== 'function' ||
                    !this.websocketClient.isSocketConnected()
                ) {
                    this.initializeWebSocketAndProgressModal();
                }
            }
        });
    }


    /**
     * Initialize WebSocket client and progress modal for real-time progress tracking
     */
    async initializeWebSocketAndProgressModal() {
        try {
            // Initialize WebSocket client if available
            if (typeof WebSocketClient !== "undefined") {
                this.websocketClient = new WebSocketClient();

                // Add connection timeout to prevent hanging
                const connectionPromise = this.websocketClient.connect();
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error("WebSocket connection timeout")), 5000)
                );

                try {
                    await Promise.race([connectionPromise, timeoutPromise]);
                    console.log("WebSocket client connected for progress tracking");
                } catch (wsError) {
                    console.warn("WebSocket connection failed:", wsError.message);
                    this.websocketClient = null; // Reset to null on failure
                }
            } else {
                console.warn("WebSocket client not available - progress modal will work in manual mode");
            }

            // Initialize progress modal if available (works with or without WebSocket)
            if (typeof ProgressModal !== "undefined") {
                this.progressModal = new ProgressModal(this.websocketClient);
                console.log("Progress modal initialized");
            } else {
                console.warn("Progress modal not available - falling back to traditional loading indicators");
            }
        } catch (error) {
            console.error("Error initializing WebSocket/Progress modal:", error);
            // Ensure websocketClient is null on any error
            this.websocketClient = null;
        }
    }

    /**
     * Setup data manager event listeners for cross-module coordination
     */
    setupDataManagerListeners() {
        // Listen to data manager events
        this.dataManager.on("dataLoaded", (_data) => {
            // PERFORMANCE FIX: Don't update chart on dataLoaded - stats/trends don't change
            // Chart only needs to update when statisticsLoaded fires
            this.updateCurrentView(); // Update grid only
        });

        this.dataManager.on("dataFiltered", (_data) => {
            this.updateCurrentView();
        });

        this.dataManager.on("statisticsLoaded", async (_data) => {
            // Update VPR cards and statistics display
            this.updateStatisticsDisplay();
            // Also update charts immediately with available data
            await this.updateChart();
            console.log("üìä Charts and stats updated from early parallel load");
        });

        this.dataManager.on("error", (data) => {
            this.showToast(data.message, "danger");
        });
    }

    /**
     * Setup global event listeners for UI interactions
     */
    setupEventListeners() {
        // Import CSV - Show date picker modal
        const importCsvBtn = document.getElementById("importCsvBtn");
        if (importCsvBtn) {
            importCsvBtn.addEventListener("click", () => {
                const csvFileInput = document.getElementById("csvFileInput");
                if (csvFileInput) {
                    csvFileInput.click();
                }
            });
        }

        const csvFileInput = document.getElementById("csvFileInput");
        if (csvFileInput) {
            csvFileInput.addEventListener("change", (e) => {
                this.showScanDateModal(e);
            });
        }

        // Confirm scan date and proceed with import
        const confirmScanDate = document.getElementById("confirmScanDate");
        if (confirmScanDate) {
            confirmScanDate.addEventListener("click", () => {
                this.proceedWithImport();
            });
        }

        // View switcher for Tabler.io button group
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const view = e.target.dataset.view || e.target.closest("[data-view]").dataset.view;
                if (view) {
                    this.switchView(view);
                }
            });
        });

        // Export button
        const exportBtn = document.getElementById("exportBtn");
        if (exportBtn) {
            exportBtn.addEventListener("click", () => {
                this.exportData();
            });
        }

        // Refresh button - Check if exists before adding listener
        const refreshBtn = document.getElementById("refreshBtn");
        if (refreshBtn) {
            refreshBtn.addEventListener("click", () => {
                this.dataManager.refreshData();
            });
        }

        // Save vulnerability edit
        const saveVulnEdit = document.getElementById("saveVulnEdit");
        if (saveVulnEdit) {
            saveVulnEdit.addEventListener("click", () => {
                this.saveVulnerabilityChanges();
            });
        }
    }

    /**
     * Setup theme change listeners for grid and chart components - T028
     * Connects theme controller changes to component updateTheme methods
     */
    setupThemeListeners() {
        try {
            // HEX-65: Check for pre-applied theme first before waiting for controller
            const currentTheme = document.documentElement.getAttribute("data-bs-theme") || "light";

            // Apply initial theme to components immediately
            if (window.agGridThemeManager) {
                window.agGridThemeManager.updateTheme(currentTheme === "dark");
                console.log(`AGGridThemeManager initial theme: ${currentTheme}`);
            }

            // Access global theme controller from header.js
            const themeController = window.themeController;

            if (!themeController) {
                console.warn("Theme controller not available - using pre-applied theme only");
                return;
            }

            // Add theme change listener for centralized AG-Grid theme management
            themeController.addThemeChangeListener((newTheme, _source) => {
                try {
                    // Use centralized AGGridThemeManager for all grids
                    if (window.agGridThemeManager) {
                        window.agGridThemeManager.updateTheme(newTheme === "dark");
                        console.log(`AGGridThemeManager theme update: ${newTheme} - Success`);
                    }
                    
                    // Fallback to individual grid manager if AGGridThemeManager not available
                    else if (this.gridManager && this.gridManager.hasThemeSupport()) {
                        const success = this.gridManager.updateTheme(newTheme);
                        console.log(`Grid theme update (fallback): ${newTheme} - ${success ? "Success" : "Failed"}`);
                    }
                } catch (error) {
                    console.error("Error updating grid theme:", error);
                }
            });

            // Add theme change listener for chart manager  
            themeController.addThemeChangeListener((newTheme, _source) => {
                try {
                    if (this.chartManager && this.chartManager.hasThemeSupport && this.chartManager.hasThemeSupport()) {
                        const success = this.chartManager.updateTheme(newTheme);
                        console.log(`Chart theme update: ${newTheme} - ${success ? "Success" : "Failed"}`);
                    } else if (this.chartManager && this.chartManager.getThemeAdapter) {
                        // Fallback: direct theme adapter access
                        const adapter = this.chartManager.getThemeAdapter();
                        if (adapter) {
                            adapter.applyChartTheme(newTheme);
                            console.log(`Chart theme update via adapter: ${newTheme}`);
                        }
                    }
                } catch (error) {
                    console.error("Error updating chart theme:", error);
                }
            });

            console.log("Theme listeners setup complete for vulnerability components");
            
        } catch (error) {
            console.error("Error setting up theme listeners:", error);
        }
    }

    /**
     * Load data and coordinate updates across all modules
     * HEX-117 Phase 2: Modified to accept filter options
     * @param {boolean} bustCache - Force cache refresh with timestamp parameter
     * @param {Object} options - Optional filter parameters (kev, limit, etc.)
     */
    async loadData(bustCache = false, options = {}) {
        // Prevent concurrent loading
        if (this.isDataLoading) {
            console.log("Data is already loading, skipping duplicate request");
            return;
        }

        this.isDataLoading = true;
        // HEX-65: Commented out to prevent white flash on page load
        // The data loads quickly enough that the toast is unnecessary
        // this.showLoading();
        try {
            // Check and trigger KEV auto-sync if needed (non-blocking)
            this.checkKevAutoSync();

            await this.dataManager.loadData(bustCache, options);
        } finally {
            // Hide loading indicator
            this.hideLoading();
            this.isDataLoading = false;
        }
    }

    /**
     * HEX-117 Phase 2: Schedule background load of full dataset
     * DEPRECATED - HEX-120: Split loading disabled as full dataset loading is now faster
     * This method is no longer used but kept for reference
     *
     * @deprecated Since HEX-120 - Full dataset now loads immediately instead of in phases
     */
    scheduleBackgroundDataLoad() {
        // HEX-120: This method is no longer called
        // Full dataset is loaded immediately in the initial loadData call
        console.warn("scheduleBackgroundDataLoad called but split loading is disabled (HEX-120)");
    }

    /**
     * Check if KEV auto-sync is needed and trigger if necessary
     * Runs in background without blocking the UI
     * @async
     */
    async checkKevAutoSync() {
        try {
            // Check if auto-sync is enabled
            const autoSyncEnabled = localStorage.getItem("kevAutoSyncEnabled") !== "false";
            if (!autoSyncEnabled) {
                return;
            }

            // Check if sync is needed
            const response = await fetch("/api/kev/check-autosync");
            if (!response.ok) {
                console.warn("Failed to check KEV auto-sync status");
                return;
            }

            const { autoSyncNeeded } = await response.json();

            if (autoSyncNeeded) {
                console.log("KEV auto-sync needed, triggering background sync");

                // Trigger sync in background (fire and forget)
                fetch("/api/kev/sync", { method: "POST" })
                    .then(response => {
                        if (response.ok) {
                            console.log("KEV auto-sync completed successfully");
                        } else {
                            console.warn("KEV auto-sync failed:", response.statusText);
                        }
                    })
                    .catch(error => {
                        console.warn("KEV auto-sync error:", error);
                    });
            } else {
                console.log("KEV auto-sync not needed");
            }

        } catch (error) {
            // Silent fail - don't let KEV sync issues block the page
            console.warn("KEV auto-sync check failed:", error);
        }
    }

    /**
     * Update chart display through chart manager
     * HEX-117: Modified to handle async chart updates
     */
    async updateChart() {
        await this.chartManager.update();
    }

    /**
     * Update statistics display across modules
     * HEX-117: Modified to handle async statistics fetching from backend
     */
    async updateStatisticsDisplay() {
        if (this.statisticsManager) {
            await this.statisticsManager.updateStatisticsDisplay();
            console.log("Statistics display updated via statisticsManager");
        } else {
            console.warn("StatisticsManager not available for display update");
        }
    }

    /**
     * Switch between different view modes (table, devices, vulnerabilities)
     * HEX-117 Phase 2: Added lazy loading for card views
     * @param {string} view - View type to switch to
     */
    async switchView(view) {
        this.currentView = view;

        // Update active button state
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.classList.remove("active");
        });
        document.querySelector(`[data-view="${view}"]`)?.classList.add("active");

        // Show/hide the correct view containers
        const viewContainers = {
            "table": "tableView",
            "devices": "devicesView",
            "vulnerabilities": "vulnerabilitiesView"
        };

        Object.entries(viewContainers).forEach(([viewType, containerId]) => {
            const container = document.getElementById(containerId);
            if (container) {
                if (viewType === view) {
                    container.classList.remove("d-none");
                    container.style.display = "block";
                } else {
                    container.classList.add("d-none");
                    container.style.display = "none";
                }
            }
        });

        // HEX-117 Phase 2: Lazy load data for card views on first access
        if (view === "devices" && !this.devicesDataLoaded) {
            console.log("üì¶ HEX-117 Phase 2: Lazy loading device cards data");
            await this.loadDevicesData();
            this.devicesDataLoaded = true;
        } else if (view === "vulnerabilities" && !this.vulnsDataLoaded) {
            console.log("üì¶ HEX-117 Phase 2: Lazy loading vulnerability cards data");
            await this.loadVulnerabilitiesData();
            this.vulnsDataLoaded = true;
        }

        // Update modules for current view
        this.updateCurrentView();
    }

    /**
     * Update current view display based on active view type
     */
    updateCurrentView() {
        switch (this.currentView) {
            case "table":
                this.gridManager.updateForCurrentView(this.currentView);
                break;
            case "devices":
                this.cardsManager.updateForCurrentView(this.currentView);
                break;
            case "vulnerabilities":
                this.cardsManager.updateForCurrentView(this.currentView);
                break;
        }
    }

    /**
     * HEX-117 Phase 2: Lazy load device cards data from server
     * HEX-120 Fix: API structure updated to match frontend expectations
     * Fetches pre-aggregated device statistics on first access to Devices tab
     * Note: vulnerabilities array is empty from API - modal fetches separately when needed
     * @returns {Promise<void>}
     */
    async loadDevicesData() {
        // HEX-120: ALWAYS process devices client-side first to ensure vulnerability arrays exist
        // This is needed for the device modal to work properly
        if (!this.dataManager.devices || this.dataManager.devices.length === 0 ||
            !this.dataManager.devices[0].vulnerabilities) {
            console.log("Processing devices client-side for modal compatibility...");
            this.dataManager.processDevices();
        }

        try {
            const response = await fetch("/api/devices/stats");
            if (response.ok) {
                const result = await response.json();
                // Extract devices array from response object
                const devices = result.devices || [];

                // HEX-120: Merge server stats with client-side vulnerability arrays
                // The API provides optimized stats, but we need vulnerability arrays for modals
                const mergedDevices = devices.map(apiDevice => {
                    const clientDevice = this.dataManager.devices.find(d => d.hostname === apiDevice.hostname);
                    if (clientDevice && clientDevice.vulnerabilities) {
                        // Merge API stats with client vulnerability data
                        return {
                            ...apiDevice,
                            vulnerabilities: clientDevice.vulnerabilities
                        };
                    }
                    return apiDevice;
                });

                // Only use merged data if we have vulnerability arrays
                if (mergedDevices.length > 0 && mergedDevices[0].vulnerabilities) {
                    this.dataManager.devices = mergedDevices;
                    console.log(`‚úÖ Loaded ${devices.length} device records from API with vulnerability data`);
                } else {
                    console.log("‚ö†Ô∏è API devices lack vulnerability data, using client-side processing");
                }
            } else {
                console.error("Failed to load devices data:", response.statusText);
            }
        } catch (error) {
            console.error("Error loading devices data:", error);
            this.showToast("Using client-side device processing", "warning");
        }
    }

    /**
     * HEX-117 Phase 2: Lazy load vulnerability cards data
     * For vulnerability cards view, we can use the existing vulnerabilities data
     * but we may want to fetch grouped/aggregated data in the future
     * @returns {Promise<void>}
     */
    async loadVulnerabilitiesData() {
        try {
            // For now, vulnerability cards can use the already-loaded vulnerability data
            // The cards manager will group by CVE client-side
            // Future optimization: Create /api/vulnerabilities/grouped-by-cve endpoint
            console.log("‚úÖ Vulnerability cards using existing data (already loaded)");
        } catch (error) {
            console.error("Error preparing vulnerabilities data:", error);
            this.showToast("Failed to load vulnerability cards", "danger");
        }
    }

    /**
     * Show scan date modal for CSV import
     * @param {Event} event - File input change event
     */
    showScanDateModal(event) {
        this.pendingFile = event.target.files[0];
        if (!this.pendingFile) {return;}

        const scanDateInput = document.getElementById("scanDateInput");
        const scanDateModal = document.getElementById("scanDateModal");

        if (!scanDateInput || !scanDateModal) {
            console.error("Required modal elements not found");
            this.showToast("Modal elements not available", "danger");
            return;
        }

        const today = new Date().toISOString().split("T")[0];
        scanDateInput.value = today;

        // Apply current theme to modal
        const currentTheme = document.documentElement.getAttribute("data-bs-theme") || "light";
        scanDateModal.setAttribute("data-bs-theme", currentTheme);

        const modal = new bootstrap.Modal(scanDateModal);
        modal.show();
    }

    /**
     * Proceed with CSV import after date confirmation
     */
    async proceedWithImport() {
        const scanDateInput = document.getElementById("scanDateInput");
        const scanDateModal = document.getElementById("scanDateModal");
        const csvFileInput = document.getElementById("csvFileInput");

        if (!scanDateInput || !scanDateModal) {
            console.error("Required modal elements not found");
            this.showToast("Modal elements not available", "danger");
            return;
        }

        const scanDate = scanDateInput.value;
        if (!scanDate) {
            this.showToast("Please select a scan date", "danger");
            return;
        }

        const modal = bootstrap.Modal.getInstance(scanDateModal);
        if (modal) {
            modal.hide();
        }

        await this.handleCsvImportWithDate(this.pendingFile, scanDate);

        this.pendingFile = null;
        if (csvFileInput) {
            csvFileInput.value = "";
        }
    }

    /**
     * Handle CSV import with progress tracking
     * @param {File} file - CSV file to import
     * @param {string} scanDate - Scan date for the import
     */
    async handleCsvImportWithDate(file, scanDate) {
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                return;
            }
        }

        // Use progress modal if available (works with or without WebSocket)
        const useProgressModal = this.progressModal !== null;
        let sessionId = null;

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");
            formData.append("scanDate", scanDate);

            if (useProgressModal) {
                // Show progress modal for real-time updates
                // Generate secure session ID using shared utility
                sessionId = generateSecureId("import", 2);
                formData.append("sessionId", sessionId);
                
                this.progressModal.show({
                    title: "Importing CSV Data",
                    sessionId: sessionId,
                    allowCancel: true,
                    onCancel: () => this.cancelCsvImport(sessionId),
                    initialMessage: `Uploading ${file.name}...`
                });
            } else {
                // Fall back to traditional loading indicator
                this.showLoading("Uploading CSV file...");
            }

            const response = await fetch(`${this.apiBase}/vulnerabilities/import-staging`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            const _result = await response.json();

            if (!useProgressModal) {
                // Manual progress updates for fallback mode
                this.showLoading("Processing data...");
                await new Promise(resolve => setTimeout(resolve, 500));

                this.showLoading("Refreshing charts and data...");
                await this.loadData(true); // Bust cache after import

                this.hideLoading();

                // For async imports, we don't have final counts immediately
                const message = `CSV import started successfully! File "${file.name}" is being processed with scan date ${scanDate}.`;

                this.showToast(message, "success");
            } else {
                // Progress modal - handle completion manually or via WebSocket
                const hasWebSocket = this.websocketClient &&
                    typeof this.websocketClient.isSocketConnected === "function" &&
                    this.websocketClient.isSocketConnected();

                if (!hasWebSocket) {
                    // Manual progress updates when WebSocket not available
                    this.progressModal.update({
                        progress: 25,
                        message: "Processing CSV data...",
                        stage: "Uploading"
                    });

                    await new Promise(resolve => setTimeout(resolve, 1000));

                    this.progressModal.update({
                        progress: 75,
                        message: "Refreshing data...",
                        stage: "Finalizing"
                    });

                    await this.loadData(true); // Bust cache after import

                    this.progressModal.showSuccess(`CSV import completed! File "${file.name}" processed with scan date ${scanDate}.`);
                } else {
                    // WebSocket mode - just refresh data when process completes
                    setTimeout(async () => {
                        await this.loadData(true); // Bust cache after import
                    }, 1000);
                }
            }

        } catch (error) {
            console.error("Error importing CSV:", error);
            
            if (useProgressModal && this.progressModal) {
                this.progressModal.showError(`Import failed: ${error.message}`);
            } else {
                this.hideLoading();
                this.showToast("Error importing CSV: " + error.message, "danger");
            }
        }
    }

    /**
     * Cancel CSV import operation
     * @param {string} sessionId - Session ID to cancel
     */
    async cancelCsvImport(sessionId) {
        try {
            await fetch(`${this.apiBase}/vulnerabilities/import-cancel`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ sessionId })
            });
            
            this.showToast("CSV import cancelled", "warning");
        } catch (error) {
            console.error("Error cancelling import:", error);
            this.showToast("Failed to cancel import", "danger");
        }
    }

    /**
     * Export vulnerability data to CSV
     */
    async exportData() {
        try {
            this.showLoading("Exporting data...");
            const response = await fetch(`${this.apiBase}/vulnerabilities/export`);
            
            if (!response.ok) {
                throw new Error("Export failed");
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.style.display = "none";
            a.href = url;
            a.download = `vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            this.hideLoading();
            this.showToast("Data exported successfully", "success");
        } catch (error) {
            this.hideLoading();
            this.showToast("Export failed: " + error.message, "danger");
        }
    }

    /**
     * View device details (delegated to device security modal)
     * @param {string} hostname - Hostname to view details for
     */
    viewDeviceDetails(hostname) {
        // Check if data is loaded first
        if (!this.dataManager || this.dataManager.getAllVulnerabilities().length === 0) {
            this.showToast("Please wait for data to load...", "info");
            // Try to load data if not already loading
            if (!this.isDataLoading) {
                this.isDataLoading = true;
                this.loadData().then(() => {
                    this.isDataLoading = false;
                    // Retry opening the modal after data loads
                    this.viewDeviceDetails(hostname);
                }).catch(() => {
                    this.isDataLoading = false;
                });
            }
            return;
        }

        // HEX-120 Fix: Ensure device modal is initialized
        if (typeof DeviceSecurityModal !== "undefined") {
            // Initialize modal if not present or check if it needs re-initialization
            if (!window.deviceSecurityModal || typeof window.deviceSecurityModal.showDeviceDetails !== "function") {
                console.log("HEX-120: Re-initializing Device Security Modal");
                window.deviceSecurityModal = new DeviceSecurityModal();
            }
            window.deviceSecurityModal.showDeviceDetails(hostname, this.dataManager);
        } else {
            this.showToast("Device details modal not available", "warning");
        }
    }

    /**
     * View vulnerability details (delegated to vulnerability details modal)
     * @param {string} vulnDataId - Vulnerability data ID
     */
    viewVulnerabilityDetails(vulnDataId) {
        const vulnData = window.vulnModalData?.[vulnDataId];
        if (vulnData && typeof VulnerabilityDetailsModal !== "undefined") {
            // HEX-120 Fix: Ensure vulnerability modal is initialized
            if (!window.vulnDetailsModal || typeof window.vulnDetailsModal.showVulnerabilityDetails !== "function") {
                console.log("HEX-120: Re-initializing Vulnerability Details Modal");
                window.vulnDetailsModal = new VulnerabilityDetailsModal();
            }
            window.vulnDetailsModal.showVulnerabilityDetails(vulnData, this.dataManager);
        } else {
            this.showToast("Vulnerability details not available", "warning");
        }
    }

    /**
     * Lookup vulnerability (delegated to search manager)
     * @param {string} vulnId - Vulnerability ID to lookup
     * @param {string} pluginName - Optional plugin name
     */
    async lookupVulnerability(vulnId, pluginName = null) {
        await this.searchManager.lookupVulnerability(vulnId, pluginName);
    }
    
    /**
     * Show vulnerability details modal filtered by CVE ID
     * T015: Fix modal state to display single CVE instead of all CVEs
     * T016: Update modal data population to filter by clicked CVE ID
     * @param {string} cveId - The CVE ID to filter by
     */
    showVulnerabilityDetailsByCVE(cveId) {
        if (!cveId || typeof cveId !== "string") {
            console.error("Invalid CVE ID provided to showVulnerabilityDetailsByCVE:", cveId);
            this.showToast("Invalid vulnerability ID", "error");
            return;
        }
        
        // Check if modal and data manager are available
        if (!window.vulnDetailsModal) {
            console.error("Vulnerability details modal not available");
            this.showToast("Vulnerability details not available", "warning");
            return;
        }
        
        if (!this.dataManager || !this.dataManager.vulnerabilities) {
            console.error("Data manager or vulnerabilities not available");
            this.showToast("Vulnerability data not available", "warning");
            return;
        }
        
        console.log("üéØ Opening modal for CVE ID:", cveId);
        
        // Use the new CVE-specific modal method
        window.vulnDetailsModal.showVulnerabilityDetailsByCVE(cveId, this.dataManager);
    }

    /**
     * Save vulnerability changes
     */
    async saveVulnerabilityChanges() {
        // Implementation would depend on vulnerability editing modal
        this.showToast("Vulnerability changes saved", "success");
    }

    /**
     * Export device report
     * @param {string} hostname - Hostname to export report for
     */
    async exportDeviceReport(hostname) {
        const deviceData = this.dataManager.getDevices().find(d => d.hostname === hostname);
        if (!deviceData) {
            this.showToast("Device not found", "danger");
            return;
        }

        const reportData = {
            hostname: hostname,
            vulnerabilities: this.dataManager.getAllVulnerabilities().filter(v => v.hostname === hostname),
            generated: new Date().toISOString(),
            filename: `device_report_${hostname}_${new Date().toISOString().split("T")[0]}.csv`
        };

        const headers = ["Hostname", "CVE", "Severity", "Description", "Port", "First Seen", "Last Seen"];
        const rows = reportData.vulnerabilities.map(v => [
            v.hostname,
            v.cve || "N/A",
            v.severity,
            v.description || v.plugin_name || "N/A",
            v.port || "N/A",
            v.first_seen ? new Date(v.first_seen).toLocaleDateString() : "N/A",
            v.last_seen ? new Date(v.last_seen).toLocaleDateString() : "N/A"
        ]);

        const csv = [headers, ...rows].map(row => 
            row.map(cell => `"${String(cell).replace(/"/g, "\"\"")}"`).join(",")
        ).join("\n");

        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", reportData.filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Device report exported for ${hostname}`, "success");
    }

    /**
     * Create a new ticket with pre-filled device hostname
     * Redirects to tickets page with device information
     * @param {string} hostname - Device hostname to pre-fill in new ticket
     */
    createTicketFromDevice(hostname) {
        if (!hostname) {
            this.showToast("No hostname provided", "warning");
            return;
        }

        // Store the hostname and flag in sessionStorage for cross-page communication
        sessionStorage.setItem("createTicketDevice", hostname);
        sessionStorage.setItem("autoOpenModal", "true");

        // Show user feedback before redirect
        this.showToast(`Creating ticket for ${hostname}...`, "info");

        // Redirect to tickets page
        setTimeout(() => {
            window.location.href = "/tickets.html";
        }, 500);
    }

    /**
     * Export vulnerability report
     */
    exportVulnerabilityReport() {
        const modal = document.getElementById("vulnerabilityModal");
        if (!modal.classList.contains("show")) {return;}

        const vulnTitle = modal.querySelector(".modal-title").textContent;
        const vulnInfo = modal.querySelector("#vulnerabilityInfo").innerHTML;
        
        const reportContent = `
            ${vulnTitle}\n
                    Generated: ${new Date().toLocaleString()}\n
                    ${vulnInfo.replace(/<[^>]*>/g, "").replace(/&nbsp;/g, " ")}
                `;

        const blob = new Blob([reportContent], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerability_report_${new Date().toISOString().split("T")[0]}.txt`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Vulnerability report exported", "success");
    }

    /**
     * Generate device PDF (placeholder)
     * @param {string} _hostname - Hostname (unused for now)
     */
    generateDevicePDF(_hostname) {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    /**
     * Generate vulnerability PDF (placeholder)
     */
    generateVulnerabilityPDF() {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    /**
     * Show loading indicator
     * @param {string} message - Loading message
     */
    showLoading(message = "Loading...") {
        if (window.toastManager) {
            return window.toastManager.showLoading(message);
        }
        console.log("Loading:", message);
    }

    /**
     * Hide loading indicator
     */
    hideLoading() {
        if (window.toastManager) {
            window.toastManager.hideLoading();
        }
        console.log("Loading hidden");
    }

    /**
     * Show toast notification
     * @param {string} message - Toast message
     * @param {string} type - Toast type (success, danger, warning, info)
     */
    showToast(message, type = "info") {
        if (window.toastManager) {
            return window.toastManager.showToast(message, type);
        }
        console.log(`Toast [${type}]: ${message}`);
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Delegates to the statistics manager
     */
    flipStatCards() {
        if (this.statisticsManager && this.statisticsManager.flipStatCards) {
            return this.statisticsManager.flipStatCards();
        } else {
            console.error("Statistics manager or flipStatCards method not available");
        }
    }

    /**
     * Cleanup method to prevent memory leaks
     * Removes event listeners and closes connections
     */
    destroy() {
        try {
            // Close WebSocket connection
            if (this.websocketClient && typeof this.websocketClient.disconnect === "function") {
                this.websocketClient.disconnect();
            }

            // Clean up data manager listeners
            if (this.dataManager && typeof this.dataManager.removeAllListeners === "function") {
                this.dataManager.removeAllListeners();
            }

            // Clean up managers
            if (this.gridManager && typeof this.gridManager.destroy === "function") {
                this.gridManager.destroy();
            }

            if (this.chartManager && typeof this.chartManager.destroy === "function") {
                this.chartManager.destroy();
            }

            // Clear references
            this.websocketClient = null;
            this.progressModal = null;
            this.dataManager = null;
            this.statisticsManager = null;
            this.chartManager = null;
            this.searchManager = null;
            this.gridManager = null;
            this.cardsManager = null;

            console.log("VulnerabilityCoreOrchestrator cleanup completed");
        } catch (error) {
            console.error("Error during cleanup:", error);
        }
    }
}

// Global export for browser usage
window.VulnerabilityCoreOrchestrator = VulnerabilityCoreOrchestrator;