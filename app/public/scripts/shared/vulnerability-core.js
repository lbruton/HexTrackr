/**
 * @fileoverview VulnerabilityCoreOrchestrator - Central coordination and orchestration for vulnerability management
 * Extracted from ModernVulnManager as part of Phase 2 modularization (T004)
 * @version 2.0.0
 * @author Claude
 * @date 2025-09-08
 */

/* eslint-env browser, es6 */
/* global bootstrap, fetch, confirm, Blob, URL, FormData, WebSocketClient, ProgressModal, PaginationController, console, document, window, setTimeout */

// Import ES6 modules
import { VulnerabilityChartManager } from './vulnerability-chart-manager.js';
import { VulnerabilityGridManager } from './vulnerability-grid.js';

/**
 * Central orchestrator for vulnerability management system
 * Coordinates between all extracted modules and handles cross-cutting concerns
 */
export class VulnerabilityCoreOrchestrator {
    constructor() {
        this.apiBase = "/api";
        this.currentView = "table";
        
        // Module managers will be injected
        this.dataManager = null;
        this.statisticsManager = null;
        this.chartManager = null;
        this.searchManager = null;
        this.gridManager = null;
        this.cardsManager = null;
        
        // Initialize pagination controllers
        this.devicePagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        this.vulnerabilityPagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        
        // Initialize WebSocket and progress modal
        this.websocketClient = null;
        this.progressModal = null;
        
        // File import state
        this.pendingFile = null;
    }

    /**
     * Initialize all modules and their interconnections (NEW - single initialization point)
     * @param {Object} parentContext - Parent context for callbacks (ModernVulnManager instance)
     */
    async initializeAllModules(parentContext) {
        // Create all modules (single creation point)
        this.dataManager = new VulnerabilityDataManager("/api");
        this.statisticsManager = new VulnerabilityStatisticsManager(this.dataManager);
        this.chartManager = new VulnerabilityChartManager("vulnerability-chart", this.statisticsManager, this.dataManager);
        this.searchManager = new VulnerabilitySearchManager("/api", this.dataManager, parentContext);
        this.gridManager = new VulnerabilityGridManager(this.dataManager, parentContext);
        this.cardsManager = new VulnerabilityCardsManager(this.dataManager, this.devicePagination, this.vulnerabilityPagination, parentContext);
        
        // Initialize WebSocket and progress modal
        await this.initializeWebSocketAndProgressModal();
        
        // Setup cross-module event coordination
        this.setupDataManagerListeners();
        this.setupEventListeners();
        
        // Setup theme change listeners for all components - T028
        this.setupThemeListeners();
        
        // Initialize modules in proper order (single initialization point)
        this.gridManager.initializeGrid();
        this.chartManager.initialize();
        
        // Load initial data (single data load)
        await this.loadData();
    }


    /**
     * Initialize WebSocket client and progress modal for real-time progress tracking
     */
    async initializeWebSocketAndProgressModal() {
        try {
            // Initialize WebSocket client if available
            if (typeof WebSocketClient !== "undefined") {
                this.websocketClient = new WebSocketClient();
                await this.websocketClient.connect();
                console.log("WebSocket client connected for progress tracking");
            } else {
                console.warn("WebSocket client not available - progress modal will work in manual mode");
            }
            
            // Initialize progress modal if available
            if (typeof ProgressModal !== "undefined") {
                this.progressModal = new ProgressModal(this.websocketClient);
                console.log("Progress modal initialized");
            } else {
                console.warn("Progress modal not available - falling back to traditional loading indicators");
            }
        } catch (error) {
            console.error("Error initializing WebSocket/Progress modal:", error);
            // Continue without WebSocket - modal will work in manual mode
        }
    }

    /**
     * Setup data manager event listeners for cross-module coordination
     */
    setupDataManagerListeners() {
        // Listen to data manager events
        this.dataManager.on("dataLoaded", (_data) => {
            this.updateChart();
            this.updateCurrentView();
        });

        this.dataManager.on("dataFiltered", (_data) => {
            this.updateCurrentView();
        });

        this.dataManager.on("statisticsLoaded", (_data) => {
            this.updateStatisticsDisplay();
        });

        this.dataManager.on("error", (data) => {
            this.showToast(data.message, "danger");
        });
    }

    /**
     * Setup global event listeners for UI interactions
     */
    setupEventListeners() {
        // Import CSV - Show date picker modal
        document.getElementById("importCsvBtn").addEventListener("click", () => {
            document.getElementById("csvFileInput").click();
        });

        document.getElementById("csvFileInput").addEventListener("change", (e) => {
            this.showScanDateModal(e);
        });

        // Confirm scan date and proceed with import
        document.getElementById("confirmScanDate").addEventListener("click", () => {
            this.proceedWithImport();
        });

        // View switcher for Tabler.io button group
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const view = e.target.dataset.view || e.target.closest("[data-view]").dataset.view;
                if (view) {
                    this.switchView(view);
                }
            });
        });

        // Export button
        document.getElementById("exportBtn").addEventListener("click", () => {
            this.exportData();
        });

        // Refresh button - Check if exists before adding listener
        const refreshBtn = document.getElementById("refreshBtn");
        if (refreshBtn) {
            refreshBtn.addEventListener("click", () => {
                this.dataManager.refreshData();
            });
        }

        // Save vulnerability edit
        const saveVulnEdit = document.getElementById("saveVulnEdit");
        if (saveVulnEdit) {
            saveVulnEdit.addEventListener("click", () => {
                this.saveVulnerabilityChanges();
            });
        }
    }

    /**
     * Setup theme change listeners for grid and chart components - T028
     * Connects theme controller changes to component updateTheme methods
     */
    setupThemeListeners() {
        try {
            // Access global theme controller from header.js
            const themeController = window.themeController;
            
            if (!themeController) {
                console.warn('Theme controller not available - theme switching may not work properly');
                return;
            }

            // Add theme change listener for centralized AG-Grid theme management
            themeController.addThemeChangeListener((newTheme, source) => {
                try {
                    // Use centralized AGGridThemeManager for all grids
                    if (window.agGridThemeManager) {
                        window.agGridThemeManager.updateTheme(newTheme === 'dark');
                        console.log(`AGGridThemeManager theme update: ${newTheme} - Success`);
                    }
                    
                    // Fallback to individual grid manager if AGGridThemeManager not available
                    else if (this.gridManager && this.gridManager.hasThemeSupport()) {
                        const success = this.gridManager.updateTheme(newTheme);
                        console.log(`Grid theme update (fallback): ${newTheme} - ${success ? 'Success' : 'Failed'}`);
                    }
                } catch (error) {
                    console.error('Error updating grid theme:', error);
                }
            });

            // Add theme change listener for chart manager  
            themeController.addThemeChangeListener((newTheme, source) => {
                try {
                    if (this.chartManager && this.chartManager.hasThemeSupport && this.chartManager.hasThemeSupport()) {
                        const success = this.chartManager.updateTheme(newTheme);
                        console.log(`Chart theme update: ${newTheme} - ${success ? 'Success' : 'Failed'}`);
                    } else if (this.chartManager && this.chartManager.getThemeAdapter) {
                        // Fallback: direct theme adapter access
                        const adapter = this.chartManager.getThemeAdapter();
                        if (adapter) {
                            adapter.applyChartTheme(newTheme);
                            console.log(`Chart theme update via adapter: ${newTheme}`);
                        }
                    }
                } catch (error) {
                    console.error('Error updating chart theme:', error);
                }
            });

            console.log('Theme listeners setup complete for vulnerability components');
            
        } catch (error) {
            console.error('Error setting up theme listeners:', error);
        }
    }

    /**
     * Load data and coordinate updates across all modules
     */
    async loadData() {
        await this.dataManager.loadData();
    }

    /**
     * Update chart display through chart manager
     */
    updateChart() {
        this.chartManager.update();
    }

    /**
     * Update statistics display across modules
     */
    updateStatisticsDisplay() {
        if (this.statisticsManager) {
            this.statisticsManager.updateStatisticsDisplay();
            console.log("Statistics display updated via statisticsManager");
        } else {
            console.warn("StatisticsManager not available for display update");
        }
    }

    /**
     * Switch between different view modes (table, devices, vulnerabilities)
     * @param {string} view - View type to switch to
     */
    switchView(view) {
        this.currentView = view;
        
        // Update active button state
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.classList.remove("active");
        });
        document.querySelector(`[data-view="${view}"]`)?.classList.add("active");
        
        // Show/hide the correct view containers
        const viewContainers = {
            "table": "tableView",
            "devices": "devicesView", 
            "vulnerabilities": "vulnerabilitiesView"
        };
        
        Object.entries(viewContainers).forEach(([viewType, containerId]) => {
            const container = document.getElementById(containerId);
            if (container) {
                if (viewType === view) {
                    container.classList.remove("d-none");
                    container.style.display = "block";
                } else {
                    container.classList.add("d-none");
                    container.style.display = "none";
                }
            }
        });
        
        // Update modules for current view
        this.updateCurrentView();
    }

    /**
     * Update current view display based on active view type
     */
    updateCurrentView() {
        switch (this.currentView) {
            case "table":
                this.gridManager.updateForCurrentView(this.currentView);
                break;
            case "devices":
                this.cardsManager.updateForCurrentView(this.currentView);
                break;
            case "vulnerabilities":
                this.cardsManager.updateForCurrentView(this.currentView);
                break;
        }
    }

    /**
     * Show scan date modal for CSV import
     * @param {Event} event - File input change event
     */
    showScanDateModal(event) {
        this.pendingFile = event.target.files[0];
        if (!this.pendingFile) {return;}

        const today = new Date().toISOString().split("T")[0];
        document.getElementById("scanDateInput").value = today;

        const modal = new bootstrap.Modal(document.getElementById("scanDateModal"));
        modal.show();
    }

    /**
     * Proceed with CSV import after date confirmation
     */
    async proceedWithImport() {
        const scanDate = document.getElementById("scanDateInput").value;
        if (!scanDate) {
            this.showToast("Please select a scan date", "danger");
            return;
        }

        const modal = bootstrap.Modal.getInstance(document.getElementById("scanDateModal"));
        modal.hide();

        await this.handleCsvImportWithDate(this.pendingFile, scanDate);
        
        this.pendingFile = null;
        document.getElementById("csvFileInput").value = "";
    }

    /**
     * Handle CSV import with progress tracking
     * @param {File} file - CSV file to import
     * @param {string} scanDate - Scan date for the import
     */
    async handleCsvImportWithDate(file, scanDate) {
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                return;
            }
        }

        // Use progress modal if available, otherwise fall back to loading indicators
        const useProgressModal = this.progressModal && this.websocketClient?.isSocketConnected();
        let sessionId = null;

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");
            formData.append("scanDate", scanDate);

            if (useProgressModal) {
                // Show progress modal for real-time updates
                sessionId = `import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                formData.append("sessionId", sessionId);
                
                this.progressModal.show({
                    title: "Importing CSV Data",
                    sessionId: sessionId,
                    allowCancel: true,
                    onCancel: () => this.cancelCsvImport(sessionId),
                    initialMessage: `Uploading ${file.name}...`
                });
            } else {
                // Fall back to traditional loading indicator
                this.showLoading("Uploading CSV file...");
            }

            const response = await fetch(`${this.apiBase}/vulnerabilities/import-staging`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            const result = await response.json();

            if (!useProgressModal) {
                // Manual progress updates for fallback mode
                this.showLoading("Processing data...");
                await new Promise(resolve => setTimeout(resolve, 500));
                
                this.showLoading("Refreshing charts and data...");
                await this.loadData();
                
                this.hideLoading();
                
                let message = `CSV import completed! Processed ${result.rowsProcessed.toLocaleString()} rows from ${result.filename} with scan date ${scanDate}.`;
                if (result.insertCount || result.updateCount || result.removedStale) {
                    message += ` Added: ${result.insertCount || 0}, Updated: ${result.updateCount || 0}, Removed: ${result.removedStale || 0} stale items.`;
                }
                
                this.showToast(message, "success");
            } else {
                // Progress modal will handle completion via WebSocket events
                // Just refresh data when process completes
                setTimeout(async () => {
                    await this.loadData();
                }, 1000);
            }

        } catch (error) {
            console.error("Error importing CSV:", error);
            
            if (useProgressModal && this.progressModal) {
                this.progressModal.showError(`Import failed: ${error.message}`);
            } else {
                this.hideLoading();
                this.showToast("Error importing CSV: " + error.message, "danger");
            }
        }
    }

    /**
     * Cancel CSV import operation
     * @param {string} sessionId - Session ID to cancel
     */
    async cancelCsvImport(sessionId) {
        try {
            await fetch(`${this.apiBase}/vulnerabilities/import-cancel`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ sessionId })
            });
            
            this.showToast("CSV import cancelled", "warning");
        } catch (error) {
            console.error("Error cancelling import:", error);
            this.showToast("Failed to cancel import", "danger");
        }
    }

    /**
     * Export vulnerability data to CSV
     */
    async exportData() {
        try {
            this.showLoading("Exporting data...");
            const response = await fetch(`${this.apiBase}/vulnerabilities/export`);
            
            if (!response.ok) {
                throw new Error("Export failed");
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.style.display = "none";
            a.href = url;
            a.download = `vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            this.hideLoading();
            this.showToast("Data exported successfully", "success");
        } catch (error) {
            this.hideLoading();
            this.showToast("Export failed: " + error.message, "danger");
        }
    }

    /**
     * View device details (delegated to device security modal)
     * @param {string} hostname - Hostname to view details for
     */
    viewDeviceDetails(hostname) {
        if (typeof DeviceSecurityModal !== "undefined" && window.deviceSecurityModal) {
            window.deviceSecurityModal.showDeviceDetails(hostname, this.dataManager);
        } else {
            this.showToast("Device details modal not available", "warning");
        }
    }

    /**
     * View vulnerability details (delegated to vulnerability details modal)
     * @param {string} vulnDataId - Vulnerability data ID
     */
    viewVulnerabilityDetails(vulnDataId) {
        const vulnData = window.vulnModalData?.[vulnDataId];
        if (vulnData && typeof VulnerabilityDetailsModal !== "undefined") {
            window.vulnDetailsModal?.showVulnerabilityDetails(vulnData, this.dataManager);
        } else {
            this.showToast("Vulnerability details not available", "warning");
        }
    }

    /**
     * Lookup vulnerability (delegated to search manager)
     * @param {string} vulnId - Vulnerability ID to lookup
     * @param {string} pluginName - Optional plugin name
     */
    async lookupVulnerability(vulnId, pluginName = null) {
        await this.searchManager.lookupVulnerability(vulnId, pluginName);
    }
    
    /**
     * Show vulnerability details modal filtered by CVE ID
     * T015: Fix modal state to display single CVE instead of all CVEs
     * T016: Update modal data population to filter by clicked CVE ID
     * @param {string} cveId - The CVE ID to filter by
     */
    showVulnerabilityDetailsByCVE(cveId) {
        if (!cveId || typeof cveId !== "string") {
            console.error("Invalid CVE ID provided to showVulnerabilityDetailsByCVE:", cveId);
            this.showToast("Invalid vulnerability ID", "error");
            return;
        }
        
        // Check if modal and data manager are available
        if (!window.vulnDetailsModal) {
            console.error("Vulnerability details modal not available");
            this.showToast("Vulnerability details not available", "warning");
            return;
        }
        
        if (!this.dataManager || !this.dataManager.vulnerabilities) {
            console.error("Data manager or vulnerabilities not available");
            this.showToast("Vulnerability data not available", "warning");
            return;
        }
        
        console.log("ðŸŽ¯ Opening modal for CVE ID:", cveId);
        
        // Use the new CVE-specific modal method
        window.vulnDetailsModal.showVulnerabilityDetailsByCVE(cveId, this.dataManager);
    }

    /**
     * Save vulnerability changes
     */
    async saveVulnerabilityChanges() {
        // Implementation would depend on vulnerability editing modal
        this.showToast("Vulnerability changes saved", "success");
    }

    /**
     * Export device report
     * @param {string} hostname - Hostname to export report for
     */
    async exportDeviceReport(hostname) {
        const deviceData = this.dataManager.getDevices().find(d => d.hostname === hostname);
        if (!deviceData) {
            this.showToast("Device not found", "danger");
            return;
        }

        const reportData = {
            hostname: hostname,
            vulnerabilities: this.dataManager.getAllVulnerabilities().filter(v => v.hostname === hostname),
            generated: new Date().toISOString(),
            filename: `device_report_${hostname}_${new Date().toISOString().split("T")[0]}.csv`
        };

        const headers = ["Hostname", "CVE", "Severity", "Description", "Port", "First Seen", "Last Seen"];
        const rows = reportData.vulnerabilities.map(v => [
            v.hostname,
            v.cve || "N/A",
            v.severity,
            v.description || v.plugin_name || "N/A",
            v.port || "N/A",
            v.first_seen ? new Date(v.first_seen).toLocaleDateString() : "N/A",
            v.last_seen ? new Date(v.last_seen).toLocaleDateString() : "N/A"
        ]);

        const csv = [headers, ...rows].map(row => 
            row.map(cell => `"${String(cell).replace(/"/g, "\"\"")}"`).join(",")
        ).join("\n");

        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", reportData.filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Device report exported for ${hostname}`, "success");
    }

    /**
     * Export vulnerability report
     */
    exportVulnerabilityReport() {
        const modal = document.getElementById("vulnerabilityModal");
        if (!modal.classList.contains("show")) {return;}

        const vulnTitle = modal.querySelector(".modal-title").textContent;
        const vulnInfo = modal.querySelector("#vulnerabilityInfo").innerHTML;
        
        const reportContent = `
            ${vulnTitle}\n
                    Generated: ${new Date().toLocaleString()}\n
                    ${vulnInfo.replace(/<[^>]*>/g, "").replace(/&nbsp;/g, " ")}
                `;

        const blob = new Blob([reportContent], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerability_report_${new Date().toISOString().split("T")[0]}.txt`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Vulnerability report exported", "success");
    }

    /**
     * Generate device PDF (placeholder)
     * @param {string} _hostname - Hostname (unused for now)
     */
    generateDevicePDF(_hostname) {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    /**
     * Generate vulnerability PDF (placeholder)
     */
    generateVulnerabilityPDF() {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    /**
     * Show loading indicator
     * @param {string} message - Loading message
     */
    showLoading(message = "Loading...") {
        if (window.toastManager) {
            return window.toastManager.showLoading(message);
        }
        console.log("Loading:", message);
    }

    /**
     * Hide loading indicator
     */
    hideLoading() {
        if (window.toastManager) {
            window.toastManager.hideLoading();
        }
        console.log("Loading hidden");
    }

    /**
     * Show toast notification
     * @param {string} message - Toast message
     * @param {string} type - Toast type (success, danger, warning, info)
     */
    showToast(message, type = "info") {
        if (window.toastManager) {
            return window.toastManager.showToast(message, type);
        }
        console.log(`Toast [${type}]: ${message}`);
    }

    /**
     * Flip statistics cards between vulnerability counts and VPR scores
     * Delegates to the statistics manager
     */
    flipStatCards() {
        if (this.statisticsManager && this.statisticsManager.flipStatCards) {
            return this.statisticsManager.flipStatCards();
        } else {
            console.error("Statistics manager or flipStatCards method not available");
        }
    }
}