/**
 * VulnerabilityService - Core vulnerability business logic and database operations
 * Extracted from server.js lines: 252-341, 343-558, 559-742, 768-1295, 1306-1703, 2159-2283, 2337-2514, 2517-2531, 3304-3317, 3501-3565
 *
 * This service handles the most complex business logic in HexTrackr:
 * - Multi-vendor vulnerability data processing and normalization
 * - Advanced deduplication using enhanced unique keys with confidence scoring
 * - Lifecycle management (active, grace_period, resolved, reopened states)
 * - CSV import processing with staging table support for performance
 * - VPR and CVSS score processing and validation
 * - Host/IP normalization and asset correlation
 * - Daily totals calculation and rollup operations
 * - Large-scale data operations with performance instrumentation
 *
 * Key Dependencies (utility functions remain in server.js):
 * - mapVulnerabilityRow: Maps CSV rows to vulnerability objects
 * - generateEnhancedUniqueKey: Multi-tier deduplication key generation
 * - extractScanDateFromFilename: Date extraction from filenames
 * - normalizeHostname, normalizeIPAddress: Network asset normalization
 * - PathValidator: Secure file operations
 * - Papa: CSV parsing
 *
 * T053 INTEGRATION NOTES:
 * This service requires database initialization and access to utility functions.
 * Utility functions must remain in server.js for shared access.
 */

const Papa = require("papaparse");
const path = require("path");
const fs = require("fs");

class VulnerabilityService {
    constructor() {
        this.db = null;
    }

    /**
     * Initialize service with database connection
     * @param {sqlite3.Database} database - Database connection from server.js
     */
    initialize(database) {
        this.db = database;
    }

    /**
     * Get vulnerabilities with pagination and filtering
     * Extracted from server.js lines 2159-2218
     */
    async getVulnerabilities(options = {}) {
        const { page = 1, limit = 50, search = "", severity = "" } = options;
        const offset = (page - 1) * limit;

        return new Promise((resolve, reject) => {
            let whereClause = "";
            const params = [];

            // CRITICAL FIX: Always filter by lifecycle_state to show only active vulnerabilities
            const conditions = ["lifecycle_state IN (?, ?)"];
            params.push("active", "reopened");

            if (search) {
                conditions.push("(hostname LIKE ? OR cve LIKE ? OR plugin_name LIKE ?)");
                params.push(`%${search}%`, `%${search}%`, `%${search}%`);
            }
            if (severity) {
                conditions.push("severity = ?");
                params.push(severity);
            }

            whereClause = "WHERE " + conditions.join(" AND ");

            const query = `
                SELECT * FROM vulnerabilities_current
                ${whereClause}
                ORDER BY vpr_score DESC, last_seen DESC
                LIMIT ? OFFSET ?
            `;

            params.push(limit, offset);

            this.db.all(query, params, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch vulnerabilities: " + err.message));
                }

                // Get total count for pagination
                const countQuery = `SELECT COUNT(*) as total FROM vulnerabilities_current ${whereClause}`;
                this.db.get(countQuery, params.slice(0, -2), (err, countResult) => {
                    if (err) {
                        return reject(new Error("Failed to count vulnerabilities: " + err.message));
                    }

                    resolve({
                        data: rows,
                        pagination: {
                            page,
                            limit,
                            total: countResult.total,
                            pages: Math.ceil(countResult.total / limit)
                        }
                    });
                });
            });
        });
    }

    /**
     * Get resolved/fixed vulnerabilities
     * Extracted from server.js lines 2221-2283
     */
    async getResolvedVulnerabilities(options = {}) {
        const { page = 1, limit = 50, search = "" } = options;
        const offset = (page - 1) * limit;

        return new Promise((resolve, reject) => {
            let whereClause = "";
            const params = [];

            // Show only resolved vulnerabilities
            const conditions = ["lifecycle_state = ?"];
            params.push("resolved");

            if (search) {
                conditions.push("(hostname LIKE ? OR cve LIKE ? OR plugin_name LIKE ?)");
                params.push(`%${search}%`, `%${search}%`, `%${search}%`);
            }

            whereClause = "WHERE " + conditions.join(" AND ");

            const query = `
                SELECT *,
                       resolved_date,
                       resolution_reason,
                       CASE
                         WHEN resolved_date IS NOT NULL THEN 'Fixed on ' || resolved_date
                         ELSE 'Status unknown'
                       END as resolution_summary
                FROM vulnerabilities_current
                ${whereClause}
                ORDER BY resolved_date DESC, last_seen DESC
                LIMIT ? OFFSET ?
            `;

            params.push(limit, offset);

            this.db.all(query, params, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch resolved vulnerabilities: " + err.message));
                }

                // Get total count for pagination
                const countQuery = `SELECT COUNT(*) as total FROM vulnerabilities_current ${whereClause}`;
                this.db.get(countQuery, params.slice(0, -2), (err, countResult) => {
                    if (err) {
                        return reject(new Error("Failed to count resolved vulnerabilities: " + err.message));
                    }

                    resolve({
                        data: rows,
                        pagination: {
                            page,
                            limit,
                            total: countResult.total,
                            pages: Math.ceil(countResult.total / limit)
                        }
                    });
                });
            });
        });
    }

    /**
     * Import CSV vulnerabilities (standard processing)
     * Extracted from server.js lines 2337-2399
     * Delegates to server.js utility functions for processing
     */
    async importCSV(options = {}) {
        const { filePath, filename, vendor, scanDate, fileSize, startTime } = options;

        return new Promise((resolve, reject) => {
            // Access server.js global utility functions
            const PathValidator = global.PathValidator || require("../utils/pathValidator");
            const mapVulnerabilityRow = global.mapVulnerabilityRow;
            const extractScanDateFromFilename = global.extractScanDateFromFilename;
            const processVulnerabilityRowsWithEnhancedLifecycle = global.processVulnerabilityRowsWithEnhancedLifecycle;

            if (!mapVulnerabilityRow || !extractScanDateFromFilename || !processVulnerabilityRowsWithEnhancedLifecycle) {
                return reject(new Error("Required utility functions not available. Ensure server.js globals are set."));
            }

            try {
                const extractedDate = extractScanDateFromFilename(filename);
                const finalScanDate = scanDate || extractedDate || new Date().toISOString().split("T")[0];

                // Log filename date extraction for debugging
                if (extractedDate) {
                    console.log(`Extracted date '${extractedDate}' from filename '${filename}'`);
                } else if (!scanDate) {
                    console.log(`No date extracted from filename '${filename}', using today's date`);
                }

                // Read and parse CSV
                const csvData = PathValidator.safeReadFileSync(filePath, "utf8");

                Papa.parse(csvData, {
                    header: true,
                    complete: (results) => {
                        const rows = results.data.filter(row => Object.values(row).some(val => val && val.trim()));

                        // Insert import record
                        const importQuery = `
                            INSERT INTO vulnerability_imports
                            (filename, import_date, row_count, vendor, file_size, processing_time, raw_headers)
                            VALUES (?, ?, ?, ?, ?, ?, ?)
                        `;

                        this.db.run(importQuery, [
                            filename,
                            new Date().toISOString(),
                            rows.length,
                            vendor,
                            fileSize,
                            Date.now() - startTime,
                            JSON.stringify(results.meta.fields)
                        ], function(err) {
                            if (err) {
                                return reject(new Error("Failed to create import record: " + err.message));
                            }

                            const importId = this.lastID;

                            // Process rows using enhanced rollover architecture with lifecycle management
                            // Note: This creates a custom response handler for the service context
                            const serviceResponseHandler = {
                                json: (data) => resolve(data),
                                status: (code) => ({
                                    json: (data) => reject(new Error(`HTTP ${code}: ${JSON.stringify(data)}`))
                                })
                            };

                            processVulnerabilityRowsWithEnhancedLifecycle(rows, null, importId, filePath, {
                                success: true,
                                importId,
                                filename,
                                processingTime: Date.now() - startTime
                            }, serviceResponseHandler, finalScanDate);
                        });
                    },
                    error: (error) => {
                        reject(new Error("CSV parsing failed: " + error.message));
                    }
                });
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * High-performance CSV import using staging table
     * Extracted from server.js lines 2403-2514
     */
    async importCSVStaging(options = {}) {
        const { filePath, filename, vendor, scanDate, fileSize, startTime, sessionId, progressTracker } = options;

        return new Promise((resolve, reject) => {
            // Access server.js global utility functions
            const PathValidator = global.PathValidator || require("../utils/pathValidator");
            const extractScanDateFromFilename = global.extractScanDateFromFilename;
            const bulkLoadToStagingTable = global.bulkLoadToStagingTable;

            if (!extractScanDateFromFilename || !bulkLoadToStagingTable) {
                return reject(new Error("Required utility functions not available. Ensure server.js globals are set."));
            }

            try {
                const extractedDate = extractScanDateFromFilename(filename);
                const finalScanDate = scanDate || extractedDate || new Date().toISOString().split("T")[0];

                // Update progress: Starting CSV parsing
                if (progressTracker && sessionId) {
                    progressTracker.updateProgress(sessionId, 5, "Parsing CSV file...", { currentStep: 1 });
                }

                // Read and parse CSV
                const csvData = PathValidator.safeReadFileSync(filePath, "utf8");

                Papa.parse(csvData, {
                    header: true,
                    complete: (results) => {
                        const rows = results.data.filter(row => Object.values(row).some(val => val && val.trim()));

                        // Update progress: CSV parsing completed
                        if (progressTracker && sessionId) {
                            progressTracker.updateProgress(sessionId, 15, `Parsed ${rows.length} rows from CSV`, {
                                currentStep: 1,
                                rowCount: rows.length
                            });
                        }

                        console.log(`ðŸ“ˆ Parsed ${rows.length} rows from CSV`);

                        // Insert import record
                        const importQuery = `
                            INSERT INTO vulnerability_imports
                            (filename, import_date, row_count, vendor, file_size, processing_time, raw_headers)
                            VALUES (?, ?, ?, ?, ?, ?, ?)
                        `;

                        this.db.run(importQuery, [
                            filename,
                            new Date().toISOString(),
                            rows.length,
                            vendor,
                            fileSize,
                            0, // Will update after completion
                            JSON.stringify(results.meta.fields)
                        ], function(err) {
                            if (err) {
                                if (progressTracker && sessionId) {
                                    progressTracker.errorSession(sessionId, "Failed to create import record: " + err.message, { error: err });
                                }
                                return reject(new Error("Failed to create import record: " + err.message));
                            }

                            const importId = this.lastID;
                            console.log(`ðŸ“ Import record created: ID ${importId}`);

                            // Update progress: Starting bulk load to staging
                            if (progressTracker && sessionId) {
                                progressTracker.updateProgress(sessionId, 20, "Loading data to staging table...", {
                                    currentStep: 2,
                                    importId: importId
                                });
                            }

                            // Bulk load to staging table
                            bulkLoadToStagingTable(rows, importId, finalScanDate, filePath, {
                                success: true,
                                importId,
                                filename,
                                vendor,
                                scanDate: finalScanDate,
                                stagingMode: true
                            }, sessionId, startTime, progressTracker);

                            // Return success immediately (processing continues asynchronously)
                            resolve({
                                success: true,
                                importId,
                                filename,
                                vendor,
                                scanDate: finalScanDate,
                                rowCount: rows.length,
                                stagingMode: true
                            });
                        });
                    },
                    error: (error) => {
                        if (progressTracker && sessionId) {
                            progressTracker.errorSession(sessionId, "CSV parsing failed: " + error.message, { error: error });
                        }
                        reject(new Error("CSV parsing failed: " + error.message));
                    }
                });
            } catch (error) {
                if (progressTracker && sessionId) {
                    progressTracker.errorSession(sessionId, "Import initialization failed: " + error.message, { error });
                }
                reject(error);
            }
        });
    }

    /**
     * Clear all vulnerability data
     * Extracted from server.js lines 2517-2531
     */
    async clearAllData() {
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                this.db.run("DELETE FROM ticket_vulnerabilities");
                this.db.run("DELETE FROM vulnerability_snapshots");
                this.db.run("DELETE FROM vulnerabilities_current");
                this.db.run("DELETE FROM vulnerability_daily_totals");
                this.db.run("DELETE FROM vulnerability_imports", (err) => {
                    if (err) {
                        return reject(new Error("Failed to clear vulnerability data: " + err.message));
                    }
                    resolve({ success: true, message: "All vulnerability data cleared from rollover architecture" });
                });
            });
        });
    }

    /**
     * Export vulnerability data for backup
     * Extracted from server.js lines 3304-3317
     */
    async exportVulnerabilities() {
        return new Promise((resolve, reject) => {
            this.db.all("SELECT * FROM vulnerabilities LIMIT 10000", (err, rows) => {
                if (err) {
                    return reject(new Error("Export failed: " + err.message));
                }
                resolve({
                    type: "vulnerabilities",
                    count: rows.length,
                    data: rows,
                    exported_at: new Date().toISOString()
                });
            });
        });
    }

    /**
     * Import vulnerabilities from web-based JSON data
     * Extracted from server.js lines 3501-3565
     */
    async importVulnerabilitiesWeb(csvData) {
        return new Promise((resolve, reject) => {
            const importDate = new Date().toISOString();
            let imported = 0;
            const errors = [];

            // Create import record
            const importQuery = `
                INSERT INTO vulnerability_imports
                (filename, import_date, row_count, vendor, file_size, processing_time, raw_headers)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `;

            this.db.run(importQuery, [
                "web-upload.csv",
                importDate,
                csvData.length,
                "web-import",
                0,
                0,
                JSON.stringify(Object.keys(csvData[0] || {}))
            ], function(err) {
                if (err) {
                    return reject(new Error("Failed to create import record: " + err.message));
                }

                const importId = this.lastID;

                // Process each row
                let processed = 0;

                function processNextRow() {
                    if (processed >= csvData.length) {
                        resolve({
                            imported,
                            errors,
                            total: csvData.length
                        });
                        return;
                    }

                    const row = csvData[processed];
                    processed++;

                    // Access server.js utility functions
                    const mapVulnerabilityRow = global.mapVulnerabilityRow;
                    if (!mapVulnerabilityRow) {
                        errors.push(`Row ${processed}: mapVulnerabilityRow function not available`);
                        processNextRow();
                        return;
                    }

                    try {
                        const mappedRows = mapVulnerabilityRow(row);
                        if (mappedRows && mappedRows.length > 0) {
                            // For simplicity, take the first mapped row
                            const mapped = mappedRows[0];

                            const sql = `INSERT OR REPLACE INTO vulnerabilities (
                                hostname, ip_address, cve, severity, vpr_score, cvss_score,
                                plugin_id, plugin_name, description, solution, vendor,
                                vulnerability_date, state, import_id, created_at
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

                            this.db.run(sql, [
                                mapped.hostname, mapped.ipAddress, mapped.cve, mapped.severity,
                                mapped.vprScore, mapped.cvssScore, mapped.pluginId, mapped.pluginName,
                                mapped.description, mapped.solution, mapped.vendor,
                                mapped.pluginPublished, mapped.state, importId,
                                new Date().toISOString()
                            ], function(insertErr) {
                                if (insertErr) {
                                    errors.push(`Row ${processed}: ${insertErr.message}`);
                                } else {
                                    imported++;
                                }
                                processNextRow();
                            });
                        } else {
                            errors.push(`Row ${processed}: No valid data after mapping`);
                            processNextRow();
                        }
                    } catch (mappingError) {
                        errors.push(`Row ${processed}: Mapping failed - ${mappingError.message}`);
                        processNextRow();
                    }
                }

                processNextRow();
            }.bind(this));
        });
    }

    /**
     * Update vulnerability lifecycle state
     * Helper method for lifecycle management
     */
    async updateLifecycleState(vulnerabilityId, newState, reason = null) {
        return new Promise((resolve, reject) => {
            const resolvedDate = (newState === "resolved") ? new Date().toISOString().split("T")[0] : null;

            const sql = `
                UPDATE vulnerabilities_current
                SET lifecycle_state = ?,
                    resolved_date = ?,
                    resolution_reason = ?
                WHERE id = ?
            `;

            this.db.run(sql, [newState, resolvedDate, reason, vulnerabilityId], function(err) {
                if (err) {
                    return reject(new Error("Failed to update lifecycle state: " + err.message));
                }
                resolve({ changes: this.changes });
            });
        });
    }

    /**
     * Get vulnerability by ID
     * Helper method for detailed operations
     */
    async getVulnerabilityById(id) {
        return new Promise((resolve, reject) => {
            this.db.get("SELECT * FROM vulnerabilities_current WHERE id = ?", [id], (err, row) => {
                if (err) {
                    return reject(new Error("Failed to fetch vulnerability: " + err.message));
                }
                resolve(row);
            });
        });
    }

    /**
     * Calculate vulnerability daily totals
     * Helper method for statistics rollup
     */
    async calculateDailyTotals(scanDate) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    severity,
                    COUNT(*) as count,
                    SUM(vpr_score) as total_vpr
                FROM vulnerabilities_current
                WHERE scan_date = ? AND lifecycle_state IN ('active', 'reopened')
                GROUP BY severity
            `;

            this.db.all(query, [scanDate], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to calculate daily totals: " + err.message));
                }

                const totals = {
                    scan_date: scanDate,
                    critical_count: 0,
                    critical_total_vpr: 0,
                    high_count: 0,
                    high_total_vpr: 0,
                    medium_count: 0,
                    medium_total_vpr: 0,
                    low_count: 0,
                    low_total_vpr: 0,
                    total_vulnerabilities: 0,
                    total_vpr: 0
                };

                rows.forEach(row => {
                    const severity = row.severity.toLowerCase();
                    const count = row.count || 0;
                    const totalVpr = row.total_vpr || 0;

                    if (severity === "critical") {
                        totals.critical_count = count;
                        totals.critical_total_vpr = totalVpr;
                    } else if (severity === "high") {
                        totals.high_count = count;
                        totals.high_total_vpr = totalVpr;
                    } else if (severity === "medium") {
                        totals.medium_count = count;
                        totals.medium_total_vpr = totalVpr;
                    } else if (severity === "low") {
                        totals.low_count = count;
                        totals.low_total_vpr = totalVpr;
                    }

                    totals.total_vulnerabilities += count;
                    totals.total_vpr += totalVpr;
                });

                resolve(totals);
            });
        });
    }
}

module.exports = VulnerabilityService;