/**
 * VulnerabilityService - Core vulnerability business logic and database operations
 * Extracted from server.js lines: 252-341, 343-558, 559-742, 768-1295, 1306-1703, 2159-2283, 2337-2514, 2517-2531, 3304-3317, 3501-3565
 *
 * This service handles the most complex business logic in HexTrackr:
 * - Multi-vendor vulnerability data processing and normalization
 * - Advanced deduplication using enhanced unique keys with confidence scoring
 * - Lifecycle management (active, grace_period, resolved, reopened states)
 * - CSV import processing with staging table support for performance
 * - VPR and CVSS score processing and validation
 * - Host/IP normalization and asset correlation
 * - Daily totals calculation and rollup operations
 * - Large-scale data operations with performance instrumentation
 *
 * Key Dependencies (utility functions remain in server.js):
 * - mapVulnerabilityRow: Maps CSV rows to vulnerability objects
 * - generateEnhancedUniqueKey: Multi-tier deduplication key generation
 * - extractScanDateFromFilename: Date extraction from filenames
 * - normalizeHostname, normalizeIPAddress: Network asset normalization
 * - PathValidator: Secure file operations
 * - Papa: CSV parsing
 *
 * T053 INTEGRATION NOTES:
 * This service requires database initialization and access to utility functions.
 * Utility functions must remain in server.js for shared access.
 */

const Papa = require("papaparse");

/**
 * Defensive logging helpers
 * Safely log to LoggingService with fallback for initialization
 */
function _log(level, message, data = {}) {
    if (global.logger && global.logger.vulnerability && typeof global.logger.vulnerability[level] === "function") {
        global.logger.vulnerability[level](message, data);
    }
}

function _audit(category, message, data = {}) {
    if (global.logger && typeof global.logger.audit === "function") {
        global.logger.audit(category, message, data, null, null);
    }
}

/**
 * CSV Security Helpers
 * HEX-117: CSV injection protection utilities
 */

/**
 * Escape embedded quotes in CSV values by doubling them
 * @param {*} value - Value to escape
 * @returns {string} Escaped value safe for CSV
 */
function escapeCSV(value) {
    const str = String(value ?? "");
    return str.replace(/"/g, "\"\"");
}

/**
 * Prevent CSV formula injection by prefixing dangerous characters
 * @param {*} value - Value to sanitize
 * @returns {string} Safe value with formula chars prefixed
 */
function safeCSV(value) {
    const str = String(value ?? "");
    // Prefix formula-leading characters with single quote to prevent injection
    if (/^[=+\-@]/.test(str)) {
        return "'" + str;
    }
    return str;
}

class VulnerabilityService {
    constructor() {
        this.db = null;
    }

    /**
     * Initialize service with database connection
     * @param {sqlite3.Database} database - Database connection from server.js
     */
    initialize(database) {
        this.db = database;
    }

    /**
     * Get vulnerabilities with pagination and filtering
     * Extracted from server.js lines 2159-2218
     */
    async getVulnerabilities(options = {}) {
        const { page = 1, limit = 50, search = "", severity = "", vendor = "", isKev = false } = options; // HEX-117: Added isKev parameter
        const offset = (page - 1) * limit;

        return new Promise((resolve, reject) => {
            let whereClause = "";
            const params = [];

            // CRITICAL FIX: Always filter by lifecycle_state to show only active vulnerabilities
            const conditions = ["lifecycle_state IN (?, ?)"];
            params.push("active", "reopened");

            if (search) {
                conditions.push("(hostname LIKE ? OR cve LIKE ? OR plugin_name LIKE ?)");
                params.push(`%${search}%`, `%${search}%`, `%${search}%`);
            }
            if (severity) {
                if (severity === "KEV") {
                    conditions.push("k.cve_id IS NOT NULL");
                } else {
                    conditions.push("severity = ?");
                    params.push(severity);
                }
            }
            // HEX-117: Independent KEV filter (can be used with or without severity filter)
            // Allows KEV-first loading pattern (load 100 KEV records instantly)
            if (isKev) {
                conditions.push("k.cve_id IS NOT NULL");
            }
            // HEX-101 Blocking Issue #3: Add vendor filtering support
            // Uses indexed vendor column (idx_current_vendor) for fast lookups
            if (vendor) {
                conditions.push("vendor = ?");
                params.push(vendor);
            }

            whereClause = "WHERE " + conditions.join(" AND ");

            const query = `
                SELECT v.*,
                       CASE WHEN k.cve_id IS NOT NULL THEN 'Yes' ELSE 'No' END as isKev,
                       k.due_date as kev_due_date,
                       k.known_ransomware_use,
                       k.required_action as kev_required_action
                FROM vulnerabilities_current v
                LEFT JOIN kev_status k ON v.cve = k.cve_id
                ${whereClause}
                ORDER BY isKev DESC,
                         CASE severity
                           WHEN 'Critical' THEN 1
                           WHEN 'High' THEN 2
                           WHEN 'Medium' THEN 3
                           WHEN 'Low' THEN 4
                           ELSE 5
                         END ASC,
                         vpr_score DESC,
                         last_seen DESC
                LIMIT ? OFFSET ?
            `;

            params.push(limit, offset);

            this.db.all(query, params, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch vulnerabilities: " + err.message));
                }

                // Enrich each vulnerability with normalized_location for filtering
                const { getHostnameParserService } = require("./hostnameParserService");
                const hostnameParser = getHostnameParserService();

                rows.forEach(vuln => {
                    if (vuln.hostname) {
                        const parsed = hostnameParser.parseHostname(vuln.hostname);
                        vuln.normalized_location = parsed.location || null;
                    } else {
                        vuln.normalized_location = null;
                    }
                });

                // Get total count for pagination
                const countQuery = `
                    SELECT COUNT(*) as total
                    FROM vulnerabilities_current v
                    LEFT JOIN kev_status k ON v.cve = k.cve_id
                    ${whereClause}
                `;
                this.db.get(countQuery, params.slice(0, -2), (err, countResult) => {
                    if (err) {
                        return reject(new Error("Failed to count vulnerabilities: " + err.message));
                    }

                    resolve({
                        data: rows,
                        pagination: {
                            page,
                            limit,
                            total: countResult.total,
                            pages: Math.ceil(countResult.total / limit)
                        }
                    });
                });
            });
        });
    }

    /**
     * Get resolved/fixed vulnerabilities
     * Extracted from server.js lines 2221-2283
     */
    async getResolvedVulnerabilities(options = {}) {
        const { page = 1, limit = 50, search = "" } = options;
        const offset = (page - 1) * limit;

        return new Promise((resolve, reject) => {
            let whereClause = "";
            const params = [];

            // Show only resolved vulnerabilities
            const conditions = ["lifecycle_state = ?"];
            params.push("resolved");

            if (search) {
                conditions.push("(hostname LIKE ? OR cve LIKE ? OR plugin_name LIKE ?)");
                params.push(`%${search}%`, `%${search}%`, `%${search}%`);
            }

            whereClause = "WHERE " + conditions.join(" AND ");

            const query = `
                SELECT *,
                       resolved_date,
                       resolution_reason,
                       CASE
                         WHEN resolved_date IS NOT NULL THEN 'Fixed on ' || resolved_date
                         ELSE 'Status unknown'
                       END as resolution_summary
                FROM vulnerabilities_current
                ${whereClause}
                ORDER BY resolved_date DESC, last_seen DESC
                LIMIT ? OFFSET ?
            `;

            params.push(limit, offset);

            this.db.all(query, params, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch resolved vulnerabilities: " + err.message));
                }

                // Get total count for pagination
                const countQuery = `SELECT COUNT(*) as total FROM vulnerabilities_current ${whereClause}`;
                this.db.get(countQuery, params.slice(0, -2), (err, countResult) => {
                    if (err) {
                        return reject(new Error("Failed to count resolved vulnerabilities: " + err.message));
                    }

                    resolve({
                        data: rows,
                        pagination: {
                            page,
                            limit,
                            total: countResult.total,
                            pages: Math.ceil(countResult.total / limit)
                        }
                    });
                });
            });
        });
    }

    /**
     * Import CSV vulnerabilities (standard processing)
     * Extracted from server.js lines 2337-2399
     * Delegates to server.js utility functions for processing
     */
    async importCSV(options = {}) {
        const { filePath, filename, vendor, scanDate, fileSize, startTime } = options;

        return new Promise((resolve, reject) => {
            // Access server.js global utility functions
            const PathValidator = global.PathValidator || require("../utils/PathValidator");
            const mapVulnerabilityRow = global.mapVulnerabilityRow;
            const extractScanDateFromFilename = global.extractScanDateFromFilename;
            const processVulnerabilityRowsWithEnhancedLifecycle = global.processVulnerabilityRowsWithEnhancedLifecycle;

            if (!mapVulnerabilityRow || !extractScanDateFromFilename || !processVulnerabilityRowsWithEnhancedLifecycle) {
                return reject(new Error("Required utility functions not available. Ensure server.js globals are set."));
            }

            try {
                const extractedDate = extractScanDateFromFilename(filename);
                const finalScanDate = scanDate || extractedDate || new Date().toISOString().split("T")[0];

                // Log filename date extraction for debugging
                if (extractedDate) {
                    _log("info", `Extracted date '${extractedDate}' from filename '${filename}'`);
                } else if (!scanDate) {
                    _log("info", `No date extracted from filename '${filename}', using today's date`);
                }

                // Read and parse CSV
                const csvData = PathValidator.safeReadFileSync(filePath, "utf8");

                Papa.parse(csvData, {
                    header: true,
                    complete: (results) => {
                        const rows = results.data.filter(row => Object.values(row).some(val => val && val.trim()));

                        // Insert import record
                        const importQuery = `
                            INSERT INTO vulnerability_imports
                            (filename, import_date, row_count, vendor, file_size, processing_time, raw_headers)
                            VALUES (?, ?, ?, ?, ?, ?, ?)
                        `;

                        this.db.run(importQuery, [
                            filename,
                            new Date().toISOString(),
                            rows.length,
                            vendor,
                            fileSize,
                            Date.now() - startTime,
                            JSON.stringify(results.meta.fields)
                        ], function(err) {
                            if (err) {
                                return reject(new Error("Failed to create import record: " + err.message));
                            }

                            const importId = this.lastID;

                            // Process rows using enhanced rollover architecture with lifecycle management
                            // Note: This creates a custom response handler for the service context
                            const serviceResponseHandler = {
                                json: (data) => resolve(data),
                                status: (code) => ({
                                    json: (data) => reject(new Error(`HTTP ${code}: ${JSON.stringify(data)}`))
                                })
                            };

                            processVulnerabilityRowsWithEnhancedLifecycle(rows, null, importId, filePath, {
                                success: true,
                                importId,
                                filename,
                                processingTime: Date.now() - startTime
                            }, serviceResponseHandler, finalScanDate);
                        });
                    },
                    error: (error) => {
                        reject(new Error("CSV parsing failed: " + error.message));
                    }
                });
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * High-performance CSV import using staging table
     * Extracted from server.js lines 2403-2514
     */
    async importCSVStaging(options = {}) {
        const { filePath, filename, vendor, scanDate, fileSize, startTime, sessionId, progressTracker } = options;

        return new Promise((resolve, reject) => {
            // Import required functions from importService
            const importService = require("./importService");
            const PathValidator = require("../utils/PathValidator");
            const extractScanDateFromFilename = importService.extractScanDateFromFilename;
            const bulkLoadToStagingTable = importService.bulkLoadToStagingTable;

            try {
                const extractedDate = extractScanDateFromFilename(filename);
                const finalScanDate = scanDate || extractedDate || new Date().toISOString().split("T")[0];

                // Update progress: Starting CSV parsing
                if (progressTracker && sessionId) {
                    progressTracker.updateProgress(sessionId, 5, "Parsing CSV file...", { currentStep: 1 });
                }

                // Read and parse CSV
                const csvData = PathValidator.safeReadFileSync(filePath, "utf8");

                Papa.parse(csvData, {
                    header: true,
                    complete: (results) => {
                        const rows = results.data.filter(row => Object.values(row).some(val => val && val.trim()));

                        // Update progress: CSV parsing completed
                        if (progressTracker && sessionId) {
                            progressTracker.updateProgress(sessionId, 15, `Parsed ${rows.length} rows from CSV`, {
                                currentStep: 1,
                                rowCount: rows.length
                            });
                        }

                        _log("info", ` Parsed ${rows.length} rows from CSV`);

                        // Insert import record
                        const importQuery = `
                            INSERT INTO vulnerability_imports
                            (filename, import_date, row_count, vendor, file_size, processing_time, raw_headers)
                            VALUES (?, ?, ?, ?, ?, ?, ?)
                        `;

                        this.db.run(importQuery, [
                            filename,
                            new Date().toISOString(),
                            rows.length,
                            vendor,
                            fileSize,
                            0, // Will update after completion
                            JSON.stringify(results.meta.fields)
                        ], function(err) {
                            if (err) {
                                if (progressTracker && sessionId) {
                                    progressTracker.errorSession(sessionId, "Failed to create import record: " + err.message, { error: err });
                                }
                                return reject(new Error("Failed to create import record: " + err.message));
                            }

                            const importId = this.lastID;
                            _log("info", ` Import record created: ID ${importId}`);

                            // Update progress: Starting bulk load to staging
                            if (progressTracker && sessionId) {
                                progressTracker.updateProgress(sessionId, 20, "Loading data to staging table...", {
                                    currentStep: 2,
                                    importId: importId
                                });
                            }

                            // Bulk load to staging table
                            bulkLoadToStagingTable(rows, importId, finalScanDate, filePath, {
                                success: true,
                                importId,
                                filename,
                                vendor,
                                scanDate: finalScanDate,
                                stagingMode: true
                            }, sessionId, startTime, progressTracker);

                            // Return success immediately (processing continues asynchronously)
                            resolve({
                                success: true,
                                importId,
                                filename,
                                vendor,
                                scanDate: finalScanDate,
                                rowCount: rows.length,
                                stagingMode: true
                            });
                        });
                    },
                    error: (error) => {
                        if (progressTracker && sessionId) {
                            progressTracker.errorSession(sessionId, "CSV parsing failed: " + error.message, { error: error });
                        }
                        reject(new Error("CSV parsing failed: " + error.message));
                    }
                });
            } catch (error) {
                if (progressTracker && sessionId) {
                    progressTracker.errorSession(sessionId, "Import initialization failed: " + error.message, { error });
                }
                reject(error);
            }
        });
    }

    /**
     * Clear all vulnerability data
     * Extracted from server.js lines 2517-2531
     */
    async clearAllData() {
        return new Promise((resolve, reject) => {
            this.db.serialize(() => {
                this.db.run("DELETE FROM ticket_vulnerabilities");
                this.db.run("DELETE FROM vulnerability_snapshots");
                this.db.run("DELETE FROM vulnerabilities_current");
                this.db.run("DELETE FROM vulnerability_daily_totals");
                this.db.run("DELETE FROM vulnerabilities");  // Clear legacy table
                this.db.run("DELETE FROM vulnerability_staging");  // Clear staging table
                this.db.run("DELETE FROM vulnerability_imports", (err) => {
                    if (err) {
                        return reject(new Error("Failed to clear vulnerability data: " + err.message));
                    }

                    // Run VACUUM to reclaim disk space (112+ MB typically freed)
                    // VACUUM rebuilds the database file, removing free-list pages
                    this.db.run("VACUUM", (vacuumErr) => {
                        if (vacuumErr) {
                            _log("warn", "VACUUM failed after clear:", vacuumErr.message);
                            // Don't reject - clear was successful, VACUUM is optimization
                        } else {
                            _log("info", "Database compacted - disk space reclaimed");
                        }
                        resolve({ success: true, message: "All vulnerability data cleared from rollover architecture" });
                    });
                });
            });
        });
    }

    /**
     * Bulk delete vulnerabilities by IDs
     * HEX-112: Phase 2 endpoint for pagination migration
     * @param {Array<number>} ids - Array of vulnerability IDs to delete
     * @returns {Promise<Object>} Result with deleted count and success status
     */
    async bulkDelete(ids) {
        if (!Array.isArray(ids) || ids.length === 0) {
            throw new Error("IDs must be a non-empty array");
        }

        // Sanitize IDs to prevent SQL injection
        const sanitizedIds = ids.filter(id => Number.isInteger(Number(id))).map(Number);
        if (sanitizedIds.length === 0) {
            throw new Error("No valid IDs provided");
        }

        return new Promise((resolve, reject) => {
            const placeholders = sanitizedIds.map(() => "?").join(",");
            const queries = [
                // Delete from junction table first (foreign key constraint)
                {
                    sql: `DELETE FROM ticket_vulnerabilities WHERE vulnerability_id IN (${placeholders})`,
                    table: "ticket_vulnerabilities"
                },
                // Delete from current table
                {
                    sql: `DELETE FROM vulnerabilities_current WHERE id IN (${placeholders})`,
                    table: "vulnerabilities_current"
                },
                // Delete from legacy table for backwards compatibility
                {
                    sql: `DELETE FROM vulnerabilities WHERE id IN (${placeholders})`,
                    table: "vulnerabilities"
                }
                // Note: vulnerability_snapshots is not deleted as it's historical data
                // and doesn't have a direct FK to vulnerabilities table
            ];

            const deletedCounts = {};
            const db = this.db; // Capture database reference for callbacks

            db.serialize(() => {
                // Begin transaction for atomicity
                db.run("BEGIN TRANSACTION", (err) => {
                    if (err) {
                        return reject(new Error("Failed to start transaction: " + err.message));
                    }

                    // Execute each delete query
                    let completed = 0;
                    let hasError = false;

                    queries.forEach((query) => {
                        db.run(query.sql, sanitizedIds, function(err) {
                            if (hasError) {return;} // Skip if already errored

                            if (err) {
                                hasError = true;
                                db.run("ROLLBACK");
                                return reject(new Error(`Failed to delete from ${query.table}: ${err.message}`));
                            }

                            deletedCounts[query.table] = this.changes;
                            completed++;

                            // If all queries completed, commit transaction
                            if (completed === queries.length) {
                                db.run("COMMIT", (err) => {
                                    if (err) {
                                        db.run("ROLLBACK");
                                        return reject(new Error("Failed to commit transaction: " + err.message));
                                    }

                                    resolve({
                                        success: true,
                                        message: `Successfully deleted ${sanitizedIds.length} vulnerabilities`,
                                        requestedCount: ids.length,
                                        processedCount: sanitizedIds.length,
                                        deletedCounts: deletedCounts,
                                        totalDeleted: deletedCounts.vulnerabilities_current || 0
                                    });
                                });
                            }
                        });
                    });
                });
            });
        });
    }

    /**
     * Get count of vulnerabilities matching filters
     * HEX-112: Phase 2 endpoint for pagination migration
     * @param {Object} filters - Filter parameters (severity, vendor, search, isKev)
     * @returns {Promise<Object>} Count result with total and breakdown by severity
     */
    async getCount(filters = {}) {
        const { severity = "", vendor = "", search = "", isKev = false } = filters;

        return new Promise((resolve, reject) => {
            const whereConditions = [];
            const params = [];

            // Build WHERE clause based on filters
            if (severity) {
                whereConditions.push("UPPER(severity) = UPPER(?)");
                params.push(severity);
            }

            if (vendor) {
                whereConditions.push("UPPER(vendor) = UPPER(?)");
                params.push(vendor);
            }

            if (search) {
                // HEX-204: Expanded search to include all relevant fields (operating_system, solution_text, etc.)
                whereConditions.push(`(
                    hostname LIKE ? OR
                    ip_address LIKE ? OR
                    cve LIKE ? OR
                    plugin_name LIKE ? OR
                    description LIKE ? OR
                    solution_text LIKE ? OR
                    operating_system LIKE ? OR
                    vendor LIKE ? OR
                    vendor_reference LIKE ?
                )`);
                const searchPattern = `%${search}%`;
                // Push search pattern 9 times (once for each field)
                params.push(searchPattern, searchPattern, searchPattern, searchPattern, searchPattern, searchPattern, searchPattern, searchPattern, searchPattern);
            }

            if (isKev) {
                whereConditions.push(`
                    EXISTS (
                        SELECT 1 FROM kev_status k
                        WHERE k.cve_id = vulnerabilities_current.cve
                    )
                `);
            }

            const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(" AND ")}` : "";

            // Get total count
            const totalQuery = `SELECT COUNT(*) as total FROM vulnerabilities_current ${whereClause}`;

            // Get breakdown by severity
            const severityQuery = `
                SELECT
                    severity,
                    COUNT(*) as count
                FROM vulnerabilities_current
                ${whereClause}
                GROUP BY severity
            `;

            const result = {
                total: 0,
                breakdown: {
                    critical: 0,
                    high: 0,
                    medium: 0,
                    low: 0,
                    info: 0
                },
                filters: {
                    severity: severity || "all",
                    vendor: vendor || "all",
                    search: search || "",
                    isKev: isKev
                }
            };

            this.db.get(totalQuery, params, (err, row) => {
                if (err) {
                    return reject(new Error("Failed to get vulnerability count: " + err.message));
                }

                result.total = row?.total || 0;

                // Get severity breakdown
                this.db.all(severityQuery, params, (err, rows) => {
                    if (err) {
                        return reject(new Error("Failed to get severity breakdown: " + err.message));
                    }

                    // Process severity breakdown
                    rows.forEach(row => {
                        const sev = row.severity?.toLowerCase();
                        if (sev && result.breakdown.hasOwnProperty(sev)) {
                            result.breakdown[sev] = row.count;
                        }
                    });

                    resolve(result);
                });
            });
        });
    }

    /**
     * Get KEV-specific statistics
     * HEX-112: Phase 2 endpoint for pagination migration
     * @returns {Promise<Object>} KEV statistics (simplified without kev_catalog table)
     */
    async getKevStats() {
        return new Promise((resolve) => {
            // Since kev_catalog table doesn't exist yet, return placeholder stats
            // This endpoint will be updated when KEV functionality is fully implemented
            const result = {
                total: 0,
                bySeverity: {
                    critical: 0,
                    high: 0,
                    medium: 0,
                    low: 0
                },
                recentCount: 0,
                topDevices: [],
                status: "KEV catalog not yet initialized",
                message: "Run KEV sync to populate data"
            };

            // Check if we have any CVE data that could be KEVs (as a rough estimate)
            const cveQuery = `
                SELECT
                    COUNT(DISTINCT cve) as total_cves,
                    COUNT(CASE WHEN severity = 'Critical' THEN 1 END) as critical_cves
                FROM vulnerabilities_current
                WHERE cve IS NOT NULL AND cve != ''
            `;

            this.db.get(cveQuery, (err, row) => {
                if (!err && row) {
                    result.estimatedPotentialKevs = {
                        totalCves: row.total_cves || 0,
                        criticalCves: row.critical_cves || 0,
                        note: "These are CVE counts, not confirmed KEVs"
                    };
                }
                resolve(result);
            });
        });
    }

    /**
     * Get vendor distribution statistics
     * HEX-112: Phase 2 endpoint for pagination migration
     * @returns {Promise<Object>} Vendor statistics including counts and top vendors
     */
    async getVendorStats() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    vendor,
                    COUNT(*) as count,
                    AVG(vpr_score) as avg_vpr,
                    MAX(vpr_score) as max_vpr,
                    COUNT(DISTINCT hostname) as affected_devices
                FROM vulnerabilities_current
                WHERE vendor IS NOT NULL AND vendor != ''
                GROUP BY vendor
                ORDER BY count DESC
            `;

            this.db.all(query, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get vendor statistics: " + err.message));
                }

                const result = {
                    totalVendors: rows.length,
                    vendors: rows.slice(0, 20).map(row => ({
                        vendor: row.vendor,
                        count: row.count,
                        avgVpr: Math.round((row.avg_vpr || 0) * 10) / 10,
                        maxVpr: row.max_vpr || 0,
                        affectedDevices: row.affected_devices
                    })),
                    distribution: {}
                };

                // Calculate percentage distribution for top 5 vendors
                const total = rows.reduce((sum, row) => sum + row.count, 0);
                rows.slice(0, 5).forEach(row => {
                    result.distribution[row.vendor] = {
                        count: row.count,
                        percentage: Math.round((row.count / total) * 1000) / 10
                    };
                });

                // Add "Others" category
                const othersCount = rows.slice(5).reduce((sum, row) => sum + row.count, 0);
                if (othersCount > 0) {
                    result.distribution["Others"] = {
                        count: othersCount,
                        percentage: Math.round((othersCount / total) * 1000) / 10
                    };
                }

                resolve(result);
            });
        });
    }

    /**
     * Import vulnerabilities from web-based JSON data
     * Extracted from server.js lines 3501-3565
     */
    async importVulnerabilitiesWeb(csvData) {
        return new Promise((resolve, reject) => {
            const importDate = new Date().toISOString();
            let imported = 0;
            const errors = [];

            // Create import record
            const importQuery = `
                INSERT INTO vulnerability_imports
                (filename, import_date, row_count, vendor, file_size, processing_time, raw_headers)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `;

            this.db.run(importQuery, [
                "web-upload.csv",
                importDate,
                csvData.length,
                "web-import",
                0,
                0,
                JSON.stringify(Object.keys(csvData[0] || {}))
            ], function(err) {
                if (err) {
                    return reject(new Error("Failed to create import record: " + err.message));
                }

                const importId = this.lastID;

                // Process each row
                let processed = 0;

                function processNextRow() {
                    if (processed >= csvData.length) {
                        resolve({
                            imported,
                            errors,
                            total: csvData.length
                        });
                        return;
                    }

                    const row = csvData[processed];
                    processed++;

                    // Access server.js utility functions
                    const mapVulnerabilityRow = global.mapVulnerabilityRow;
                    if (!mapVulnerabilityRow) {
                        errors.push(`Row ${processed}: mapVulnerabilityRow function not available`);
                        processNextRow();
                        return;
                    }

                    try {
                        const mappedRows = mapVulnerabilityRow(row);
                        if (mappedRows && mappedRows.length > 0) {
                            // For simplicity, take the first mapped row
                            const mapped = mappedRows[0];

                            const sql = `INSERT OR REPLACE INTO vulnerabilities (
                                hostname, ip_address, cve, severity, vpr_score, cvss_score,
                                plugin_id, plugin_name, description, solution, vendor,
                                vulnerability_date, state, import_id, created_at
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

                            this.db.run(sql, [
                                mapped.hostname, mapped.ipAddress, mapped.cve, mapped.severity,
                                mapped.vprScore, mapped.cvssScore, mapped.pluginId, mapped.pluginName,
                                mapped.description, mapped.solution, mapped.vendor,
                                mapped.pluginPublished, mapped.state, importId,
                                new Date().toISOString()
                            ], function(insertErr) {
                                if (insertErr) {
                                    errors.push(`Row ${processed}: ${insertErr.message}`);
                                } else {
                                    imported++;
                                }
                                processNextRow();
                            });
                        } else {
                            errors.push(`Row ${processed}: No valid data after mapping`);
                            processNextRow();
                        }
                    } catch (mappingError) {
                        errors.push(`Row ${processed}: Mapping failed - ${mappingError.message}`);
                        processNextRow();
                    }
                }

                processNextRow();
            }.bind(this));
        });
    }

    /**
     * Update vulnerability lifecycle state
     * Helper method for lifecycle management
     */
    async updateLifecycleState(vulnerabilityId, newState, reason = null) {
        return new Promise((resolve, reject) => {
            const resolvedDate = (newState === "resolved") ? new Date().toISOString().split("T")[0] : null;

            const sql = `
                UPDATE vulnerabilities_current
                SET lifecycle_state = ?,
                    resolved_date = ?,
                    resolution_reason = ?
                WHERE id = ?
            `;

            this.db.run(sql, [newState, resolvedDate, reason, vulnerabilityId], function(err) {
                if (err) {
                    return reject(new Error("Failed to update lifecycle state: " + err.message));
                }
                resolve({ changes: this.changes });
            });
        });
    }

    /**
     * Get vulnerability by ID
     * Helper method for detailed operations
     */
    async getVulnerabilityById(id) {
        return new Promise((resolve, reject) => {
            this.db.get("SELECT * FROM vulnerabilities_current WHERE id = ?", [id], (err, row) => {
                if (err) {
                    return reject(new Error("Failed to fetch vulnerability: " + err.message));
                }
                resolve(row);
            });
        });
    }

    /**
     * Calculate vulnerability daily totals
     * Helper method for statistics rollup
     */
    async calculateDailyTotals(scanDate) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    severity,
                    COUNT(*) as count,
                    SUM(vpr_score) as total_vpr
                FROM vulnerabilities_current
                WHERE scan_date = ? AND lifecycle_state IN ('active', 'reopened')
                GROUP BY severity
            `;

            this.db.all(query, [scanDate], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to calculate daily totals: " + err.message));
                }

                const totals = {
                    scan_date: scanDate,
                    critical_count: 0,
                    critical_total_vpr: 0,
                    high_count: 0,
                    high_total_vpr: 0,
                    medium_count: 0,
                    medium_total_vpr: 0,
                    low_count: 0,
                    low_total_vpr: 0,
                    total_vulnerabilities: 0,
                    total_vpr: 0
                };

                rows.forEach(row => {
                    const severity = row.severity.toLowerCase();
                    const count = row.count || 0;
                    const totalVpr = row.total_vpr || 0;

                    if (severity === "critical") {
                        totals.critical_count = count;
                        totals.critical_total_vpr = totalVpr;
                    } else if (severity === "high") {
                        totals.high_count = count;
                        totals.high_total_vpr = totalVpr;
                    } else if (severity === "medium") {
                        totals.medium_count = count;
                        totals.medium_total_vpr = totalVpr;
                    } else if (severity === "low") {
                        totals.low_count = count;
                        totals.low_total_vpr = totalVpr;
                    }

                    totals.total_vulnerabilities += count;
                    totals.total_vpr += totalVpr;
                });

                resolve(totals);
            });
        });
    }

    /**
     * Get device statistics with aggregated vulnerability data
     * HEX-101 Blocking Issue #2: Server-side device aggregation
     *
     * Replaces client-side processDevices() which required loading all 30k vulnerabilities.
     * Pre-calculates device statistics server-side for efficient device card rendering.
     *
     * @returns {Promise<Array>} Array of device statistics objects
     * @since v1.0.42
     * @module VulnerabilityService
     *
     * @example
     * const devices = await vulnerabilityService.getDeviceStatistics();
     * // Returns: [{ hostname, totalVulnerabilities, totalVpr, severityCounts, hasKev }, ...]
     */
    async getDeviceStatistics() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    v.hostname,
                    COUNT(*) as totalVulnerabilities,
                    ROUND(SUM(v.vpr_score), 2) as totalVpr,
                    SUM(CASE WHEN v.severity = 'Critical' THEN 1 ELSE 0 END) as criticalCount,
                    SUM(CASE WHEN v.severity = 'High' THEN 1 ELSE 0 END) as highCount,
                    SUM(CASE WHEN v.severity = 'Medium' THEN 1 ELSE 0 END) as mediumCount,
                    SUM(CASE WHEN v.severity = 'Low' THEN 1 ELSE 0 END) as lowCount,
                    ROUND(SUM(CASE WHEN v.severity = 'Critical' THEN v.vpr_score ELSE 0 END), 2) as criticalVpr,
                    ROUND(SUM(CASE WHEN v.severity = 'High' THEN v.vpr_score ELSE 0 END), 2) as highVpr,
                    ROUND(SUM(CASE WHEN v.severity = 'Medium' THEN v.vpr_score ELSE 0 END), 2) as mediumVpr,
                    ROUND(SUM(CASE WHEN v.severity = 'Low' THEN v.vpr_score ELSE 0 END), 2) as lowVpr,
                    MAX(CASE WHEN k.cve_id IS NOT NULL THEN 1 ELSE 0 END) as hasKev
                FROM vulnerabilities_current v
                LEFT JOIN kev_status k ON v.cve = k.cve_id
                WHERE v.lifecycle_state IN ('active', 'reopened')
                GROUP BY v.hostname
                ORDER BY totalVpr DESC, totalVulnerabilities DESC
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch device statistics: " + err.message));
                }

                // HEX-120 Fix: Transform rows into frontend-compatible format
                // Match the structure expected by vulnerability-cards.js and device-security-modal.js
                const devices = rows.map(row => ({
                    hostname: row.hostname,
                    totalCount: row.totalVulnerabilities,  // Frontend expects totalCount
                    totalVPR: row.totalVpr,                // Frontend expects totalVPR (uppercase)
                    criticalCount: row.criticalCount,      // Flat structure, not nested
                    highCount: row.highCount,
                    mediumCount: row.mediumCount,
                    lowCount: row.lowCount,
                    criticalVPR: row.criticalVpr || 0,     // VPR scores by severity
                    highVPR: row.highVpr || 0,
                    mediumVPR: row.mediumVpr || 0,
                    lowVPR: row.lowVpr || 0,
                    vulnerabilities: [],  // Empty for now - modal will need to fetch separately
                    hasKev: row.hasKev === 1
                }));

                resolve(devices);
            });
        });
    }

    /**
     * Get top affected devices by vulnerability count
     * HEX-112 Phase 2: Service method for dashboard charts
     * @param {number} limit - Maximum number of devices to return
     * @returns {Promise<Array>} Top affected devices with counts
     */
    async getTopAffectedDevices(limit = 10) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    hostname,
                    COUNT(*) as vulnerabilityCount,
                    SUM(vpr_score) as totalVpr,
                    SUM(CASE WHEN severity = 'Critical' THEN 1 ELSE 0 END) as criticalCount,
                    SUM(CASE WHEN severity = 'High' THEN 1 ELSE 0 END) as highCount,
                    SUM(CASE WHEN severity = 'Medium' THEN 1 ELSE 0 END) as mediumCount,
                    SUM(CASE WHEN severity = 'Low' THEN 1 ELSE 0 END) as lowCount
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY hostname
                ORDER BY vulnerabilityCount DESC
                LIMIT ?
            `;

            this.db.all(query, [limit], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch top devices: " + err.message));
                }
                resolve(rows || []);
            });
        });
    }

    /**
     * Get CVSS score distribution
     * HEX-112 Phase 2: Service method for dashboard charts
     * @returns {Promise<Object>} CVSS score buckets with counts
     */
    async getCvssDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    CASE
                        WHEN cvss_base_score >= 9.0 THEN 'Critical (9.0-10.0)'
                        WHEN cvss_base_score >= 7.0 THEN 'High (7.0-8.9)'
                        WHEN cvss_base_score >= 4.0 THEN 'Medium (4.0-6.9)'
                        WHEN cvss_base_score >= 0.1 THEN 'Low (0.1-3.9)'
                        ELSE 'None (0.0)'
                    END as range,
                    COUNT(*) as count,
                    AVG(cvss_base_score) as avgScore
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY range
                ORDER BY
                    CASE range
                        WHEN 'Critical (9.0-10.0)' THEN 1
                        WHEN 'High (7.0-8.9)' THEN 2
                        WHEN 'Medium (4.0-6.9)' THEN 3
                        WHEN 'Low (0.1-3.9)' THEN 4
                        WHEN 'None (0.0)' THEN 5
                    END
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch CVSS distribution: " + err.message));
                }

                // Transform to object format
                const distribution = {
                    ranges: [],
                    counts: [],
                    totalVulnerabilities: 0
                };

                rows.forEach(row => {
                    distribution.ranges.push(row.range);
                    distribution.counts.push(row.count);
                    distribution.totalVulnerabilities += row.count;
                });

                resolve(distribution);
            });
        });
    }

    /**
     * Get severity distribution
     * HEX-112 Phase 2: Service method for dashboard charts
     * @returns {Promise<Array>} Severity counts and percentages
     */
    async getSeverityDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    severity,
                    COUNT(*) as count,
                    SUM(vpr_score) as totalVpr,
                    AVG(vpr_score) as avgVpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY severity
                ORDER BY
                    CASE severity
                        WHEN 'Critical' THEN 1
                        WHEN 'High' THEN 2
                        WHEN 'Medium' THEN 3
                        WHEN 'Low' THEN 4
                        ELSE 5
                    END
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch severity distribution: " + err.message));
                }

                // Calculate total for percentages
                const total = rows.reduce((sum, row) => sum + row.count, 0);

                // Add percentage to each row
                const distribution = rows.map(row => ({
                    ...row,
                    percentage: total > 0 ? ((row.count / total) * 100).toFixed(1) : 0
                }));

                resolve(distribution);
            });
        });
    }

    /**
     * Get recent vulnerabilities
     * HEX-112 Phase 2: Service method for activity feed
     * @param {number} limit - Maximum number of vulnerabilities to return
     * @returns {Promise<Array>} Recent vulnerabilities
     */
    async getRecentVulnerabilities(limit = 10) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    id, hostname, cve, plugin_name, severity,
                    cvss_base_score, vpr_score, scan_date,
                    first_seen, last_seen
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                ORDER BY scan_date DESC, id DESC
                LIMIT ?
            `;

            this.db.all(query, [limit], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch recent vulnerabilities: " + err.message));
                }
                resolve(rows || []);
            });
        });
    }

    /**
     * Stream export data for large datasets
     * HEX-112 Phase 2: Streaming export to handle large data without memory issues
     * @param {Object} res - Express response object for streaming
     * @param {string} format - Export format (csv or json)
     * @param {Object} filters - Filter criteria
     */
    async streamExport(res, format, filters) {
        return new Promise((resolve, reject) => {
            let isComplete = false;

            // Handle stream errors (client disconnect, etc.)
            res.on("error", (err) => {
                _log("error", "Response stream error:", err);
                if (!isComplete) {
                    isComplete = true;
                    reject(err);
                }
            });

            res.on("close", () => {
                if (!isComplete) {
                    _log("info", "Client disconnected during export");
                    // Don't reject on normal close, just log
                }
            });

            // Build query with filters
            const whereConditions = ["lifecycle_state IN ('active', 'reopened')"];
            const params = [];

            if (filters.severity) {
                whereConditions.push("severity = ?");
                params.push(filters.severity);
            }
            if (filters.vendor) {
                whereConditions.push("UPPER(vendor) = UPPER(?)");
                params.push(filters.vendor);
            }
            if (filters.search) {
                whereConditions.push("(cve LIKE ? OR plugin_name LIKE ? OR hostname LIKE ?)");
                const searchTerm = `%${filters.search}%`;
                params.push(searchTerm, searchTerm, searchTerm);
            }
            if (filters.isKev) {
                whereConditions.push("id IN (SELECT v.id FROM vulnerabilities_current v LEFT JOIN kev_status k ON v.cve = k.cve_id WHERE k.cve_id IS NOT NULL)");
            }

            const query = `
                SELECT * FROM vulnerabilities_current
                WHERE ${whereConditions.join(" AND ")}
                ORDER BY scan_date DESC, severity ASC
            `;

            // Start CSV header if format is CSV
            if (format === "csv") {
                res.write("ID,Hostname,CVE,Plugin Name,Severity,CVSS Score,VPR Score,Scan Date,First Seen,Last Seen,Vendor\n");
            } else {
                res.write("{\"vulnerabilities\":[");
            }

            let firstRow = true;
            let rowCount = 0;

            // Use each() for streaming row-by-row processing
            this.db.each(query, params,
                (err, row) => {
                    if (err) {
                        _log("error", "Error streaming row:", err);
                        if (!res.headersSent) {
                            res.status(500).json({
                                success: false,
                                error: "Database error during export",
                                details: err.message
                            });
                        }
                        return reject(err);
                    }

                    rowCount++;

                    if (format === "csv") {
                        // HEX-117: CSV injection protection using module-level helpers
                        // Write CSV row with proper escaping
                        res.write(`"${escapeCSV(safeCSV(row.id))}","${escapeCSV(safeCSV(row.hostname))}","${escapeCSV(safeCSV(row.cve || ""))}","${escapeCSV(safeCSV(row.plugin_name))}","${escapeCSV(safeCSV(row.severity))}",${row.cvss_base_score || 0},${row.vpr_score || 0},"${escapeCSV(safeCSV(row.scan_date))}","${escapeCSV(safeCSV(row.first_seen || ""))}","${escapeCSV(safeCSV(row.last_seen || ""))}","${escapeCSV(safeCSV(row.vendor || ""))}"\n`);
                    } else {
                        // Write JSON row
                        if (!firstRow) {res.write(",");}
                        res.write(JSON.stringify(row));
                        firstRow = false;
                    }
                },
                (err, _count) => {
                    // Completion callback
                    if (err) {
                        isComplete = true;
                        return reject(err);
                    }

                    // Close JSON array if format is JSON
                    if (format === "json") {
                        res.write("],\"total\":" + rowCount + "}");
                    }

                    res.end();
                    isComplete = true;
                    resolve({ exported: rowCount });
                }
            );
        });
    }
}

module.exports = VulnerabilityService;