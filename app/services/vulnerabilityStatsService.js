/**
 * VulnerabilityStatsService - Vulnerability statistics and analytics business logic
 * Extracted from server.js lines: 1996-2016, 2019-2092, 2095-2156, 1719-1798
 *
 * This service handles all statistical calculations and analytics for vulnerabilities:
 * - Current vulnerability statistics with VPR totals and distribution
 * - Recent trends comparison for dashboard cards (current vs previous day)
 * - Historical trending data with date range filtering
 * - Daily totals calculation and rollup operations
 * - Enhanced lifecycle state tracking (active, resolved, reopened)
 * - VPR score aggregations and severity-based metrics
 *
 * Separated from vulnerabilityService due to complexity and distinct concerns:
 * - vulnerabilityService: CRUD, import, data management
 * - vulnerabilityStatsService: Analytics, trends, statistics, rollups
 *
 * T053 INTEGRATION NOTES:
 * This service requires database initialization and works with vulnerability_daily_totals table.
 * Complex statistical calculations are isolated here for maintainability.
 */

class VulnerabilityStatsService {
    constructor() {
        this.db = null;
    }

    /**
     * Initialize service with database connection
     * @param {sqlite3.Database} database - Database connection from server.js
     */
    initialize(database) {
        this.db = database;
    }

    /**
     * Get vulnerability statistics with VPR totals
     * Enhanced to fall back to daily totals when no active vulnerabilities exist
     * HEX-156: Added vendor filtering support
     * Extracted from server.js lines 1996-2016
     * @param {string|null} vendor - Optional vendor filter (CISCO, Palo Alto, Other, or null for all)
     */
    async getStats(vendor = null) {
        return new Promise((resolve, reject) => {
            // Add vendor filtering to WHERE clause
            // Database has pre-normalized vendor column from import process
            const vendorFilter = vendor ? "AND vendor = ?" : "";

            // Query latest snapshot for consistency with trends chart
            // Use vulnerability_snapshots to get historical totals, not current active state
            const query = `
                SELECT
                  severity,
                  COUNT(*) as count,
                  SUM(max_vpr) as total_vpr,
                  AVG(max_vpr) as avg_vpr,
                  MIN(earliest) as earliest,
                  MAX(latest) as latest
                FROM (
                    SELECT
                      severity,
                      hostname,
                      COALESCE(plugin_id, SUBSTR(description, 1, 100)) as dedup_key,
                      MAX(vpr_score) as max_vpr,
                      MIN(COALESCE(first_seen, scan_date)) as earliest,
                      MAX(COALESCE(last_seen, scan_date)) as latest
                    FROM vulnerability_snapshots
                    WHERE scan_date = (SELECT MAX(scan_date) FROM vulnerability_snapshots)
                    ${vendorFilter}
                    GROUP BY severity, hostname, dedup_key
                )
                GROUP BY severity
            `;

            // Single vendor parameter for column equality check
            const params = vendor ? [vendor] : [];

            this.db.all(query, params, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch vulnerability statistics: " + err.message));
                }

                // If no active vulnerabilities found, fall back to most recent daily totals
                if (!rows || rows.length === 0) {
                    console.log("No active vulnerabilities found, falling back to most recent daily totals");
                    this._getStatsFromDailyTotals()
                        .then(fallbackStats => resolve(fallbackStats))
                        .catch(fallbackErr => {
                            console.warn("Failed to get fallback stats from daily totals:", fallbackErr.message);
                            resolve([]); // Return empty array as final fallback
                        });
                } else {
                    resolve(rows);
                }
            });
        });
    }

    /**
     * Get statistics from the most recent daily totals when no active vulnerabilities exist
     * Provides fallback data for VPR cards after rollback operations
     * @returns {Promise<Array>} Stats array in same format as getStats()
     */
    async _getStatsFromDailyTotals() {
        return new Promise((resolve, reject) => {
            // Get the most recent daily totals entry
            const fallbackQuery = `
                SELECT
                    scan_date,
                    critical_count, critical_total_vpr,
                    high_count, high_total_vpr,
                    medium_count, medium_total_vpr,
                    low_count, low_total_vpr
                FROM vulnerability_daily_totals
                ORDER BY scan_date DESC
                LIMIT 1
            `;

            this.db.get(fallbackQuery, [], (err, row) => {
                if (err) {
                    return reject(new Error("Failed to fetch fallback daily totals: " + err.message));
                }

                if (!row) {
                    console.log("No daily totals available for fallback");
                    return resolve([]);
                }

                console.log(` Using daily totals fallback from ${row.scan_date}`);

                // Convert daily totals format to stats format (matching getStats() output)
                const fallbackStats = [];

                if (row.critical_count > 0) {
                    fallbackStats.push({
                        severity: "Critical",
                        count: row.critical_count,
                        total_vpr: row.critical_total_vpr,
                        avg_vpr: row.critical_total_vpr / row.critical_count,
                        earliest: row.scan_date,
                        latest: row.scan_date
                    });
                }

                if (row.high_count > 0) {
                    fallbackStats.push({
                        severity: "High",
                        count: row.high_count,
                        total_vpr: row.high_total_vpr,
                        avg_vpr: row.high_total_vpr / row.high_count,
                        earliest: row.scan_date,
                        latest: row.scan_date
                    });
                }

                if (row.medium_count > 0) {
                    fallbackStats.push({
                        severity: "Medium",
                        count: row.medium_count,
                        total_vpr: row.medium_total_vpr,
                        avg_vpr: row.medium_total_vpr / row.medium_count,
                        earliest: row.scan_date,
                        latest: row.scan_date
                    });
                }

                if (row.low_count > 0) {
                    fallbackStats.push({
                        severity: "Low",
                        count: row.low_count,
                        total_vpr: row.low_total_vpr,
                        avg_vpr: row.low_total_vpr / row.low_count,
                        earliest: row.scan_date,
                        latest: row.scan_date
                    });
                }

                resolve(fallbackStats);
            });
        });
    }

    /**
     * Get recent vulnerability statistics with trend comparison (for dashboard cards)
     * Extracted from server.js lines 2019-2092
     */
    async getRecentTrends() {
        return new Promise((resolve, reject) => {
            // Get previous data from vulnerability_daily_totals (most recent vs previous day)
            const previousQuery = `
                SELECT
                  scan_date,
                  critical_count as critical_count, critical_total_vpr as critical_total_vpr,
                  high_count as high_count, high_total_vpr as high_total_vpr,
                  medium_count as medium_count, medium_total_vpr as medium_total_vpr,
                  low_count as low_count, low_total_vpr as low_total_vpr
                FROM vulnerability_daily_totals
                ORDER BY scan_date DESC
                LIMIT 2
            `;

            this.db.all(previousQuery, [], (err, dailyTotalsRows) => {
                if (err) {
                    return reject(new Error("Failed to fetch recent trends: " + err.message));
                }

                // Calculate trends
                const trends = {};

                // If we have daily totals history, use it for comparison
                let currentData = {};
                let previousData = {};

                if (dailyTotalsRows.length >= 1) {
                    // Use the most recent daily total as "current"
                    const currentRow = dailyTotalsRows[0];
                    currentData = {
                        "Critical": { count: currentRow.critical_count || 0, total_vpr: currentRow.critical_total_vpr || 0 },
                        "High": { count: currentRow.high_count || 0, total_vpr: currentRow.high_total_vpr || 0 },
                        "Medium": { count: currentRow.medium_count || 0, total_vpr: currentRow.medium_total_vpr || 0 },
                        "Low": { count: currentRow.low_count || 0, total_vpr: currentRow.low_total_vpr || 0 }
                    };
                }

                if (dailyTotalsRows.length >= 2) {
                    // Use the second most recent daily total (previousData)
                    const prevRow = dailyTotalsRows[1];
                    previousData = {
                        "Critical": { count: prevRow.critical_count || 0, total_vpr: prevRow.critical_total_vpr || 0 },
                        "High": { count: prevRow.high_count || 0, total_vpr: prevRow.high_total_vpr || 0 },
                        "Medium": { count: prevRow.medium_count || 0, total_vpr: prevRow.medium_total_vpr || 0 },
                        "Low": { count: prevRow.low_count || 0, total_vpr: prevRow.low_total_vpr || 0 }
                    };
                } else if (dailyTotalsRows.length === 1) {
                    // First day of data, compare to zero
                    previousData = {
                        "Critical": { count: 0, total_vpr: 0 },
                        "High": { count: 0, total_vpr: 0 },
                        "Medium": { count: 0, total_vpr: 0 },
                        "Low": { count: 0, total_vpr: 0 }
                    };
                }

                // Build trends for each severity
                Object.keys(currentData).forEach(severity => {
                    const current = currentData[severity];
                    const prev = previousData[severity] || { count: 0, total_vpr: 0 };
                    const currentVpr = Math.round((current.total_vpr || 0) * 100) / 100;
                    trends[severity] = {
                        current: { count: current.count, total_vpr: currentVpr },
                        trend: {
                            count_change: current.count - prev.count,
                            vpr_change: Math.round((currentVpr - prev.total_vpr) * 100) / 100
                        }
                    };
                });

                resolve(trends);
            });
        });
    }

    /**
     * Get historical trending data with optional date range filtering and vendor filtering
     * Extracted from server.js lines 2095-2156
     * HEX-156: Added vendor parameter for vendor-specific trends
     * @param {string|null} startDate - Optional start date filter (YYYY-MM-DD)
     * @param {string|null} endDate - Optional end date filter (YYYY-MM-DD)
     * @param {string|null} vendor - Optional vendor filter (CISCO, Palo Alto, Other)
     * @returns {Promise<Array>} Trend data formatted for ApexCharts
     */
    async getTrends(startDate = null, endDate = null, vendor = null) {
        return new Promise((resolve, reject) => {
            // If vendor specified, aggregate from raw vulnerabilities_current
            // instead of using pre-aggregated vulnerability_daily_totals
            if (vendor) {
                // Database has pre-normalized vendor column from import process
                const vendorFilter = "vendor = ?";

                let dateFilter = "";
                const params = [vendor];

                if (startDate && endDate) {
                    dateFilter = "AND scan_date >= ? AND scan_date <= ?";
                    params.push(startDate, endDate);
                } else if (startDate) {
                    dateFilter = "AND scan_date >= ?";
                    params.push(startDate);
                } else if (endDate) {
                    dateFilter = "AND scan_date <= ?";
                    params.push(endDate);
                }

                // Query vendor_daily_totals (permanent historical data, never cleaned up)
                const query = `
                    SELECT
                      scan_date as date,
                      critical_count,
                      critical_total_vpr,
                      high_count,
                      high_total_vpr,
                      medium_count,
                      medium_total_vpr,
                      low_count,
                      low_total_vpr,
                      total_vulnerabilities,
                      total_vpr
                    FROM vendor_daily_totals
                    WHERE ${vendorFilter}
                    ${dateFilter}
                    ORDER BY scan_date ASC
                `;

                this.db.all(query, params, (err, rows) => {
                    if (err) {
                        return reject(new Error("Failed to fetch vendor trends: " + err.message));
                    }

                    // Format data for ApexCharts (same structure as "All Vendors" path)
                    const trends = rows.map(row => ({
                        date: row.date,
                        Critical: {
                            count: row.critical_count || 0,
                            total_vpr: Math.round((row.critical_total_vpr || 0) * 100) / 100
                        },
                        High: {
                            count: row.high_count || 0,
                            total_vpr: Math.round((row.high_total_vpr || 0) * 100) / 100
                        },
                        Medium: {
                            count: row.medium_count || 0,
                            total_vpr: Math.round((row.medium_total_vpr || 0) * 100) / 100
                        },
                        Low: {
                            count: row.low_count || 0,
                            total_vpr: Math.round((row.low_total_vpr || 0) * 100) / 100
                        }
                    }));

                    resolve(trends);
                });
            } else {
                // Original logic for "All Vendors" (use pre-aggregated table)
                let whereClause = "";
                let params = [];

                if (startDate && endDate) {
                    whereClause = "WHERE scan_date >= ? AND scan_date <= ?";
                    params = [startDate, endDate];
                } else if (startDate) {
                    whereClause = "WHERE scan_date >= ?";
                    params = [startDate];
                } else if (endDate) {
                    whereClause = "WHERE scan_date <= ?";
                    params = [endDate];
                }
                // No WHERE clause = return all data for ApexCharts to handle filtering

                const query = `
                    SELECT
                      scan_date as date,
                      critical_count, critical_total_vpr,
                      high_count, high_total_vpr,
                      medium_count, medium_total_vpr,
                      low_count, low_total_vpr,
                      total_vulnerabilities, total_vpr
                    FROM vulnerability_daily_totals
                    ${whereClause}
                    ORDER BY scan_date ASC
                `;

                this.db.all(query, params, (err, rows) => {
                    if (err) {
                        return reject(new Error("Failed to fetch trends: " + err.message));
                    }

                    // Format data for chart consumption
                    const trends = rows.map(row => ({
                        date: row.date,
                        Critical: {
                            count: row.critical_count,
                            total_vpr: Math.round((row.critical_total_vpr || 0) * 100) / 100
                        },
                        High: {
                            count: row.high_count,
                            total_vpr: Math.round((row.high_total_vpr || 0) * 100) / 100
                        },
                        Medium: {
                            count: row.medium_count,
                            total_vpr: Math.round((row.medium_total_vpr || 0) * 100) / 100
                        },
                        Low: {
                            count: row.low_count,
                            total_vpr: Math.round((row.low_total_vpr || 0) * 100) / 100
                        }
                    }));

                    resolve(trends);
                });
            }
        });
    }

    /**
     * Calculate and store enhanced daily totals with lifecycle states
     * Extracted from server.js lines 1719-1798
     */
    async calculateAndStoreDailyTotalsEnhanced(scanDate) {
        return new Promise((resolve, reject) => {
            // Calculate totals with deduplicated VPR to avoid multi-CVE inflation
            // Group by hostname + plugin_id (or hostname + description) for unique vulnerabilities
            const totalsQuery = `
                SELECT
                    severity,
                    SUM(vuln_count) as count,
                    SUM(max_vpr) as total_vpr,
                    SUM(reopened_count) as reopened_count
                FROM (
                    SELECT
                        severity,
                        hostname,
                        COALESCE(plugin_id, SUBSTR(description, 1, 100)) as dedup_key,
                        COUNT(*) as vuln_count,
                        MAX(vpr_score) as max_vpr,
                        MAX(CASE WHEN lifecycle_state = 'reopened' THEN 1 ELSE 0 END) as reopened_count
                    FROM vulnerabilities_current
                    WHERE scan_date = ? AND lifecycle_state IN ('active', 'reopened')
                    GROUP BY severity, hostname, dedup_key
                )
                GROUP BY severity
            `;

            this.db.all(totalsQuery, [scanDate], (err, results) => {
                if (err) {
                    return reject(new Error("Error calculating enhanced daily totals: " + err.message));
                }

                // Get resolved count for the day
                this.db.get("SELECT COUNT(*) as resolved_count FROM vulnerabilities_current WHERE resolved_date = ?",
                    [scanDate], (err, resolvedResult) => {
                        if (err) {
                            return reject(new Error("Error getting resolved count: " + err.message));
                        }

                        const resolvedCount = resolvedResult ? resolvedResult.resolved_count : 0;

                        const totals = {
                            critical_count: 0, critical_total_vpr: 0,
                            high_count: 0, high_total_vpr: 0,
                            medium_count: 0, medium_total_vpr: 0,
                            low_count: 0, low_total_vpr: 0,
                            total_vulnerabilities: 0, total_vpr: 0,
                            resolved_count: resolvedCount,
                            reopened_count: 0
                        };

                        results.forEach(row => {
                            const severity = row.severity.toLowerCase();
                            if (severity === "critical") {
                                totals.critical_count = row.count;
                                totals.critical_total_vpr = row.total_vpr;
                            } else if (severity === "high") {
                                totals.high_count = row.count;
                                totals.high_total_vpr = row.total_vpr;
                            } else if (severity === "medium") {
                                totals.medium_count = row.count;
                                totals.medium_total_vpr = row.total_vpr;
                            } else if (severity === "low") {
                                totals.low_count = row.count;
                                totals.low_total_vpr = row.total_vpr;
                            }
                            totals.total_vulnerabilities += row.count;
                            totals.total_vpr += row.total_vpr;
                            totals.reopened_count += row.reopened_count || 0;
                        });

                        // Store enhanced daily totals
                        const storeQuery = `INSERT OR REPLACE INTO vulnerability_daily_totals
                            (scan_date, critical_count, critical_total_vpr, high_count, high_total_vpr,
                             medium_count, medium_total_vpr, low_count, low_total_vpr,
                             total_vulnerabilities, total_vpr, resolved_count, reopened_count)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

                        this.db.run(storeQuery, [
                            scanDate,
                            totals.critical_count, totals.critical_total_vpr,
                            totals.high_count, totals.high_total_vpr,
                            totals.medium_count, totals.medium_total_vpr,
                            totals.low_count, totals.low_total_vpr,
                            totals.total_vulnerabilities, totals.total_vpr,
                            totals.resolved_count, totals.reopened_count
                        ], (err) => {
                            if (err) {
                                return reject(new Error("Error storing enhanced daily totals: " + err.message));
                            }

                            console.log(`Enhanced daily totals updated for ${scanDate}`);
                            resolve(totals);
                        });
                    });
            });
        });
    }

    /**
     * Get vulnerability distribution by severity
     * Helper method for analytics
     */
    async getVulnerabilityDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    severity,
                    COUNT(*) as count,
                    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM vulnerabilities_current WHERE lifecycle_state IN ('active', 'reopened')), 2) as percentage
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY severity
                ORDER BY
                    CASE severity
                        WHEN 'Critical' THEN 1
                        WHEN 'High' THEN 2
                        WHEN 'Medium' THEN 3
                        WHEN 'Low' THEN 4
                        ELSE 5
                    END
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get vulnerability distribution: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get top vulnerable hosts by VPR score
     * Helper method for analytics
     */
    async getTopVulnerableHosts(limit = 10) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    hostname,
                    ip_address,
                    COUNT(*) as vulnerability_count,
                    SUM(vpr_score) as total_vpr,
                    AVG(vpr_score) as avg_vpr,
                    MAX(vpr_score) as max_vpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY hostname, ip_address
                ORDER BY total_vpr DESC
                LIMIT ?
            `;

            this.db.all(query, [limit], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get top vulnerable hosts: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get VPR score distribution statistics
     * Helper method for analytics
     */
    async getVprScoreDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    CASE
                        WHEN vpr_score >= 9.0 THEN 'Extreme (9.0-10.0)'
                        WHEN vpr_score >= 7.0 THEN 'High (7.0-8.9)'
                        WHEN vpr_score >= 4.0 THEN 'Medium (4.0-6.9)'
                        WHEN vpr_score >= 1.0 THEN 'Low (1.0-3.9)'
                        ELSE 'Minimal (0.0-0.9)'
                    END as vpr_range,
                    COUNT(*) as count,
                    ROUND(AVG(vpr_score), 2) as avg_vpr_in_range,
                    MIN(vpr_score) as min_vpr,
                    MAX(vpr_score) as max_vpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened') AND vpr_score IS NOT NULL
                GROUP BY
                    CASE
                        WHEN vpr_score >= 9.0 THEN 'Extreme (9.0-10.0)'
                        WHEN vpr_score >= 7.0 THEN 'High (7.0-8.9)'
                        WHEN vpr_score >= 4.0 THEN 'Medium (4.0-6.9)'
                        WHEN vpr_score >= 1.0 THEN 'Low (1.0-3.9)'
                        ELSE 'Minimal (0.0-0.9)'
                    END
                ORDER BY min_vpr DESC
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get VPR score distribution: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get vulnerability aging metrics
     * Helper method for analytics
     */
    async getVulnerabilityAging() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    CASE
                        WHEN julianday('now') - julianday(first_seen) <= 7 THEN 'New (≤7 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 30 THEN 'Recent (8-30 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 90 THEN 'Aging (31-90 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 365 THEN 'Old (91-365 days)'
                        ELSE 'Legacy (>365 days)'
                    END as age_category,
                    COUNT(*) as count,
                    ROUND(AVG(julianday('now') - julianday(first_seen)), 1) as avg_days_old,
                    ROUND(AVG(vpr_score), 2) as avg_vpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened') AND first_seen IS NOT NULL
                GROUP BY
                    CASE
                        WHEN julianday('now') - julianday(first_seen) <= 7 THEN 'New (≤7 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 30 THEN 'Recent (8-30 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 90 THEN 'Aging (31-90 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 365 THEN 'Old (91-365 days)'
                        ELSE 'Legacy (>365 days)'
                    END
                ORDER BY avg_days_old ASC
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get vulnerability aging metrics: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get daily totals for a specific date range
     * Helper method for custom analytics
     */
    async getDailyTotalsRange(startDate, endDate) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT *
                FROM vulnerability_daily_totals
                WHERE scan_date >= ? AND scan_date <= ?
                ORDER BY scan_date ASC
            `;

            this.db.all(query, [startDate, endDate], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get daily totals range: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get the most recent import date from vulnerability_daily_totals
     * Used by settings modal to display last CSV import date (HEX-240)
     * @returns {Promise<Object>} Object with lastImport date or null
     */
    async getLastImportDate() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT scan_date
                FROM vulnerability_daily_totals
                ORDER BY scan_date DESC
                LIMIT 1
            `;

            this.db.get(query, [], (err, row) => {
                if (err) {
                    return reject(new Error("Failed to fetch last import date: " + err.message));
                }
                resolve({ lastImport: row ? row.scan_date : null });
            });
        });
    }
}

module.exports = VulnerabilityStatsService;