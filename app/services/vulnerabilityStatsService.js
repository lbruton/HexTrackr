/**
 * VulnerabilityStatsService - Vulnerability statistics and analytics business logic
 * Extracted from server.js lines: 1996-2016, 2019-2092, 2095-2156, 1719-1798
 *
 * This service handles all statistical calculations and analytics for vulnerabilities:
 * - Current vulnerability statistics with VPR totals and distribution
 * - Recent trends comparison for dashboard cards (current vs previous day)
 * - Historical trending data with date range filtering
 * - Daily totals calculation and rollup operations
 * - Enhanced lifecycle state tracking (active, resolved, reopened)
 * - VPR score aggregations and severity-based metrics
 *
 * Separated from vulnerabilityService due to complexity and distinct concerns:
 * - vulnerabilityService: CRUD, import, data management
 * - vulnerabilityStatsService: Analytics, trends, statistics, rollups
 *
 * T053 INTEGRATION NOTES:
 * This service requires database initialization and works with vulnerability_daily_totals table.
 * Complex statistical calculations are isolated here for maintainability.
 */

class VulnerabilityStatsService {
    constructor() {
        this.db = null;
    }

    /**
     * Initialize service with database connection
     * @param {sqlite3.Database} database - Database connection from server.js
     */
    initialize(database) {
        this.db = database;
    }

    /**
     * Get vulnerability statistics with VPR totals
     * Extracted from server.js lines 1996-2016
     */
    async getStats() {
        return new Promise((resolve, reject) => {
            // Use deduplicated VPR aggregation to avoid counting multi-CVE vulnerabilities multiple times
            // Group by hostname + plugin_id (or hostname + description) to identify unique vulnerabilities
            const query = `
                SELECT
                  severity,
                  COUNT(*) as count,
                  SUM(max_vpr) as total_vpr,
                  AVG(max_vpr) as avg_vpr,
                  MIN(earliest) as earliest,
                  MAX(latest) as latest
                FROM (
                    SELECT
                      severity,
                      hostname,
                      COALESCE(plugin_id, SUBSTR(description, 1, 100)) as dedup_key,
                      MAX(vpr_score) as max_vpr,
                      MIN(COALESCE(first_seen, scan_date)) as earliest,
                      MAX(COALESCE(last_seen, scan_date)) as latest
                    FROM vulnerabilities_current
                    WHERE lifecycle_state IN ('active', 'reopened')
                    GROUP BY severity, hostname, dedup_key
                )
                GROUP BY severity
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch vulnerability statistics: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get recent vulnerability statistics with trend comparison (for dashboard cards)
     * Extracted from server.js lines 2019-2092
     */
    async getRecentTrends() {
        return new Promise((resolve, reject) => {
            // Get previous data from vulnerability_daily_totals (most recent vs previous day)
            const previousQuery = `
                SELECT
                  scan_date,
                  critical_count as critical_count, critical_total_vpr as critical_total_vpr,
                  high_count as high_count, high_total_vpr as high_total_vpr,
                  medium_count as medium_count, medium_total_vpr as medium_total_vpr,
                  low_count as low_count, low_total_vpr as low_total_vpr
                FROM vulnerability_daily_totals
                ORDER BY scan_date DESC
                LIMIT 2
            `;

            this.db.all(previousQuery, [], (err, dailyTotalsRows) => {
                if (err) {
                    return reject(new Error("Failed to fetch recent trends: " + err.message));
                }

                // Calculate trends
                const trends = {};

                // If we have daily totals history, use it for comparison
                let currentData = {};
                let previousData = {};

                if (dailyTotalsRows.length >= 1) {
                    // Use the most recent daily total as "current"
                    const currentRow = dailyTotalsRows[0];
                    currentData = {
                        "Critical": { count: currentRow.critical_count || 0, total_vpr: currentRow.critical_total_vpr || 0 },
                        "High": { count: currentRow.high_count || 0, total_vpr: currentRow.high_total_vpr || 0 },
                        "Medium": { count: currentRow.medium_count || 0, total_vpr: currentRow.medium_total_vpr || 0 },
                        "Low": { count: currentRow.low_count || 0, total_vpr: currentRow.low_total_vpr || 0 }
                    };
                }

                if (dailyTotalsRows.length >= 2) {
                    // Use the second most recent daily total (previousData)
                    const prevRow = dailyTotalsRows[1];
                    previousData = {
                        "Critical": { count: prevRow.critical_count || 0, total_vpr: prevRow.critical_total_vpr || 0 },
                        "High": { count: prevRow.high_count || 0, total_vpr: prevRow.high_total_vpr || 0 },
                        "Medium": { count: prevRow.medium_count || 0, total_vpr: prevRow.medium_total_vpr || 0 },
                        "Low": { count: prevRow.low_count || 0, total_vpr: prevRow.low_total_vpr || 0 }
                    };
                } else if (dailyTotalsRows.length === 1) {
                    // First day of data, compare to zero
                    previousData = {
                        "Critical": { count: 0, total_vpr: 0 },
                        "High": { count: 0, total_vpr: 0 },
                        "Medium": { count: 0, total_vpr: 0 },
                        "Low": { count: 0, total_vpr: 0 }
                    };
                }

                // Build trends for each severity
                Object.keys(currentData).forEach(severity => {
                    const current = currentData[severity];
                    const prev = previousData[severity] || { count: 0, total_vpr: 0 };
                    const currentVpr = Math.round((current.total_vpr || 0) * 100) / 100;
                    trends[severity] = {
                        current: { count: current.count, total_vpr: currentVpr },
                        trend: {
                            count_change: current.count - prev.count,
                            vpr_change: Math.round((currentVpr - prev.total_vpr) * 100) / 100
                        }
                    };
                });

                resolve(trends);
            });
        });
    }

    /**
     * Get historical trending data with optional date range filtering
     * Extracted from server.js lines 2095-2156
     */
    async getTrends(startDate = null, endDate = null) {
        return new Promise((resolve, reject) => {
            let whereClause = "";
            let params = [];

            if (startDate && endDate) {
                whereClause = "WHERE scan_date >= ? AND scan_date <= ?";
                params = [startDate, endDate];
            } else if (startDate) {
                whereClause = "WHERE scan_date >= ?";
                params = [startDate];
            } else if (endDate) {
                whereClause = "WHERE scan_date <= ?";
                params = [endDate];
            }
            // No WHERE clause = return all data for ApexCharts to handle filtering

            const query = `
                SELECT
                  scan_date as date,
                  critical_count, critical_total_vpr,
                  high_count, high_total_vpr,
                  medium_count, medium_total_vpr,
                  low_count, low_total_vpr,
                  total_vulnerabilities, total_vpr
                FROM vulnerability_daily_totals
                ${whereClause}
                ORDER BY scan_date ASC
            `;

            this.db.all(query, params, (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to fetch trends: " + err.message));
                }

                // Format data for chart consumption
                const trends = rows.map(row => ({
                    date: row.date,
                    Critical: {
                        count: row.critical_count,
                        total_vpr: Math.round((row.critical_total_vpr || 0) * 100) / 100
                    },
                    High: {
                        count: row.high_count,
                        total_vpr: Math.round((row.high_total_vpr || 0) * 100) / 100
                    },
                    Medium: {
                        count: row.medium_count,
                        total_vpr: Math.round((row.medium_total_vpr || 0) * 100) / 100
                    },
                    Low: {
                        count: row.low_count,
                        total_vpr: Math.round((row.low_total_vpr || 0) * 100) / 100
                    }
                }));

                resolve(trends);
            });
        });
    }

    /**
     * Calculate and store enhanced daily totals with lifecycle states
     * Extracted from server.js lines 1719-1798
     */
    async calculateAndStoreDailyTotalsEnhanced(scanDate) {
        return new Promise((resolve, reject) => {
            // Calculate totals with deduplicated VPR to avoid multi-CVE inflation
            // Group by hostname + plugin_id (or hostname + description) for unique vulnerabilities
            const totalsQuery = `
                SELECT
                    severity,
                    SUM(vuln_count) as count,
                    SUM(max_vpr) as total_vpr,
                    SUM(reopened_count) as reopened_count
                FROM (
                    SELECT
                        severity,
                        hostname,
                        COALESCE(plugin_id, SUBSTR(description, 1, 100)) as dedup_key,
                        COUNT(*) as vuln_count,
                        MAX(vpr_score) as max_vpr,
                        MAX(CASE WHEN lifecycle_state = 'reopened' THEN 1 ELSE 0 END) as reopened_count
                    FROM vulnerabilities_current
                    WHERE scan_date = ? AND lifecycle_state IN ('active', 'reopened')
                    GROUP BY severity, hostname, dedup_key
                )
                GROUP BY severity
            `;

            this.db.all(totalsQuery, [scanDate], (err, results) => {
                if (err) {
                    return reject(new Error("Error calculating enhanced daily totals: " + err.message));
                }

                // Get resolved count for the day
                this.db.get("SELECT COUNT(*) as resolved_count FROM vulnerabilities_current WHERE resolved_date = ?",
                    [scanDate], (err, resolvedResult) => {
                        if (err) {
                            return reject(new Error("Error getting resolved count: " + err.message));
                        }

                        const resolvedCount = resolvedResult ? resolvedResult.resolved_count : 0;

                        const totals = {
                            critical_count: 0, critical_total_vpr: 0,
                            high_count: 0, high_total_vpr: 0,
                            medium_count: 0, medium_total_vpr: 0,
                            low_count: 0, low_total_vpr: 0,
                            total_vulnerabilities: 0, total_vpr: 0,
                            resolved_count: resolvedCount,
                            reopened_count: 0
                        };

                        results.forEach(row => {
                            const severity = row.severity.toLowerCase();
                            if (severity === "critical") {
                                totals.critical_count = row.count;
                                totals.critical_total_vpr = row.total_vpr;
                            } else if (severity === "high") {
                                totals.high_count = row.count;
                                totals.high_total_vpr = row.total_vpr;
                            } else if (severity === "medium") {
                                totals.medium_count = row.count;
                                totals.medium_total_vpr = row.total_vpr;
                            } else if (severity === "low") {
                                totals.low_count = row.count;
                                totals.low_total_vpr = row.total_vpr;
                            }
                            totals.total_vulnerabilities += row.count;
                            totals.total_vpr += row.total_vpr;
                            totals.reopened_count += row.reopened_count || 0;
                        });

                        // Store enhanced daily totals
                        const storeQuery = `INSERT OR REPLACE INTO vulnerability_daily_totals
                            (scan_date, critical_count, critical_total_vpr, high_count, high_total_vpr,
                             medium_count, medium_total_vpr, low_count, low_total_vpr,
                             total_vulnerabilities, total_vpr, resolved_count, reopened_count)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

                        this.db.run(storeQuery, [
                            scanDate,
                            totals.critical_count, totals.critical_total_vpr,
                            totals.high_count, totals.high_total_vpr,
                            totals.medium_count, totals.medium_total_vpr,
                            totals.low_count, totals.low_total_vpr,
                            totals.total_vulnerabilities, totals.total_vpr,
                            totals.resolved_count, totals.reopened_count
                        ], (err) => {
                            if (err) {
                                return reject(new Error("Error storing enhanced daily totals: " + err.message));
                            }

                            console.log(`Enhanced daily totals updated for ${scanDate}`);
                            resolve(totals);
                        });
                    });
            });
        });
    }

    /**
     * Get vulnerability distribution by severity
     * Helper method for analytics
     */
    async getVulnerabilityDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    severity,
                    COUNT(*) as count,
                    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM vulnerabilities_current WHERE lifecycle_state IN ('active', 'reopened')), 2) as percentage
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY severity
                ORDER BY
                    CASE severity
                        WHEN 'Critical' THEN 1
                        WHEN 'High' THEN 2
                        WHEN 'Medium' THEN 3
                        WHEN 'Low' THEN 4
                        ELSE 5
                    END
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get vulnerability distribution: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get top vulnerable hosts by VPR score
     * Helper method for analytics
     */
    async getTopVulnerableHosts(limit = 10) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    hostname,
                    ip_address,
                    COUNT(*) as vulnerability_count,
                    SUM(vpr_score) as total_vpr,
                    AVG(vpr_score) as avg_vpr,
                    MAX(vpr_score) as max_vpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened')
                GROUP BY hostname, ip_address
                ORDER BY total_vpr DESC
                LIMIT ?
            `;

            this.db.all(query, [limit], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get top vulnerable hosts: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get VPR score distribution statistics
     * Helper method for analytics
     */
    async getVprScoreDistribution() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    CASE
                        WHEN vpr_score >= 9.0 THEN 'Extreme (9.0-10.0)'
                        WHEN vpr_score >= 7.0 THEN 'High (7.0-8.9)'
                        WHEN vpr_score >= 4.0 THEN 'Medium (4.0-6.9)'
                        WHEN vpr_score >= 1.0 THEN 'Low (1.0-3.9)'
                        ELSE 'Minimal (0.0-0.9)'
                    END as vpr_range,
                    COUNT(*) as count,
                    ROUND(AVG(vpr_score), 2) as avg_vpr_in_range,
                    MIN(vpr_score) as min_vpr,
                    MAX(vpr_score) as max_vpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened') AND vpr_score IS NOT NULL
                GROUP BY
                    CASE
                        WHEN vpr_score >= 9.0 THEN 'Extreme (9.0-10.0)'
                        WHEN vpr_score >= 7.0 THEN 'High (7.0-8.9)'
                        WHEN vpr_score >= 4.0 THEN 'Medium (4.0-6.9)'
                        WHEN vpr_score >= 1.0 THEN 'Low (1.0-3.9)'
                        ELSE 'Minimal (0.0-0.9)'
                    END
                ORDER BY min_vpr DESC
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get VPR score distribution: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get vulnerability aging metrics
     * Helper method for analytics
     */
    async getVulnerabilityAging() {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT
                    CASE
                        WHEN julianday('now') - julianday(first_seen) <= 7 THEN 'New (≤7 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 30 THEN 'Recent (8-30 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 90 THEN 'Aging (31-90 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 365 THEN 'Old (91-365 days)'
                        ELSE 'Legacy (>365 days)'
                    END as age_category,
                    COUNT(*) as count,
                    ROUND(AVG(julianday('now') - julianday(first_seen)), 1) as avg_days_old,
                    ROUND(AVG(vpr_score), 2) as avg_vpr
                FROM vulnerabilities_current
                WHERE lifecycle_state IN ('active', 'reopened') AND first_seen IS NOT NULL
                GROUP BY
                    CASE
                        WHEN julianday('now') - julianday(first_seen) <= 7 THEN 'New (≤7 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 30 THEN 'Recent (8-30 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 90 THEN 'Aging (31-90 days)'
                        WHEN julianday('now') - julianday(first_seen) <= 365 THEN 'Old (91-365 days)'
                        ELSE 'Legacy (>365 days)'
                    END
                ORDER BY avg_days_old ASC
            `;

            this.db.all(query, [], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get vulnerability aging metrics: " + err.message));
                }
                resolve(rows);
            });
        });
    }

    /**
     * Get daily totals for a specific date range
     * Helper method for custom analytics
     */
    async getDailyTotalsRange(startDate, endDate) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT *
                FROM vulnerability_daily_totals
                WHERE scan_date >= ? AND scan_date <= ?
                ORDER BY scan_date ASC
            `;

            this.db.all(query, [startDate, endDate], (err, rows) => {
                if (err) {
                    return reject(new Error("Failed to get daily totals range: " + err.message));
                }
                resolve(rows);
            });
        });
    }
}

module.exports = VulnerabilityStatsService;