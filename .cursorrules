# HexTrackr Cursor Rules

You are an AI coding assistant working on HexTrackr, a vulnerability and ticket management system. Follow these rules when generating code or making suggestions.

## Project Overview

HexTrackr is a cybersecurity management system with:
- **Backend**: Node.js/Express monolithic server (server.js)
- **Database**: SQLite3 with runtime schema evolution
- **Frontend**: Vanilla JavaScript with modular architecture
- **UI Framework**: Tabler.io (primary) + Bootstrap (legacy)
- **Deployment**: Docker-only (never run Node.js locally)
- **Port**: 8080 (always use localhost:8080 for testing)

## Architecture Principles

### Backend Architecture
- Single `server.js` file handles all routes, middleware, and business logic
- SQLite database with `PathValidator` class for security
- RESTful API with comprehensive endpoint coverage
- Middleware stack: CORS, compression, JSON/form parsing (100MB limits)
- File uploads via multer to `uploads/` directory
- Security headers: X-Content-Type-Options, X-Frame-Options, X-XSS-Protection

### Frontend Architecture
- Modular JavaScript pattern with clear separation:
  - `scripts/shared/` - Shared components (settings-modal.js, header-loader.js)
  - `scripts/pages/` - Page-specific logic (tickets.js, vulnerabilities.js)
  - `scripts/utils/` - Utility functions (security.js)
- Page initialization flow: Load shared components → Load page-specific code
- Inter-module communication via `window.refreshPageData(type)` pattern
- No build process - direct script loading in HTML

### Database Patterns
- Runtime schema evolution with idempotent ALTER TABLE statements
- Key tables: tickets, vulnerabilities, vulnerability_imports, vulnerability_snapshots
- JSON fields stored as strings (e.g., devices column in tickets)
- Rollover architecture for vulnerability data management

## Coding Standards

### JavaScript Style
- **Quotes**: Always use double quotes ("") for strings
- **Semicolons**: Always required at end of statements
- **Variables**: Use `const` by default, `let` when reassignment needed, never `var`
- **Equality**: Always use strict equality (`===` and `!==`)
- **Braces**: Always use curly braces for all control structures
- **Console**: `console.log` allowed (no-console rule disabled)

### Node.js Backend Code
- Use CommonJS modules (`require`/`module.exports`)
- ECMAScript 2022 features allowed
- Handle errors with try-catch blocks
- Use `PathValidator` class for all file system operations
- Database connections via sqlite3 with proper error handling
- Middleware functions should call `next()` appropriately

### Browser Frontend Code
- Use vanilla JavaScript (no frameworks/build tools)
- ECMAScript 2022 features allowed
- Global variables available: window, document, localStorage, fetch, etc.
- Third-party globals: bootstrap, agGrid, DOMPurify
- Use `fetch()` for API calls, not XMLHttpRequest
- Handle async operations with async/await or Promises

### Security Requirements
- Always use `PathValidator.validatePath()` for file operations
- Sanitize user inputs with DOMPurify when rendering HTML
- Set security headers on all API responses
- Validate file uploads and restrict file types
- Use parameterized queries for database operations

## File Organization

### Directory Structure
```
/
├── server.js                 # Main Express server
├── scripts/
│   ├── shared/              # Reusable components
│   ├── pages/               # Page-specific JavaScript
│   ├── utils/               # Utility functions
│   └── init-database.js     # Database initialization
├── data/
│   ├── hextrackr.db        # SQLite database
│   └── schema.sql          # Database schema
├── uploads/                 # File upload directory
├── docs-html/              # Documentation portal
└── app/public/             # Static web assets
```

### Naming Conventions
- Files: kebab-case (e.g., `settings-modal.js`)
- Functions: camelCase (e.g., `refreshPageData`)
- Classes: PascalCase (e.g., `PathValidator`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `DATABASE_PATH`)
- Database tables: snake_case (e.g., `vulnerability_imports`)

## Development Workflow

### Docker Requirements
- **CRITICAL**: Never run Node.js locally - always use Docker
- Use `docker-compose up` to start the application
- Restart container before running Playwright tests: `docker-compose restart`
- All development and testing must happen in containerized environment

### Database Operations
- Database auto-initializes on first run via `scripts/init-database.js`
- Schema changes use idempotent ALTER TABLE statements in server startup
- Backup/restore functionality available via API endpoints
- Use transactions for multi-table operations

### Testing Strategy
- Playwright for browser automation testing (requires Docker restart)
- All tests run against `http://localhost:8080`
- ESLint for code quality with project-specific configuration
- Manual testing via Docker container only

## API Patterns

### Endpoint Structure
- RESTful design: `GET/POST/PUT/DELETE /api/resource`
- Consistent response format with proper HTTP status codes
- Error handling with descriptive error messages
- Support for both JSON and multipart/form-data requests

### Key Endpoints
- Tickets: `/api/tickets` (CRUD operations)
- Vulnerabilities: `/api/vulnerabilities` (with import/export)
- Backups: `/api/backup/:type` and `/api/restore`
- Health check: `/health`

### Data Processing
- CSV imports via Papa Parse library
- Large file handling with 100MB limits
- Vulnerability rollover processing for daily snapshots
- JSON data validation before database insertion

## UI/UX Guidelines

### Component Architecture
- Settings modal provides global data operation hooks
- Page-specific JavaScript handles local interactions
- Shared components loaded before page-specific code
- Use `window.refreshPageData(type)` for cross-component communication

### Styling
- Primary: Tabler.io framework components
- Legacy: Bootstrap classes (being phased out)
- Custom CSS in organized files under `styles/`
- Responsive design principles

### User Experience
- Loading states for async operations
- Error messages with clear user guidance
- Confirmation dialogs for destructive actions
- Progress indicators for long-running processes

## Documentation Standards

### Code Comments
- JSDoc format for function documentation
- Inline comments for complex business logic
- Header comments explaining file purpose
- TODO comments with ticket references when applicable

### API Documentation
- Auto-generated from server.js route definitions
- Request/response examples for all endpoints
- Error code documentation with troubleshooting steps
- Integration examples for common use cases

## Common Patterns to Follow

### Error Handling
```javascript
try {
    const result = await someAsyncOperation();
    res.json({ success: true, data: result });
} catch (error) {
    console.error("Operation failed:", error);
    res.status(500).json({ 
        success: false, 
        error: "Operation failed",
        details: error.message 
    });
}
```

### Database Queries
```javascript
const query = "SELECT * FROM table WHERE id = ?";
db.all(query, [id], (err, rows) => {
    if (err) {
        console.error("Database error:", err);
        return res.status(500).json({ error: "Database operation failed" });
    }
    res.json({ success: true, data: rows });
});
```

### File Operations
```javascript
try {
    const validatedPath = PathValidator.validatePath(filePath);
    const content = PathValidator.safeReadFileSync(validatedPath);
    // Process content...
} catch (error) {
    console.error("File operation failed:", error);
    // Handle error appropriately
}
```

### Frontend API Calls
```javascript
async function fetchData(endpoint) {
    try {
        const response = await fetch(`/api/${endpoint}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("API call failed:", error);
        // Show user-friendly error message
    }
}
```

## Forbidden Practices

### Never Do
- Run Node.js locally (always use Docker)
- Use `var` for variable declarations
- Skip error handling in async operations
- Directly manipulate file paths without PathValidator
- Use `==` or `!=` for comparisons
- Create build processes or bundling steps
- Use single quotes for strings
- Skip semicolons
- Use global variables without proper declaration

### Deprecated Patterns
- XMLHttpRequest (use fetch instead)
- jQuery (use vanilla JavaScript)
- Inline event handlers (use addEventListener)
- Direct DOM manipulation without sanitization
- Synchronous file operations in request handlers

## Performance Considerations

### Backend Optimization
- Use compression middleware for response gzipping
- Implement proper database indexing
- Cache frequently accessed data appropriately
- Use streaming for large file operations
- Implement request rate limiting where needed

### Frontend Optimization
- Minimize DOM queries and cache references
- Use event delegation for dynamic content
- Implement lazy loading for large datasets
- Optimize images and static assets
- Use efficient data structures for client-side operations

## Security Checklist

- [ ] All file paths validated with PathValidator
- [ ] User inputs sanitized before database insertion
- [ ] HTML content sanitized with DOMPurify before rendering
- [ ] Security headers set on all responses
- [ ] File upload restrictions properly implemented
- [ ] SQL injection prevention via parameterized queries
- [ ] Path traversal attacks prevented
- [ ] CORS configured appropriately for production

Remember: HexTrackr prioritizes security, maintainability, and Docker-based development. Always test in the containerized environment and follow the established patterns for consistency across the codebase.
