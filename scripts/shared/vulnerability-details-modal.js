/**
 * Focused Vulnerability Details Modal Module for HexTrackr
 * 
 * This module provides a network admin-friendly vulnerability details modal with essential information,
 * matching the Device Security Modal design patterns and focusing on quick diagnosis and remediation.
 * 
 * @fileoverview Simplified vulnerability details modal for network administrators
 * @author HexTrackr Development Team
 * @version 2.0.0
 */

/* global window, document, bootstrap, agGrid, console */

class VulnerabilityDetailsModal {
    constructor() {
        this.currentVulnerability = null;
        this.affectedAssetsGrid = null;
        this.affectedAssetsGridApi = null;
        
        this.init();
    }

    /**
     * Initialize the vulnerability details modal
     */
    init() {
        this.bindEventListeners();
        console.log("VulnerabilityDetailsModal initialized (Network Admin Focused v2.0)");
    }

    /**
     * Bind event listeners for modal interactions
     */
    bindEventListeners() {
        // Export vulnerability CSV button
        const exportVulnCSV = document.getElementById("exportVulnCSV");
        if (exportVulnCSV) {
            exportVulnCSV.addEventListener("click", () => {
                this.exportVulnerabilityCSV();
            });
        }

        // Generate vulnerability report button
        const generateVulnReport = document.getElementById("generateVulnReport");
        if (generateVulnReport) {
            generateVulnReport.addEventListener("click", () => {
                this.generateVulnerabilityReport();
            });
        }
    }

    /**
     * Display vulnerability details in the modal with focused UI
     * @param {Object|string} vulnerability - The vulnerability data object or vulnerability ID
     * @param {Object} dataManager - The data manager instance for getting related data
     */
    showVulnerabilityDetails(vulnerability, dataManager) {
        let vulnData;
        
        // Handle both direct vulnerability object and ID-based lookup
        if (typeof vulnerability === "string") {
            // New approach: get vulnerability from temporary storage
            vulnData = window.vulnModalData && window.vulnModalData[vulnerability];
            if (!vulnData) {
                console.error("Vulnerability data not found for ID:", vulnerability);
                return;
            }
        } else if (typeof vulnerability === "object" && vulnerability !== null) {
            // Legacy approach: direct object passed
            vulnData = vulnerability;
        } else {
            console.error("Invalid vulnerability parameter:", vulnerability);
            return;
        }

        this.currentVulnerability = vulnData;
        this.populateVulnerabilityInfo(vulnData);
        this.populateRiskSummary(vulnData);
        this.createAffectedAssetsGrid(vulnData, dataManager);
        this.showModal();
    }

    /**
     * Populate vulnerability information section
     * @param {Object} vulnerability - The vulnerability data object
     */
    populateVulnerabilityInfo(vulnerability) {
        const vulnLink = this.getVulnerabilityLink(vulnerability);
        
        document.getElementById("vulnInfo").innerHTML = `
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Vulnerability ID:</div>
                    <div class="col-sm-8">
                        ${vulnLink.url ? 
                            `<a href="#" class="text-primary text-decoration-none fw-bold" 
                               onclick="vulnDetailsModal.lookupVulnerability('${vulnLink.id}')">${vulnLink.id}</a>` :
                            `<span class="fw-bold">${vulnLink.id}</span>`
                        }
                        ${vulnLink.type === "cisco" ? 
                            "<small class=\"badge bg-warning-lt text-warning ms-2\">Cisco Advisory</small>" : 
                            vulnLink.type === "plugin" ? 
                            "<small class=\"badge bg-secondary-lt text-secondary ms-2\">Plugin ID</small>" : ""
                        }
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Plugin Name:</div>
                    <div class="col-sm-8 fw-bold">${vulnerability.plugin_name || "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Description:</div>
                    <div class="col-sm-8"><small class="text-muted">${this.truncateText(vulnerability.description || "No description available", 200)}</small></div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Solution:</div>
                    <div class="col-sm-8"><small class="text-success">${this.truncateText(vulnerability.solution || "No solution provided", 200)}</small></div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Severity:</div>
                    <div class="col-sm-8">
                        <span class="severity-badge severity-${(vulnerability.severity || "Low").toLowerCase()}">${vulnerability.severity || "Low"}</span>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Populate risk summary cards with Tabler.io styling matching device modal
     * @param {Object} vulnerability - The vulnerability data object
     */
    populateRiskSummary(vulnerability) {
        const vprScore = parseFloat(vulnerability.vpr_score) || 0;
        const severity = vulnerability.severity || "Low";
        const severityColor = severity === "Critical" ? "red" : 
                            severity === "High" ? "orange" : 
                            severity === "Medium" ? "yellow" : "green";
        const vprColor = vprScore >= 9 ? "red" : vprScore >= 7 ? "orange" : vprScore >= 4 ? "yellow" : "green";
        
        // Get device count (mock data for now, will be updated when real data integration is available)
        const affectedDevices = this.getAffectedDevicesCount(vulnerability);
        
        document.getElementById("vulnRiskSummary").innerHTML = `
            <div class="col-6">
                <div class="card card-sm bg-${vprColor}-lt">
                    <div class="card-body text-center">
                        <div class="text-${vprColor} h3 mb-1">${vprScore.toFixed(1)}</div>
                        <div class="text-muted small">VPR Score</div>
                        <div class="text-${vprColor} fw-bold">${vprScore >= 9 ? "Critical Risk" : vprScore >= 7 ? "High Risk" : vprScore >= 4 ? "Medium Risk" : "Low Risk"}</div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm bg-${severityColor}-lt">
                    <div class="card-body text-center">
                        <div class="text-${severityColor} h3 mb-1">${affectedDevices}</div>
                        <div class="text-muted small">Devices</div>
                        <div class="text-${severityColor} fw-bold">${severity} Risk</div>
                    </div>
                </div>
            </div>
            <div class="col-12 mt-2">
                <div class="card card-sm bg-blue-lt">
                    <div class="card-body text-center">
                        <div class="row">
                            <div class="col-6">
                                <div class="text-blue small">First Seen</div>
                                <div class="text-blue fw-bold">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString() : "N/A"}</div>
                            </div>
                            <div class="col-6">
                                <div class="text-blue small">Last Seen</div>
                                <div class="text-blue fw-bold">${vulnerability.last_seen ? new Date(vulnerability.last_seen).toLocaleDateString() : vulnerability.scan_date ? new Date(vulnerability.scan_date).toLocaleDateString() : "N/A"}</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Create and configure the affected assets grid with main table styling
     * @param {Object} vulnerability - The vulnerability data object
     * @param {Object} dataManager - The data manager instance
     */
    createAffectedAssetsGrid(vulnerability, dataManager) {
        const gridDiv = document.getElementById("vuln-affected-assets-grid");
        gridDiv.innerHTML = "";

        // Get affected assets data
        const affectedAssets = this.getAffectedAssets(vulnerability, dataManager);
        
        // Update the count
        document.getElementById("affectedAssetsCount").textContent = affectedAssets.length;

        const columnDefs = [
            {
                headerName: "Hostname",
                field: "hostname",
                width: 180,
                cellRenderer: (params) => {
                    return `<a href="#" class="text-primary fw-bold text-decoration-none" onclick="vulnManager?.viewDeviceDetails('${params.value}')">${params.value}</a>`;
                }
            },
            {
                headerName: "IP Address",
                field: "ip_address",
                width: 130,
                cellRenderer: (params) => {
                    const ip = params.value || "N/A";
                    return ip !== "N/A" ? `<code class="text-muted small">${ip}</code>` : "<span class=\"text-muted\">N/A</span>";
                }
            },
            {
                headerName: "VPR",
                field: "vpr_score",
                width: 80,
                cellRenderer: (params) => {
                    const score = parseFloat(params.value) || 0;
                    const severityClass = this.getVprSeverityClass(score);
                    return `<span class="severity-badge severity-${severityClass}">${score.toFixed(1)}</span>`;
                }
            },
            {
                headerName: "Severity",
                field: "severity",
                width: 100,
                cellRenderer: (params) => {
                    const severity = params.value || "Low";
                    const className = `severity-${severity.toLowerCase()}`;
                    return `<span class="severity-badge ${className}">${severity}</span>`;
                }
            },
            {
                headerName: "Last Seen",
                field: "last_seen",
                width: 110,
                cellRenderer: (params) => {
                    if (params.value && params.value.trim() !== "") {
                        return new Date(params.value).toLocaleDateString();
                    } else if (params.data.scan_date && params.data.scan_date.trim() !== "") {
                        return new Date(params.data.scan_date).toLocaleDateString();
                    }
                    return "N/A";
                }
            }
        ];

        const gridOptions = {
            columnDefs: columnDefs,
            rowData: affectedAssets,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 25,
            animateRows: true,
            onGridReady: (params) => {
                this.affectedAssetsGridApi = params.api;
            }
        };

        this.affectedAssetsGrid = new agGrid.Grid(gridDiv, gridOptions);
    }

    /**
     * Get affected assets data for the vulnerability
     * @param {Object} vulnerability - The vulnerability data
     * @param {Object} dataManager - The data manager instance
     * @returns {Array} Array of affected asset objects
     */
    getAffectedAssets(vulnerability, dataManager) {
        if (!dataManager || !dataManager.currentData) {
            // Fallback to single asset if no data manager
            if (vulnerability.hostname && vulnerability.ip_address) {
                return [{
                    hostname: vulnerability.hostname,
                    ip_address: vulnerability.ip_address,
                    vpr_score: vulnerability.vpr_score || 0,
                    severity: vulnerability.severity || "Low",
                    last_seen: vulnerability.last_seen || vulnerability.scan_date,
                    first_seen: vulnerability.first_seen,
                    scan_date: vulnerability.scan_date
                }];
            }
            return [];
        }

        const _assets = [];
        const allVulns = dataManager.currentData.vulnerabilities || [];
        
        // Find all vulnerabilities that match this vulnerability
        // Match by CVE, or plugin_name, or description
        const matchingVulns = allVulns.filter(vuln => {
            if (vulnerability.cve && vuln.cve === vulnerability.cve) {
                return true;
            }
            if (vulnerability.plugin_name && vuln.plugin_name === vulnerability.plugin_name) {
                return true;
            }
            if (vulnerability.description && vuln.description === vulnerability.description) {
                return true;
            }
            return false;
        });

        // Create unique list of affected assets
        const uniqueAssets = new Map();
        
        matchingVulns.forEach(vuln => {
            if (vuln.hostname) {
                const key = vuln.hostname.toLowerCase();
                if (!uniqueAssets.has(key) || vuln.last_seen > uniqueAssets.get(key).last_seen) {
                    uniqueAssets.set(key, {
                        hostname: vuln.hostname,
                        ip_address: vuln.ip_address || "N/A",
                        vpr_score: vuln.vpr_score || 0,
                        severity: vuln.severity || "Low",
                        last_seen: vuln.last_seen || vuln.scan_date,
                        first_seen: vuln.first_seen,
                        scan_date: vuln.scan_date
                    });
                }
            }
        });

        return Array.from(uniqueAssets.values());
    }

    /**
     * Get the count of affected devices for this vulnerability
     * @param {Object} vulnerability - The vulnerability data
     * @returns {number} Number of affected devices
     */
    getAffectedDevicesCount(vulnerability) {
        // Use the same logic as getAffectedAssets but just return count
        if (!window.vulnManager || !window.vulnManager.dataManager || !window.vulnManager.dataManager.currentData) {
            return vulnerability.hostname ? 1 : 0;
        }

        const allVulns = window.vulnManager.dataManager.currentData.vulnerabilities || [];
        const uniqueHosts = new Set();
        
        allVulns.forEach(vuln => {
            if (vuln.hostname) {
                // Match by CVE, plugin_name, or description
                if ((vulnerability.cve && vuln.cve === vulnerability.cve) ||
                    (vulnerability.plugin_name && vuln.plugin_name === vulnerability.plugin_name) ||
                    (vulnerability.description && vuln.description === vulnerability.description)) {
                    uniqueHosts.add(vuln.hostname.toLowerCase());
                }
            }
        });

        return uniqueHosts.size;
    }

    /**
     * Get VPR severity class based on score
     * @param {number} score - VPR score
     * @returns {string} Severity class name
     */
    getVprSeverityClass(score) {
        if (score >= 9.0) {return "critical";}
        if (score >= 7.0) {return "high";}
        if (score >= 4.0) {return "medium";}
        return "low";
    }

    /**
     * Truncate text to specified length
     * @param {string} text - Text to truncate
     * @param {number} maxLength - Maximum length
     * @returns {string} Truncated text
     */
    truncateText(text, maxLength) {
        if (!text || text.length <= maxLength) {return text;}
        return text.substring(0, maxLength) + "...";
    }

    /**
     * Show the vulnerability modal
     */
    showModal() {
        // Close any existing device modal before opening vulnerability modal
        const existingDeviceModal = bootstrap.Modal.getInstance(document.getElementById("deviceModal"));
        if (existingDeviceModal) {
            existingDeviceModal.hide();
        }

        const modal = new bootstrap.Modal(document.getElementById("vulnDetailsModal"));
        modal.show();
    }

    /**
     * Export vulnerability data to CSV
     */
    exportVulnerabilityCSV() {
        const modal = document.getElementById("vulnDetailsModal");
        if (!modal.classList.contains("show")) {
            this.showToast("No vulnerability modal is currently open", "warning");
            return;
        }

        if (!this.currentVulnerability) {
            this.showToast("No vulnerability data available for export", "warning");
            return;
        }

        const vulnerability = this.currentVulnerability;
        const csvData = [];
        
        // Add vulnerability header information
        csvData.push(["Vulnerability Information"]);
        csvData.push(["Vulnerability ID", this.getVulnerabilityLink(vulnerability).id]);
        csvData.push(["Plugin Name", vulnerability.plugin_name || "N/A"]);
        csvData.push(["Severity", vulnerability.severity || "Low"]);
        csvData.push(["VPR Score", (vulnerability.vpr_score || 0).toFixed(1)]);
        csvData.push(["CVSS Score", vulnerability.cvss_score || "N/A"]);
        csvData.push(["Description", vulnerability.description || "N/A"]);
        csvData.push(["Solution", vulnerability.solution || "N/A"]);
        csvData.push(["First Seen", vulnerability.first_seen || "N/A"]);
        csvData.push(["Last Seen", vulnerability.last_seen || vulnerability.scan_date || "N/A"]);
        csvData.push([]);

        // Add affected assets data
        const affectedAssets = this.getAffectedAssets(vulnerability, null);
        if (affectedAssets.length > 0) {
            csvData.push(["Affected Assets"]);
            csvData.push(["Hostname", "IP Address", "VPR Score", "Severity", "Last Seen"]);
            
            affectedAssets.forEach(asset => {
                csvData.push([
                    asset.hostname || "N/A",
                    asset.ip_address || "N/A",
                    (asset.vpr_score || 0).toFixed(1),
                    asset.severity || "Low",
                    asset.last_seen ? new Date(asset.last_seen).toLocaleDateString() : "N/A"
                ]);
            });
        }

        // Convert to CSV format
        const csvContent = csvData.map(row => 
            row.map(field => `"${String(field).replace(/"/g, "\"\"")}"`).join(",")
        ).join("\n");

        // Create and download the file
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        const vulnId = this.getVulnerabilityLink(vulnerability).id.replace(/[^a-zA-Z0-9]/g, "_");
        link.href = URL.createObjectURL(blob);
        link.download = `vulnerability-details-${vulnId}-${timestamp}.csv`;
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Vulnerability details exported for ${this.getVulnerabilityLink(vulnerability).id}`, "success");
    }

    /**
     * Generate vulnerability report in a popup window with print capabilities
     */
    generateVulnerabilityReport() {
        const modal = document.getElementById("vulnDetailsModal");
        if (!modal.classList.contains("show")) {
            this.showToast("No vulnerability modal is currently open", "warning");
            return;
        }

        if (!this.currentVulnerability) {
            this.showToast("No vulnerability data available for report generation", "warning");
            return;
        }

        const vulnerability = this.currentVulnerability;
        const reportWindow = window.open("", "_blank", "width=1200,height=800,scrollbars=yes,resizable=yes");
        
        if (!reportWindow) {
            this.showToast("Popup blocked. Please allow popups for this site.", "error");
            return;
        }

        const reportContent = this.generateReportHTML(vulnerability);
        reportWindow.document.write(reportContent);
        reportWindow.document.close();
        
        // Add event listeners after content is loaded
        reportWindow.addEventListener("load", () => {
            this.setupReportWindowControls(reportWindow);
        });

        this.showToast("Vulnerability report generated successfully", "success");
    }

    /**
     * Generate HTML content for the vulnerability report
     * @param {Object} vulnerability - The vulnerability data object
     * @returns {string} HTML content for the report
     */
    generateReportHTML(vulnerability) {
        const timestamp = new Date().toLocaleString();
        const vulnLink = this.getVulnerabilityLink(vulnerability);
        const affectedAssets = this.getAffectedAssets(vulnerability, null);
        
        return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulnerability Report - ${vulnLink.id}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .severity-badge { padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-weight: 500; font-size: 0.75rem; }
        .severity-critical { background-color: #dc3545; color: white; }
        .severity-high { background-color: #fd7e14; color: white; }
        .severity-medium { background-color: #ffc107; color: #000; }
        .severity-low { background-color: #198754; color: white; }
        .no-print { display: block; }
        @media print {
            .no-print { display: none !important; }
            body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        }
        .report-header { border-bottom: 3px solid #dc3545; padding-bottom: 1rem; margin-bottom: 2rem; }
        .summary-card { border-left: 4px solid #dc3545; }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="no-print sticky-top bg-white border-bottom p-3 mb-3">
            <div class="d-flex justify-content-between align-items-center">
                <h1 class="h4 mb-0">Vulnerability Report - ${vulnLink.id}</h1>
                <div>
                    <button type="button" class="btn btn-outline-primary me-2" onclick="window.print()">
                        <i class="fas fa-print me-1"></i>Print Report
                    </button>
                    <button type="button" class="btn btn-outline-secondary" onclick="window.close()">
                        <i class="fas fa-times me-1"></i>Close
                    </button>
                </div>
            </div>
        </div>

        <div class="report-header">
            <div class="row">
                <div class="col-md-8">
                    <h1 class="display-6 text-danger">Vulnerability Report</h1>
                    <h2 class="h4 text-muted">${vulnLink.id}</h2>
                </div>
                <div class="col-md-4 text-end">
                    <p class="mb-0"><strong>Generated:</strong> ${timestamp}</p>
                    <p class="mb-0"><strong>Report Type:</strong> Security Vulnerability Analysis</p>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card summary-card h-100">
                    <div class="card-header">
                        <h3 class="card-title">Vulnerability Summary</h3>
                    </div>
                    <div class="card-body">
                        <table class="table table-borderless">
                            <tr><th width="40%">Vulnerability ID:</th><td>
                                ${vulnLink.url ? 
                                    `<a href="${vulnLink.url}" target="_blank" class="text-primary text-decoration-none fw-bold">${vulnLink.id} <i class="fas fa-external-link-alt ms-1"></i></a>` :
                                    `<span class="fw-bold">${vulnLink.id}</span>`
                                }
                            </td></tr>
                            <tr><th>Plugin Name:</th><td>${vulnerability.plugin_name || "N/A"}</td></tr>
                            <tr><th>Severity:</th><td><span class="severity-badge severity-${(vulnerability.severity || "low").toLowerCase()}">${vulnerability.severity || "Low"}</span></td></tr>
                            <tr><th>VPR Score:</th><td><span class="severity-badge severity-${this.getVprSeverityClass(vulnerability.vpr_score || 0)}">${(vulnerability.vpr_score || 0).toFixed(1)}</span></td></tr>
                            <tr><th>Affected Devices:</th><td><span class="badge bg-secondary">${affectedAssets.length}</span></td></tr>
                        </table>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card h-100">
                    <div class="card-header">
                        <h3 class="card-title">Timeline</h3>
                    </div>
                    <div class="card-body">
                        <div class="row g-2">
                            <div class="col-12">
                                <div class="card bg-info bg-opacity-10">
                                    <div class="card-body text-center">
                                        <div class="text-info fw-bold">First Seen</div>
                                        <div class="text-muted">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString() : "N/A"}</div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-12">
                                <div class="card bg-warning bg-opacity-10">
                                    <div class="card-body text-center">
                                        <div class="text-warning fw-bold">Last Seen</div>
                                        <div class="text-muted">${vulnerability.last_seen ? new Date(vulnerability.last_seen).toLocaleDateString() : vulnerability.scan_date ? new Date(vulnerability.scan_date).toLocaleDateString() : "N/A"}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Description</h3>
                    </div>
                    <div class="card-body">
                        <p class="border p-3 bg-light">${vulnerability.description || "No description available"}</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Remediation</h3>
                    </div>
                    <div class="card-body">
                        <p class="border p-3 bg-success-lt">${vulnerability.solution || "No solution provided"}</p>
                    </div>
                </div>
            </div>
        </div>

        ${affectedAssets.length > 0 ? `
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">Affected Assets</h3>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-hover mb-0">
                        <thead class="table-dark">
                            <tr>
                                <th>Hostname</th>
                                <th>IP Address</th>
                                <th>VPR Score</th>
                                <th>Severity</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${affectedAssets.map(asset => `
                                <tr>
                                    <td>${asset.hostname || "N/A"}</td>
                                    <td><code>${asset.ip_address || "N/A"}</code></td>
                                    <td><span class="severity-badge severity-${this.getVprSeverityClass(asset.vpr_score || 0)}">${(asset.vpr_score || 0).toFixed(1)}</span></td>
                                    <td><span class="severity-badge severity-${(asset.severity || "low").toLowerCase()}">${asset.severity || "Low"}</span></td>
                                    <td>${asset.last_seen ? new Date(asset.last_seen).toLocaleDateString() : "N/A"}</td>
                                </tr>
                            `).join("")}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        ` : ""}

        <footer class="mt-4 pt-3 border-top text-muted text-center">
            <p>Generated by HexTrackr Security Management Platform</p>
        </footer>
    </div>
</body>
</html>
        `;
    }

    /**
     * Setup controls for the report window
     * @param {Window} reportWindow - The popup report window
     */
    setupReportWindowControls(reportWindow) {
        // Focus the window
        reportWindow.focus();
        
        // Set window title
        const vulnId = this.getVulnerabilityLink(this.currentVulnerability).id;
        reportWindow.document.title = `Vulnerability Report - ${vulnId}`;
    }

    /**
     * Determine vulnerability ID type and create appropriate link
     * @param {Object} vulnData - The vulnerability data
     * @returns {Object} Link object with id, type, and url
     */
    getVulnerabilityLink(vulnData) {
        const { cve, plugin_name, plugin_id } = vulnData;
        
        // Check for CVE first
        if (cve && cve.startsWith("CVE-")) {
            return {
                id: cve,
                type: "cve",
                url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve.trim()}`
            };
        }
        
        // Check for Cisco SA ID in plugin name
        const ciscoId = this.extractCiscoVulnId(plugin_name);
        if (ciscoId) {
            return {
                id: ciscoId,
                type: "cisco",
                url: `https://www.cisco.com/c/en/us/support/docs/csa/${ciscoId}.html`
            };
        }
        
        // Fall back to plugin ID
        return {
            id: plugin_id ? `Plugin ${plugin_id}` : "Unknown",
            type: "plugin",
            url: null
        };
    }

    /**
     * Extract Cisco vulnerability ID from plugin name
     * @param {string} pluginName - The plugin name
     * @returns {string|null} Cisco vulnerability ID or null
     */
    extractCiscoVulnId(pluginName) {
        if (!pluginName || typeof pluginName !== "string") {
            return null;
        }
        
        // Look for cisco-sa- pattern in plugin name
        const ciscoSaMatch = pluginName.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
        if (ciscoSaMatch) {
            return `cisco-sa-${ciscoSaMatch[1]}`;
        }
        
        return null;
    }

    /**
     * Lookup vulnerability in external resources
     * @param {string} vulnId - The vulnerability ID
     */
    async lookupVulnerability(vulnId) {
        // If CVE, use existing CVE lookup
        if (vulnId && vulnId.startsWith("CVE-")) {
            return this.lookupCVE(vulnId);
        }
        
        // If it looks like a Cisco SA ID, open Cisco advisory
        if (vulnId && vulnId.startsWith("cisco-sa-")) {
            const popup = window.open(
                `https://www.cisco.com/c/en/us/support/docs/csa/${vulnId}.html`,
                `Cisco_Advisory_${vulnId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            
            if (popup) {
                popup.focus();
                this.showToast(`Opened Cisco advisory for ${vulnId}`, "success");
            } else {
                this.showToast("Popup blocked - please allow popups for vulnerability lookups", "warning");
            }
            return;
        }
        
        // Default fallback
        this.showToast("No external vulnerability reference available for this item", "info");
    }

    /**
     * Lookup CVE information
     * @param {string} cveId - The CVE ID
     */
    async lookupCVE(cveId) {
        const popup = window.open(
            `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId}`,
            `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
            "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
        );
        
        if (popup) {
            popup.focus();
            this.showToast(`Opened CVE lookup for ${cveId}`, "success");
        } else {
            this.showToast("Popup blocked - please allow popups for CVE lookups", "warning");
        }
    }

    /**
     * Show toast notification
     * @param {string} message - Toast message
     * @param {string} type - Toast type (success, warning, error, info)
     */
    showToast(message, type = "info") {
        // Integration with existing toast system
        if (window.vulnManager && typeof window.vulnManager.showToast === "function") {
            window.vulnManager.showToast(message, type);
        } else {
            console.log(`${type.toUpperCase()}: ${message}`);
        }
    }
}

// Initialize the vulnerability details modal when the DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
    window.vulnDetailsModal = new VulnerabilityDetailsModal();
});

// Export for module usage (Node.js environment check)
if (typeof window === "undefined" && typeof module !== "undefined" && module.exports) {
    module.exports = VulnerabilityDetailsModal;
}