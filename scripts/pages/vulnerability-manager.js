/* eslint-env browser */
/* global bootstrap, agGrid, ApexCharts, Papa, Sortable, createVulnerabilityGridOptions */
/* exported ModernVulnManager */

/**
 * @fileoverview
 * This file defines the ModernVulnManager class, the core of the HexTrackr
 * vulnerability management dashboard. It handles all client-side logic, including:
 * - Data fetching, processing, and caching from the backend API.
 * - Initialization and management of the AG Grid for tabular data display.
 * - Rendering and updating of the ApexCharts for historical trend visualization.
 * - User interactions such as searching, filtering, and view switching.
 * - Modal dialogs for device details, vulnerability information, and CSV imports.
 * - Data import/export functionality.
 *
 * @version 2.0.0
 * @author Gemini
 * @date 2025-09-03
 */

// Pagination Controller Class
class PaginationController {
    constructor(defaultPageSize = 12, availableSizes = [6, 12, 24, 48, 64, 96]) {
        this.pageSize = defaultPageSize;
        this.currentPage = 1;
        this.availableSizes = availableSizes;
        this.totalItems = 0;
    }

    setTotalItems(count) {
        this.totalItems = count;
        // Reset to page 1 if current page is out of bounds
        const maxPage = this.getTotalPages();
        if (this.currentPage > maxPage && maxPage > 0) {
            this.currentPage = 1;
        }
    }

    getTotalPages() {
        return Math.ceil(this.totalItems / this.pageSize);
    }

    getCurrentPageData(items) {
        const startIndex = (this.currentPage - 1) * this.pageSize;
        const endIndex = startIndex + this.pageSize;
        return items.slice(startIndex, endIndex);
    }

    setPageSize(size) {
        const validSize = this.availableSizes.includes(parseInt(size)) ? parseInt(size) : this.availableSizes[0];
        this.pageSize = validSize;
        this.currentPage = 1; // Reset to first page when changing page size
    }

    setCurrentPage(page) {
        const pageNum = parseInt(page);
        const maxPage = this.getTotalPages();
        if (pageNum >= 1 && pageNum <= maxPage) {
            this.currentPage = pageNum;
        }
    }

    getPageInfo() {
        const startItem = this.totalItems === 0 ? 0 : (this.currentPage - 1) * this.pageSize + 1;
        const endItem = Math.min(this.currentPage * this.pageSize, this.totalItems);
        
        return {
            currentPage: this.currentPage,
            totalPages: this.getTotalPages(),
            pageSize: this.pageSize,
            totalItems: this.totalItems,
            startItem,
            endItem,
            availableSizes: this.availableSizes
        };
    }

    renderPaginationControls(containerId, onPageChange, onPageSizeChange) {
        const container = document.getElementById(containerId);
        if (!container) {
            return;
        }

        const info = this.getPageInfo();
        
        if (info.totalItems === 0) {
            container.innerHTML = "";
            return;
        }

        const prevDisabled = info.currentPage === 1 ? "disabled" : "";
        const nextDisabled = info.currentPage === info.totalPages ? "disabled" : "";

        container.innerHTML = `
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                <div class="pagination-info">
                    <span class="text-muted">
                        Showing ${info.startItem} to ${info.endItem} of ${info.totalItems} items
                    </span>
                </div>
                
                <div class="d-flex align-items-center gap-3 flex-wrap">
                    <div class="d-flex align-items-center gap-2">
                        <label for="${containerId}PageSize" class="form-label mb-0 text-muted small">Items per page:</label>
                        <select id="${containerId}PageSize" class="form-select form-select-sm" style="width: auto;">
                            ${info.availableSizes.map(size => 
                                `<option value="${size}" ${size === info.pageSize ? "selected" : ""}>${size}</option>`
                            ).join("")}
                        </select>
                    </div>
                    
                    <nav aria-label="Card pagination">
                        <ul class="pagination pagination-sm mb-0">
                            <li class="page-item ${prevDisabled}">
                                <button class="page-link" data-page="1" ${prevDisabled ? "disabled" : ""}>
                                    <i class="fas fa-angle-double-left"></i>
                                </button>
                            </li>
                            <li class="page-item ${prevDisabled}">
                                <button class="page-link" data-page="${info.currentPage - 1}" ${prevDisabled ? "disabled" : ""}>
                                    <i class="fas fa-angle-left"></i>
                                </button>
                            </li>
                            
                            ${this.generatePageNumbers(info).map(page => {
                                if (page === "...") {
                                    return "<li class=\"page-item disabled\"><span class=\"page-link\">...</span></li>";
                                }
                                const isActive = page === info.currentPage ? "active" : "";
                                return `<li class="page-item ${isActive}">
                                    <button class="page-link" data-page="${page}">${page}</button>
                                </li>`;
                            }).join("")}
                            
                            <li class="page-item ${nextDisabled}">
                                <button class="page-link" data-page="${info.currentPage + 1}" ${nextDisabled ? "disabled" : ""}>
                                    <i class="fas fa-angle-right"></i>
                                </button>
                            </li>
                            <li class="page-item ${nextDisabled}">
                                <button class="page-link" data-page="${info.totalPages}" ${nextDisabled ? "disabled" : ""}>
                                    <i class="fas fa-angle-double-right"></i>
                                </button>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
        `;

        // Add event listeners
        const pageSizeSelect = container.querySelector(`#${containerId}PageSize`);
        if (pageSizeSelect) {
            pageSizeSelect.addEventListener("change", (e) => {
                this.setPageSize(e.target.value);
                onPageSizeChange();
            });
        }

        container.querySelectorAll(".page-link[data-page]").forEach(btn => {
            btn.addEventListener("click", (e) => {
                e.preventDefault();
                if (!btn.disabled) {
                    this.setCurrentPage(btn.getAttribute("data-page"));
                    onPageChange();
                }
            });
        });
    }

    generatePageNumbers(info) {
        const pages = [];
        const current = info.currentPage;
        const total = info.totalPages;
        
        if (total <= 7) {
            for (let i = 1; i <= total; i++) {
                pages.push(i);
            }
        } else {
            if (current <= 4) {
                for (let i = 1; i <= 5; i++) {
                    pages.push(i);
                }
                pages.push("...");
                pages.push(total);
            } else if (current >= total - 3) {
                pages.push(1);
                pages.push("...");
                for (let i = total - 4; i <= total; i++) {
                    pages.push(i);
                }
            } else {
                pages.push(1);
                pages.push("...");
                for (let i = current - 1; i <= current + 1; i++) {
                    pages.push(i);
                }
                pages.push("...");
                pages.push(total);
            }
        }
        
        return pages;
    }
}

// Modern Vulnerability Management System
class ModernVulnManager {
    constructor() {
        this.vulnerabilities = [];
        this.filteredVulnerabilities = [];
        this.devices = [];
        this.currentView = "table";
        this.gridApi = null;
        this.chart = null;
        this.historicalData = [];
        this.statistics = {};
        this.uniqueAssets = new Set();
        this.apiBase = "/api";
        this.currentMetricType = "count"; // Default to showing count percentages
        
        // Initialize pagination controllers
        this.devicePagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        this.vulnerabilityPagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        
        this.setupEventListeners();
        this.initializeGrid();
        this.initializeChart();
        this.loadData();
    }

    setupEventListeners() {
        // Import CSV - Show date picker modal
        document.getElementById("importCsvBtn").addEventListener("click", () => {
            document.getElementById("csvFileInput").click();
        });

        document.getElementById("csvFileInput").addEventListener("change", (e) => {
            this.showScanDateModal(e);
        });

        // Confirm scan date and proceed with import
        document.getElementById("confirmScanDate").addEventListener("click", () => {
            this.proceedWithImport();
        });

        // Search and filters
        document.getElementById("searchInput").addEventListener("input", (_e) => {
            this.filterData();
        });

        document.getElementById("severityFilter").addEventListener("change", (_e) => {
            this.filterData();
        });

        // View switcher for Tabler.io button group
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const view = e.target.dataset.view || e.target.closest("[data-view]").dataset.view;
                if (view) {
                    this.switchView(view);
                }
            });
        });

        // Export button
        document.getElementById("exportBtn").addEventListener("click", () => {
            this.exportData();
        });

        // Refresh button - Check if exists before adding listener
        const refreshBtn = document.getElementById("refreshBtn");
        if (refreshBtn) {
            refreshBtn.addEventListener("click", () => {
                this.refreshData();
            });
        }

        // Save vulnerability edit
        const saveVulnEdit = document.getElementById("saveVulnEdit");
        if (saveVulnEdit) {
            saveVulnEdit.addEventListener("click", () => {
                this.saveVulnerabilityChanges();
            });
        }

        // Device modal export buttons
        const exportDeviceData = document.getElementById("exportDeviceData");
        if (exportDeviceData) {
            exportDeviceData.addEventListener("click", () => {
                this.exportDeviceData();
            });
        }

        // Generate device report button - Check if exists
        const generateDeviceReport = document.getElementById("generateDeviceReport");
        if (generateDeviceReport) {
            generateDeviceReport.addEventListener("click", () => {
                this.generateDeviceReport();
            });
        }
    }

    initializeGrid() {
        const gridOptions = createVulnerabilityGridOptions(this);
        const gridDiv = document.getElementById("vulnGrid");
        
        if (this.gridApi) {
            this.gridApi.destroy();
        }

        this.gridApi = agGrid.createGrid(gridDiv, gridOptions);
    }

    initializeChart() {
        const options = {
            series: [{
                name: "Critical",
                data: []
            }, {
                name: "High",
                data: []
            }, {
                name: "Medium",
                data: []
            }, {
                name: "Low",
                data: []
            }],
            chart: {
                height: 450,
                type: "line",
                background: "transparent",
                fontFamily: "Inter, -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif",
                zoom: {
                    enabled: true,
                    type: "x",
                    autoScaleYaxis: true,
                    zoomedArea: {
                        fill: {
                            color: "#90CAF9",
                            opacity: 0.4
                        },
                        stroke: {
                            color: "#0D47A1",
                            opacity: 0.4,
                            width: 1
                        }
                    }
                },
                toolbar: {
                    show: true,
                    offsetX: 0,
                    offsetY: 0,
                    tools: {
                        download: true,
                        selection: true,
                        zoom: true,
                        zoomin: true,
                        zoomout: true,
                        pan: true,
                        reset: true
                    },
                    export: {
                        csv: {
                            filename: `vulnerability-trends-${new Date().toISOString().split("T")[0]}`
                        },
                        png: {
                            filename: `vulnerability-trends-${new Date().toISOString().split("T")[0]}`
                        }
                    }
                },
                animations: {
                    enabled: true,
                    easing: "easeinout",
                    speed: 800,
                    animateGradually: {
                        enabled: true,
                        delay: 150
                    },
                    dynamicAnimation: {
                        enabled: true,
                        speed: 350
                    }
                }
            },
            colors: ["#dc2626", "#ea580c", "#2563eb", "#16a34a"],
            stroke: {
                curve: "smooth",
                width: 3,
                lineCap: "round"
            },
            markers: {
                size: 0,
                strokeWidth: 2,
                strokeColors: "#ffffff",
                fillOpacity: 1,
                hover: {
                    size: 10,
                    sizeOffset: 3
                },
                discrete: []
            },
            dataLabels: {
                enabled: false
            },
            grid: {
                show: true,
                borderColor: "#f1f5f9",
                strokeDashArray: 3,
                position: "back",
                xaxis: {
                    lines: {
                        show: true
                    }
                },
                yaxis: {
                    lines: {
                        show: true
                    }
                },
                padding: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            },
            xaxis: {
                type: "datetime",
                labels: {
                    style: {
                        colors: "#64748b",
                        fontSize: "13px",
                        fontFamily: "Inter, sans-serif",
                        fontWeight: 500
                    },
                    datetimeUTC: false,
                    format: "MMM dd",
                    rotate: 0
                },
                axisBorder: {
                    show: true,
                    color: "#e2e8f0",
                    height: 1
                },
                axisTicks: {
                    show: true,
                    color: "#e2e8f0",
                    height: 4
                },
                tooltip: {
                    enabled: false
                }
            },
            yaxis: {
                labels: {
                    style: {
                        colors: "#64748b",
                        fontSize: "13px",
                        fontFamily: "Inter, sans-serif",
                        fontWeight: 500
                    },
                    formatter: function(value) {
                        return Math.round(value).toLocaleString();
                    }
                },
                axisBorder: {
                    show: true,
                    color: "#e2e8f0"
                },
                axisTicks: {
                    show: true,
                    color: "#e2e8f0"
                },
                title: {
                    text: "Vulnerability Count",
                    style: {
                        color: "#475569",
                        fontSize: "14px",
                        fontFamily: "Inter, sans-serif",
                        fontWeight: 600
                    }
                },
                min: 0
            },
            legend: {
                show: true,
                position: "top",
                horizontalAlign: "left",
                floating: false,
                fontSize: "14px",
                fontFamily: "Inter, sans-serif",
                fontWeight: 500,
                offsetY: 0,
                offsetX: 0,
                markers: {
                    width: 16,
                    height: 16,
                    strokeWidth: 0,
                    radius: 8
                },
                itemMargin: {
                    horizontal: 20,
                    vertical: 8
                },
                labels: {
                    colors: "#374151"
                }
            },
            tooltip: {
                enabled: true,
                shared: true,
                intersect: false,
                theme: "light",
                style: {
                    fontSize: "13px",
                    fontFamily: "Inter, sans-serif"
                },
                x: {
                    format: "MMM dd, yyyy"
                },
                filter: {
                    seriesIndex: 0,
                    type: "none"
                },
                custom: function({ series, seriesIndex: _seriesIndex, dataPointIndex, w: _w }) {
                    const vulnerabilityTracker = window.vulnerabilityTracker;
                    if (!vulnerabilityTracker || !vulnerabilityTracker.historicalData) {return "";}
                    
                    const extendedData = vulnerabilityTracker.extendTimelineData(vulnerabilityTracker.historicalData);
                    const dataPoint = extendedData[dataPointIndex];
                    
                    if (!dataPoint || !dataPoint.hasActualData) {
                        return "";
                    }
                    
                    const date = new Date(dataPoint.scan_date || dataPoint.date).toLocaleDateString("en-US", { 
                        weekday: "long",
                        month: "long", 
                        day: "numeric", 
                        year: "numeric" 
                    });
                    
                    const currentMetric = document.querySelector("input[name=\"chart-metric\"]:checked")?.nextElementSibling?.dataset?.metric || "count";
                    
                    let tooltipContent = `
                        <div class="apexcharts-tooltip-custom" style="
                            background: white;
                            border: 1px solid #e2e8f0;
                            border-radius: 12px;
                            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
                            padding: 16px;
                            font-family: Inter, sans-serif;
                            min-width: 280px;
                            max-width: 320px;
                        ">
                            <div style="
                                font-weight: 600;
                                font-size: 14px;
                                color: #1f2937;
                                margin-bottom: 12px;
                                padding-bottom: 8px;
                                border-bottom: 1px solid #f3f4f6;
                                text-align: center;
                            ">${date}</div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                    `;
                    
                    const seriesNames = ["Critical", "High", "Medium", "Low"];
                    const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
                    
                    series.forEach((seriesData, index) => {
                        const value = seriesData[dataPointIndex];
                        if (value !== undefined && value !== null) {
                            const metric = currentMetric === "vpr" ? " VPR" : "";
                            
                            tooltipContent += `
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: space-between;
                                    padding: 6px 0;
                                ">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <div style="
                                            width: 14px;
                                            height: 14px;
                                            border-radius: 50%;
                                            background-color: ${colors[index]};
                                            border: 2px solid white;
                                            box-shadow: 0 0 0 1px ${colors[index]}40;
                                        "></div>
                                        <span style="
                                            font-size: 13px;
                                            color: #4b5563;
                                            font-weight: 500;
                                        ">${seriesNames[index]}</span>
                                    </div>
                                    <span style="
                                        font-size: 14px;
                                        font-weight: 600;
                                        color: #1f2937;
                                    ">${value.toLocaleString()}${metric}</span>
                                </div>
                            `;
                        }
                    });
                    
                    tooltipContent += `
                            </div>
                            <div style="
                                margin-top: 12px;
                                padding-top: 8px;
                                border-top: 1px solid #f3f4f6;
                                font-size: 11px;
                                color: #6b7280;
                                text-align: center;
                            ">ðŸ“Š Data from vulnerability scan</div>
                        </div>
                    `;
                    
                    return tooltipContent;
                }
            },
            title: {
                text: "Historical Vulnerability Trends",
                align: "left",
                style: {
                    fontSize: "20px",
                    fontWeight: "600",
                    color: "#1f2937",
                    fontFamily: "Inter, sans-serif"
                },
                offsetY: 20
            },
            subtitle: {
                text: "Showing data points only for actual vulnerability scans",
                align: "left",
                style: {
                    fontSize: "14px",
                    fontWeight: "400",
                    color: "#6b7280",
                    fontFamily: "Inter, sans-serif"
                },
                offsetY: 45
            },
            theme: {
                mode: "light",
                palette: "palette1"
            },
            responsive: [{
                breakpoint: 768,
                options: {
                    chart: {
                        height: 350
                    },
                    legend: {
                        position: "bottom",
                        offsetY: 10
                    },
                    title: {
                        style: {
                            fontSize: "18px"
                        }
                    }
                }
            }]
        };

        this.chart = new ApexCharts(document.getElementById("historicalChart"), options);
        this.chart.render();
        
        setTimeout(() => {
            const chartContainer = document.getElementById("historicalChart");
            if (chartContainer) {
                let _pinnedTooltip = null;
                let tooltipCloseTime = null;
                
                chartContainer.addEventListener("click", (_e) => {
                    const tooltip = document.querySelector(".apexcharts-tooltip.persistent-tooltip");
                    if (tooltip && tooltip.style.opacity !== "0") {
                        _pinnedTooltip = tooltip;
                        tooltip.style.border = "2px solid #3b82f6";
                        tooltip.style.boxShadow = "0 4px 12px rgba(59, 130, 246, 0.3)";
                        tooltip.setAttribute("data-pinned", "true");
                        
                        if (!tooltip.querySelector(".close-btn")) {
                            const closeBtn = document.createElement("div");
                            closeBtn.className = "close-btn";
                            closeBtn.innerHTML = "âœ•";
                            closeBtn.style.cssText = `
                                position: absolute; top: 4px; right: 8px; 
                                cursor: pointer; color: #6b7280; font-size: 14px; 
                                width: 16px; height: 16px; display: flex; 
                                align-items: center; justify-content: center;
                                border-radius: 50%; background: #f3f4f6;
                            `;
                            closeBtn.addEventListener("mouseenter", () => {
                                closeBtn.style.background = "#e5e7eb";
                            });
                            closeBtn.addEventListener("mouseleave", () => {
                                closeBtn.style.background = "#f3f4f6";
                            });
                            closeBtn.addEventListener("click", (e) => {
                                e.stopPropagation();
                                tooltip.style.opacity = "0";
                                tooltip.style.display = "none";
                                tooltipCloseTime = Date.now();
                                _pinnedTooltip = null;
                            });
                            tooltip.appendChild(closeBtn);
                        }
                    }
                });
                
                chartContainer.addEventListener("mouseover", (_e) => {
                    if (tooltipCloseTime && (Date.now() - tooltipCloseTime) > 500) {
                        const tooltip = document.querySelector(".apexcharts-tooltip");
                        if (tooltip && tooltip.style.opacity === "0") {
                            tooltip.style.opacity = "";
                            tooltip.style.display = "";
                            tooltip.style.border = "2px solid #e5e7eb";
                            tooltip.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
                            tooltip.removeAttribute("data-pinned");
                            
                            const closeBtn = tooltip.querySelector(".close-btn");
                            if (closeBtn) {closeBtn.remove();}
                            
                            tooltipCloseTime = null;
                        }
                    }
                });
            }
        }, 100);
    }

    showScanDateModal(event) {
        this.pendingFile = event.target.files[0];
        if (!this.pendingFile) {return;}

        const today = new Date().toISOString().split("T")[0];
        document.getElementById("scanDateInput").value = today;

        const modal = new bootstrap.Modal(document.getElementById("scanDateModal"));
        modal.show();
    }

    async proceedWithImport() {
        const scanDate = document.getElementById("scanDateInput").value;
        if (!scanDate) {
            this.showToast("Please select a scan date", "danger");
            return;
        }

        const modal = bootstrap.Modal.getInstance(document.getElementById("scanDateModal"));
        modal.hide();

        await this.handleCsvImportWithDate(this.pendingFile, scanDate);
        
        this.pendingFile = null;
        document.getElementById("csvFileInput").value = "";
    }

    async handleCsvImportWithDate(file, scanDate) {
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                return;
            }
        }

        this.showLoading("Uploading CSV file...");

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");
            formData.append("scanDate", scanDate);

            const response = await fetch(`${this.apiBase}/vulnerabilities/import`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            this.showLoading("Processing data...");
            const result = await response.json();

            this.showLoading("Refreshing charts and data...");
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await this.loadData();

            this.hideLoading();
            
            let message = `CSV import completed! Processed ${result.rowsProcessed.toLocaleString()} rows from ${result.filename} with scan date ${scanDate}.`;
            if (result.insertCount || result.updateCount || result.removedStale) {
                message += ` Added: ${result.insertCount || 0}, Updated: ${result.updateCount || 0}, Removed: ${result.removedStale || 0} stale items.`;
            }
            
            this.showToast(message, "success");

        } catch (error) {
            this.hideLoading();
            console.error("Error importing CSV:", error);
            this.showToast("Error importing CSV: " + error.message, "danger");
        }
    }

    async handleCsvImport(event) {
        const file = event.target.files[0];
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                event.target.value = "";
                return;
            }
        }

        this.showLoading("Uploading CSV file...");

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");

            const response = await fetch(`${this.apiBase}/vulnerabilities/import`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            this.showLoading("Processing data...");
            const result = await response.json();

            this.showLoading("Updating display...");
            await this.loadData();

            this.hideLoading();
            this.showToast(`CSV import completed! Imported ${result.rowsProcessed.toLocaleString()} vulnerabilities from ${result.filename}.`, "success");

            event.target.value = "";
        } catch (error) {
            this.hideLoading();
            console.error("Error importing CSV:", error);
            this.showToast("Error importing CSV: " + error.message, "danger");
            event.target.value = "";
        }
    }

    calculateSeverity(vprScore) {
        if (vprScore >= 9.0) {return "Critical";}
        if (vprScore >= 7.0) {return "High";}
        if (vprScore >= 4.0) {return "Medium";}
        return "Low";
    }

    async loadData() {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities?limit=10000`);
            if (response.ok) {
                const result = await response.json();
                this.vulnerabilities = result.data || [];
            } else {
                this.vulnerabilities = [];
            }
            
            const trendsResponse = await fetch(`${this.apiBase}/vulnerabilities/trends`);
            if (trendsResponse.ok) {
                this.historicalData = await trendsResponse.json();
            } else {
                this.historicalData = [];
            }
            
            this.processDevices();
            this.loadStatistics();
            this.updateChart();
            this.filterData();
        } catch (error) {
            console.error("Error loading data:", error);
            this.showToast("Error loading data from database", "danger");
        }
    }

    processDevices() {
        const deviceMap = new Map();
        
        this.vulnerabilities.forEach(vuln => {
            if (!deviceMap.has(vuln.hostname)) {
                deviceMap.set(vuln.hostname, {
                    hostname: vuln.hostname,
                    vulnerabilities: [],
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0,
                    criticalVPR: 0,
                    highVPR: 0,
                    mediumVPR: 0,
                    lowVPR: 0,
                    totalCount: 0,
                    totalVPR: 0
                });
            }
            
            const device = deviceMap.get(vuln.hostname);
            device.vulnerabilities.push(vuln);
            device.totalCount++;
            
            const vprScore = vuln.vpr_score || 0;
            device.totalVPR += vprScore;
            
            switch (vuln.severity) {
                case "Critical": 
                    device.criticalCount++; 
                    device.criticalVPR += vprScore;
                    break;
                case "High": 
                    device.highCount++; 
                    device.highVPR += vprScore;
                    break;
                case "Medium": 
                    device.mediumCount++; 
                    device.mediumVPR += vprScore;
                    break;
                case "Low": 
                    device.lowCount++; 
                    device.lowVPR += vprScore;
                    break;
            }
        });
        
        this.devices = Array.from(deviceMap.values());
    }

    async loadStatistics() {
        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/recent-trends`);
            if (response.ok) {
                const trends = await response.json();
                this.statistics = {};
                this.trends = trends;
                
                Object.keys(trends).forEach(severity => {
                    this.statistics[severity.toLowerCase()] = {
                        count: trends[severity].current.count,
                        total_vpr: trends[severity].current.total_vpr,
                        avg_vpr: trends[severity].current.total_vpr / trends[severity].current.count || 0
                    };
                });
                
                this.updateStatisticsDisplay();
            }
        } catch (error) {
            console.error("Error loading statistics:", error);
        }
    }

    updateStatisticsDisplay() {
        ["critical", "high", "medium", "low", "info"].forEach(severity => {
            const stat = this.statistics[severity];
            if (stat) {
                const countEl = document.getElementById(`${severity}Count`);
                const vprEl = document.getElementById(`${severity}VPR`);
                
                if (countEl) {
                    countEl.textContent = stat.count;
                }
                
                if (vprEl) {
                    vprEl.textContent = `${stat.total_vpr.toFixed(1)} VPR`;
                }
                
                const totalVprEl = document.getElementById(`${severity}TotalVPR`);
                const avgVprEl = document.getElementById(`${severity}AvgVPR`);
                
                if (totalVprEl) {
                    totalVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (avgVprEl) {
                    const average = stat.count > 0 ? (stat.total_vpr / stat.count).toFixed(1) : "0.0";
                    avgVprEl.textContent = `${average} avg`;
                }
                
                const legacyCountEl = document.getElementById(`${severity}-count`);
                const legacyVprEl = document.getElementById(`${severity}-vpr`);
                
                if (legacyCountEl) {
                    legacyCountEl.textContent = stat.count;
                }
                
                if (legacyVprEl) {
                    legacyVprEl.textContent = stat.total_vpr.toFixed(1);
                }
                
                if (this.trends && this.trends[severity]) {
                    const trendEl = document.getElementById(`${severity}Trend`);
                    if (trendEl) {
                        const severityKey = severity.charAt(0).toUpperCase() + severity.slice(1);
                        const trendData = this.trends[severityKey] ? this.trends[severityKey].trend : null;
                        
                        if (trendData) {
                            const change = this.currentMetricType === "vpr" ? trendData.vpr_change : trendData.count_change;
                            const current = this.currentMetricType === "vpr" ? this.trends[severityKey].current.total_vpr : this.trends[severityKey].current.count;
                            const previous = current - change;
                            const direction = change > 0 ? "up" : change < 0 ? "down" : "stable";
                            
                            let percentage = 0;
                            if (previous !== 0) {
                                percentage = Math.abs((change / previous) * 100);
                            }
                            
                            const iconEl = trendEl.querySelector("i");
                            const badgeEl = trendEl.querySelector(".trend-value");
                            
                            if (iconEl && badgeEl) {
                                if (direction === "up") {
                                    iconEl.className = "ti ti-trending-up fs-3";
                                    badgeEl.textContent = `+${percentage.toFixed(1)}%`;
                                } else if (direction === "down") {
                                    iconEl.className = "ti ti-trending-down fs-3";
                                    badgeEl.textContent = `-${percentage.toFixed(1)}%`;
                                } else {
                                    iconEl.className = "ti ti-minus fs-3";
                                    badgeEl.textContent = "0%";
                                }
                            }
                        }
                    }
                }
            }
        });
        
        const totalVulns = Object.values(this.statistics).reduce((sum, stat) => sum + stat.count, 0);
        const totalVulnsEl = document.getElementById("total-vulns");
        if (totalVulnsEl) {
            totalVulnsEl.textContent = totalVulns;
        }
        
        const total = totalVulns;
        if (total > 0) {
            ["critical", "high", "medium", "low", "info"].forEach(severity => {
                const stat = this.statistics[severity];
                if (stat) {
                    const percentageEl = document.querySelector(`.severity-${severity} .percentage`);
                    if (percentageEl) {
                        percentageEl.textContent = `${((stat.count / total) * 100).toFixed(1)}%`;
                    }
                }
            });
        }
    }

    updateTrendIndicators(_currentStats) {
        if (this.historicalData && this.historicalData.length > 0) {
            const latest = this.historicalData[this.historicalData.length - 1];
            const previous = this.historicalData.length > 1 ? this.historicalData[this.historicalData.length - 2] : latest;
            
            const trends = {
                critical: this.calculateTrend(previous.critical_vpr || 0, latest.critical_vpr || 0),
                high: this.calculateTrend(previous.high_vpr || 0, latest.high_vpr || 0),
                medium: this.calculateTrend(previous.medium_vpr || 0, latest.medium_vpr || 0),
                low: this.calculateTrend(previous.low_vpr || 0, latest.low_vpr || 0)
            };
            
            Object.keys(trends).forEach(severity => {
                const element = document.getElementById(`${severity}Trend`);
                if (element) {
                    const trend = trends[severity];
                    element.className = `trend-indicator trend-${trend.direction}`;
                    element.innerHTML = `<i class="fas fa-arrow-${trend.direction === "up" ? "up" : "down"} me-1"></i>${trend.direction === "up" ? "+" : ""}${trend.percentage}%`;
                }
            });
        } else {
            const trends = {
                critical: Math.random() > 0.5 ? "up" : "down",
                high: Math.random() > 0.5 ? "up" : "down",
                medium: Math.random() > 0.5 ? "up" : "down",
                low: Math.random() > 0.5 ? "up" : "down"
            };

            Object.keys(trends).forEach(severity => {
                const element = document.getElementById(`${severity}Trend`);
                if (element) {
                    const isUp = trends[severity] === "up";
                    const percentage = Math.floor(Math.random() * 20) + 1;
                    
                    element.className = `trend-indicator trend-${trends[severity]}`;
                    element.innerHTML = `<i class="fas fa-arrow-${isUp ? "up" : "down"} me-1"></i>${isUp ? "+" : "-"}${percentage}%`;
                }
            });
        }
    }

    calculateTrend(previous, current) {
        if (previous === 0 && current === 0) {
            return { direction: "stable", percentage: "0" };
        }
        if (previous === 0) {
            return { direction: "up", percentage: "100" };
        }
        
        const percentChange = ((current - previous) / previous) * 100;
        if (Math.abs(percentChange) < 1) {
            return { direction: "stable", percentage: "0" };
        }
        
        return {
            direction: percentChange > 0 ? "up" : "down",
            percentage: Math.abs(percentChange).toFixed(1)
        };
    }

    flipStatCards() {
        const cards = document.querySelectorAll(".stat-card-enhanced");
        
        cards.forEach(card => {
            const cardFront = card.querySelector(".card-front");
            const cardBack = card.querySelector(".card-back");
            
            if (cardFront && cardBack) {
                if (cardFront.style.display !== "none") {
                    cardFront.style.display = "none";
                    cardBack.style.display = "block";
                    this.currentMetricType = "vpr";
                } else {
                    cardFront.style.display = "block";
                    cardBack.style.display = "none";
                    this.currentMetricType = "count";
                }
            }
        });
        
        this.updateStatisticsDisplay();
    }

    extendTimelineData(originalData) {
        if (!originalData || originalData.length === 0) {return [];}
        
        const sortedData = [...originalData].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        const earliestDate = new Date(sortedData[0].date);
        const latestDate = new Date(sortedData[sortedData.length - 1].date);
        const currentDate = new Date();
        
        const backwardExtensionDays = 14;
        const extendedStartDate = new Date(earliestDate);
        extendedStartDate.setDate(extendedStartDate.getDate() - backwardExtensionDays);
        
        const extendedData = [];
        
        const earliestValues = sortedData[0];
        let currentExtensionDate = new Date(extendedStartDate);
        
        while (currentExtensionDate < earliestDate) {
            extendedData.push({
                date: currentExtensionDate.toISOString().split("T")[0],
                Critical: earliestValues.Critical,
                High: earliestValues.High,
                Medium: earliestValues.Medium,
                Low: earliestValues.Low,
                isExtended: true,
                extensionType: "backward",
                hasActualData: false
            });
            currentExtensionDate.setDate(currentExtensionDate.getDate() + 1);
        }
        
        sortedData.forEach(dataPoint => {
            extendedData.push({
                ...dataPoint,
                isExtended: false,
                extensionType: "actual",
                hasActualData: true
            });
        });
        
        const latestValues = sortedData[sortedData.length - 1];
        currentExtensionDate = new Date(latestDate);
        currentExtensionDate.setDate(currentExtensionDate.getDate() + 1);
        
        while (currentExtensionDate <= currentDate) {
            extendedData.push({
                date: currentExtensionDate.toISOString().split("T")[0],
                Critical: latestValues.Critical,
                High: latestValues.High,
                Medium: latestValues.Medium,
                Low: latestValues.Low,
                isExtended: true,
                extensionType: "forward",
                hasActualData: false
            });
            currentExtensionDate.setDate(currentExtensionDate.getDate() + 1);
        }
        
        return extendedData;
    }

    updateChart() {
        if (!this.chart || this.historicalData.length === 0) {return;}

        const checkedInput = document.querySelector("input[name=\"chart-metric\"]:checked");
        const associatedLabel = checkedInput ? document.querySelector(`label[for="${checkedInput.id}"]`) : null;
        const metricType = associatedLabel?.dataset?.metric || "vpr";
        
        const extendedData = this.extendTimelineData(this.historicalData);
        
        const series = ["Critical", "High", "Medium", "Low"].map((severity, _index) => {
            const seriesData = extendedData.map(point => {
                let value;
                if (typeof point[severity] === "object" && point[severity] !== null) {
                    value = metricType === "vpr" ? point[severity].total_vpr : point[severity].count;
                } else {
                    value = point[severity] || 0;
                }
                
                return {
                    x: new Date(point.date).getTime(),
                    y: value || 0,
                    hasActualData: point.hasActualData
                };
            });

            return {
                name: severity,
                data: seriesData
            };
        });

        this.chart.updateSeries(series);

        setTimeout(() => {
            if (this.chart && this.chart.resetSeries) {
                this.chart.zoomX(undefined, undefined);
            }
        }, 100);

        const colors = ["#dc2626", "#ea580c", "#2563eb", "#16a34a"];
        
        this.chart.updateOptions({
            markers: {
                discrete: extendedData.flatMap((point, pointIndex) => {
                    if (!point.hasActualData) {return [];}
                    
                    return ["Critical", "High", "Medium", "Low"].map((severity, seriesIndex) => ({
                        seriesIndex: seriesIndex,
                        dataPointIndex: pointIndex,
                        fillColor: colors[seriesIndex],
                        strokeColor: "#ffffff",
                        size: 6,
                        strokeWidth: 2
                    }));
                })
            }
        });

        const chartTitle = metricType === "vpr" ? 
            "Vulnerability VPR Score Trends Over Time" : 
            "Vulnerability Count Trends Over Time";
        
        const yAxisTitle = metricType === "vpr" ? 
            "Cumulative VPR Score Total" : 
            "Cumulative Vulnerability Count";
            
        this.chart.updateOptions({
            title: {
                text: chartTitle
            },
            yaxis: {
                title: {
                    text: yAxisTitle
                },
                min: 0,
                labels: {
                    formatter: function (val) {
                        if (metricType === "vpr") {
                            return val.toFixed(2);
                        } else {
                            return val % 1 === 0 ? val.toString() : val.toFixed(0);
                        }
                    }
                }
            },
            tooltip: {
                shared: true,
                intersect: false,
                custom: function({series, seriesIndex: _seriesIndex, dataPointIndex, w: _w}) {
                    const point = extendedData[dataPointIndex];
                    if (!point || !point.hasActualData) {
                        return "<div></div>";
                    }

                    const date = new Date(point.date).toLocaleDateString();
                    let tooltipContent = `<div class="apexcharts-tooltip-custom">
                        <div class="tooltip-date">${date}</div>`;
                    
                    ["Critical", "High", "Medium", "Low"].forEach((severity, index) => {
                        const value = series[index][dataPointIndex];
                        const color = colors[index];
                        const label = metricType === "vpr" ? `${value.toFixed(2)} VPR points` : `${value} vulnerabilities`;
                        
                        tooltipContent += `
                            <div class="tooltip-series">
                                <span style="color: ${color};">â—</span>
                                <span class="tooltip-severity">${severity}:</span>
                                <span class="tooltip-value">${label}</span>
                            </div>`;
                    });
                    
                    tooltipContent += "</div>";
                    return tooltipContent;
                }
            }
        });

        if (this.historicalData.length > 0) {
            const actualDataPoints = extendedData.filter(point => point.hasActualData);
            if (actualDataPoints.length > 0) {
                const latestActualDate = new Date(actualDataPoints[actualDataPoints.length - 1].date);
                const fourteenDaysAgo = new Date(latestActualDate.getTime() - (14 * 24 * 60 * 60 * 1000));
                
                this.chart.zoomX(fourteenDaysAgo.getTime(), latestActualDate.getTime());
            }
        }
    }

    filterData() {
        const searchTerm = document.getElementById("searchInput").value.toLowerCase();
        const severityFilter = document.getElementById("severityFilter").value;

        this.filteredVulnerabilities = this.vulnerabilities.filter(vuln => {
            const matchesSearch = !searchTerm || 
                vuln.hostname.toLowerCase().includes(searchTerm) ||
                vuln.cve.toLowerCase().includes(searchTerm) ||
                vuln.plugin_name.toLowerCase().includes(searchTerm);
            
            const matchesSeverity = !severityFilter || vuln.severity === severityFilter;
            
            return matchesSearch && matchesSeverity;
        });

        if (this.gridApi) {
            this.gridApi.setGridOption("rowData", this.filteredVulnerabilities);
        }

        this.updateCurrentView();
    }

    switchView(viewType) {
        const radioButton = document.getElementById(`view-${viewType}`);
        if (radioButton) {
            radioButton.checked = true;
        }

        document.querySelectorAll(".view-content").forEach(view => {
            view.classList.add("d-none");
        });

        document.getElementById(`${viewType}View`).classList.remove("d-none");
        
        this.currentView = viewType;
        this.updateCurrentView();
    }

    updateCurrentView() {
        switch (this.currentView) {
            case "table":
                if (this.gridApi) {
                    this.gridApi.setRowData(this.filteredVulnerabilities);
                }
                break;
            case "devices":
                this.renderDeviceCards();
                break;
            case "vulnerabilities":
                this.renderVulnerabilityCards();
                break;
        }
    }

    renderDeviceCards() {
        const container = document.getElementById("deviceCards");
        const filteredDevices = this.devices.filter(device => {
            const searchTerm = document.getElementById("searchInput").value.toLowerCase();
            return !searchTerm || device.hostname.toLowerCase().includes(searchTerm);
        });

        // Sort devices by total VPR score (high to low)
        filteredDevices.sort((a, b) => {
            const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
            const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
            return bTotalVPR - aTotalVPR;
        });

        // Update pagination with filtered count
        this.devicePagination.setTotalItems(filteredDevices.length);
        
        // Get current page data
        const paginatedDevices = this.devicePagination.getCurrentPageData(filteredDevices);

        container.innerHTML = paginatedDevices.map(device => {
            const criticalVPR = device.criticalVPR || 0;
            const highVPR = device.highVPR || 0;
            const mediumVPR = device.mediumVPR || 0;
            const lowVPR = device.lowVPR || 0;
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card device-card">
                    <div class="card-body">
                        <div class="device-hostname">
                            <i class="fas fa-server me-2 text-primary"></i>
                            ${device.hostname}
                        </div>
                        
                        <div class="device-stats">
                            <div>
                                <div class="text-muted small">Total Vulnerabilities</div>
                                <div class="fw-bold">${device.totalCount}</div>
                            </div>
                            <div class="text-end">
                                <div class="text-muted small">Total VPR</div>
                                <div class="device-total-vpr">${totalVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${device.criticalCount}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${device.highCount}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${device.mediumCount}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${device.lowCount}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="card-actions">
                            <button class="btn btn-primary" 
                                    onclick="vulnManager.viewDeviceDetails('${device.hostname}')">
                                <i class="fas fa-eye me-1"></i>View Device Details
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;}).join("");

        // Render pagination controls
        this.devicePagination.renderPaginationControls(
            "devicePaginationControls",
            () => this.renderDeviceCards(),
            () => this.renderDeviceCards()
        );

        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }

    renderVulnerabilityCards() {
        const container = document.getElementById("vulnerabilityCards");
        const groupedVulns = this.groupVulnerabilitiesByCVE();
        
        // Sort vulnerability groups by total VPR score (high to low)
        const sortedVulnEntries = Object.entries(groupedVulns).sort(([,vulnsA], [,vulnsB]) => {
            const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            return totalVPRB - totalVPRA;
        });

        // Update pagination with total count
        this.vulnerabilityPagination.setTotalItems(sortedVulnEntries.length);
        
        // Get current page data
        const paginatedVulnEntries = this.vulnerabilityPagination.getCurrentPageData(sortedVulnEntries);

        container.innerHTML = paginatedVulnEntries.map(([cve, vulns]) => {
            const criticalVulns = vulns.filter(v => v.severity === "Critical");
            const highVulns = vulns.filter(v => v.severity === "High");
            const mediumVulns = vulns.filter(v => v.severity === "Medium");
            const lowVulns = vulns.filter(v => v.severity === "Low");
            
            const criticalVPR = criticalVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const highVPR = highVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const mediumVPR = mediumVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const lowVPR = lowVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            const primaryVuln = vulns[0];
            const description = primaryVuln.description || primaryVuln.plugin_name || "No description available";
            
            // Create a safe data attribute for the vulnerability data
            const vulnDataId = `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            // Store the vulnerability data temporarily for modal access
            window.vulnModalData = window.vulnModalData || {};
            window.vulnModalData[vulnDataId] = primaryVuln;

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card vulnerability-card" style="cursor: pointer;" data-vuln-id="${vulnDataId}" onclick="vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                    <div class="card-body">
                        <div class="vulnerability-title">
                            ${description.substring(0, 100)}${description.length > 100 ? "..." : ""}
                        </div>
                        
                        <div class="vulnerability-meta">
                            <div>
                                ${cve && cve.startsWith("CVE-") ? `
                                    <a href="#" class="vulnerability-cve" 
                                       onclick="event.stopPropagation(); vulnManager.lookupCVE('${cve}');">
                                        ${cve}
                                    </a>
                                ` : `
                                    <span class="text-muted">Plugin ${primaryVuln.plugin_id}</span>
                                `}
                            </div>
                            <div class="text-end">
                                <div class="vulnerability-vpr text-primary">
                                    ${totalVPR.toFixed(1)}
                                </div>
                                <div class="text-muted small">Total VPR</div>
                            </div>
                        </div>

                        <div class="mb-3">
                            <span class="badge severity-${primaryVuln.severity.toLowerCase()}">
                                ${primaryVuln.severity}
                            </span>
                            <span class="text-muted ms-2">
                                <i class="fas fa-server me-1"></i>
                                ${vulns.length} device${vulns.length !== 1 ? "s" : ""}
                            </span>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${criticalVulns.length}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${highVulns.length}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${mediumVulns.length}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${lowVulns.length}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        ${cve && cve.startsWith("CVE-") ? `
                            <div class="card-actions">
                                <button class="btn btn-outline-primary btn-sm w-100" 
                                        onclick="event.stopPropagation(); vulnManager.lookupCVE('${cve}')">
                                    <i class="fas fa-external-link-alt me-1"></i>Lookup CVE Details
                                </button>
                            </div>
                        ` : `
                            <div class="card-actions">
                                <button class="btn btn-outline-info btn-sm w-100" onclick="event.stopPropagation(); vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                                    <i class="fas fa-info-circle me-1"></i>Click for Details
                                </button>
                            </div>
                        `}
                    </div>
                </div>
            </div>
        `;}).join("");

        // Render pagination controls
        this.vulnerabilityPagination.renderPaginationControls(
            "vulnerabilityPaginationControls",
            () => this.renderVulnerabilityCards(),
            () => this.renderVulnerabilityCards()
        );

        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }

    groupVulnerabilitiesByCVE() {
        const grouped = {};
        this.filteredVulnerabilities.forEach(vuln => {
            const key = vuln.cve || `plugin_${vuln.plugin_id}`;
            if (!grouped[key]) {
                grouped[key] = [];
            }
            grouped[key].push(vuln);
        });
        return grouped;
    }

    viewDeviceDetails(hostname) {
        const device = this.devices.find(d => d.hostname === hostname);
        if (!device) {return;}

        document.getElementById("deviceInfo").innerHTML = `
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Hostname:</div>
                    <div class="col-sm-8 fw-bold">${device.hostname}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Total Risks:</div>
                    <div class="col-sm-8">
                        <span class="badge bg-secondary">${device.totalCount} vulnerabilities</span>
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Total VPR:</div>
                    <div class="col-sm-8">
                        <span class="h5 text-danger fw-bold">${(device.totalVPR || 0).toFixed(1)}</span>
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Risk Level:</div>
                    <div class="col-sm-8">
                        ${device.criticalCount > 0 ? "<span class=\"badge bg-red\">Critical Risk</span>" :
                          device.highCount > 5 ? "<span class=\"badge bg-orange\">High Risk</span>" :
                          device.mediumCount > 10 ? "<span class=\"badge bg-yellow\">Medium Risk</span>" :
                          "<span class=\"badge bg-green\">Low Risk</span>"}
                    </div>
                </div>
            </div>
        `;

        document.getElementById("deviceVprSummary").innerHTML = `
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-red h3 mb-1">${device.criticalCount}</div>
                        <div class="text-muted small">Critical</div>
                        <div class="text-red fw-bold">${(device.criticalVPR || 0).toFixed(1)}</div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-orange h3 mb-1">${device.highCount}</div>
                        <div class="text-muted small">High</div>
                        <div class="text-orange fw-bold">${(device.highVPR || 0).toFixed(1)}</div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-yellow h3 mb-1">${device.mediumCount}</div>
                        <div class="text-muted small">Medium</div>
                        <div class="text-yellow fw-bold">${(device.mediumVPR || 0).toFixed(1)}</div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-green h3 mb-1">${device.lowCount}</div>
                        <div class="text-muted small">Low</div>
                        <div class="text-green fw-bold">${(device.lowVPR || 0).toFixed(1)}</div>
                    </div>
                </div>
            </div>
        `;

        const deviceGridDiv = document.getElementById("device-vuln-grid");
        deviceGridDiv.innerHTML = "";

        const deviceColumnDefs = [
            {
                headerName: "CVE",
                field: "cve",
                width: 140,
                cellRenderer: (params) => {
                    const cve = params.value;
                    if (cve && cve.startsWith("CVE-")) {
                        return `<a href="#" class="text-primary text-decoration-none" onclick="vulnManager.lookupCVE('${cve}')">${cve}</a>`;
                    }
                    return cve || "N/A";
                }
            },
            {
                headerName: "VPR",
                field: "vpr_score",
                width: 80,
                cellRenderer: (params) => {
                    const score = params.value || 0;
                    const color = score >= 9 ? "text-danger" : score >= 7 ? "text-warning" : score >= 4 ? "text-info" : "text-success";
                    return `<span class="${color} fw-bold">${score.toFixed(1)}</span>`;
                }
            },
            {
                headerName: "Severity",
                field: "severity",
                width: 100,
                cellRenderer: (params) => {
                    const severity = params.value || "Low";
                    const className = `severity-${severity.toLowerCase()}`;
                    return `<span class="severity-badge ${className}">${severity}</span>`;
                }
            },
            { headerName: "Plugin Name", field: "plugin_name", flex: 1 },
            {
                headerName: "First Seen",
                field: "first_seen",
                width: 120,
                cellRenderer: (params) => {
                    return params.value ? new Date(params.value).toLocaleDateString() : "N/A";
                }
            }
        ];

        const deviceGridOptions = {
            columnDefs: deviceColumnDefs,
            rowData: device.vulnerabilities,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 25,
            animateRows: true
        };

        new agGrid.Grid(deviceGridDiv, deviceGridOptions);

        const modal = new bootstrap.Modal(document.getElementById("deviceModal"));
        modal.show();
    }

    viewVulnerabilityDetails(vulnerabilityId) {
        // Handle both old direct object calls and new ID-based calls
        let vulnerability;
        if (typeof vulnerabilityId === "string") {
            // New approach: get vulnerability from temporary storage
            vulnerability = window.vulnModalData && window.vulnModalData[vulnerabilityId];
        } else {
            // Legacy approach: direct object passed
            vulnerability = vulnerabilityId;
        }
        
        if (!vulnerability) {
            console.error("Vulnerability data not found");
            return;
        }

        document.getElementById("vulnerabilityInfo").innerHTML = `
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">CVE ID:</div>
                    <div class="col-sm-8">
                        <a href="#" class="text-primary text-decoration-none fw-bold" 
                           onclick="vulnManager.lookupCVE('${vulnerability.cve}')">${vulnerability.cve}</a>
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Plugin Name:</div>
                    <div class="col-sm-8 fw-bold">${vulnerability.plugin_name || "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Description:</div>
                    <div class="col-sm-8">${vulnerability.description || vulnerability.plugin_name || "No description available"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Solution:</div>
                    <div class="col-sm-8">${vulnerability.solution || "No solution provided"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">First Seen:</div>
                    <div class="col-sm-8">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString() : "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Port:</div>
                    <div class="col-sm-8">
                        <span class="badge bg-secondary">${vulnerability.port || "N/A"}</span>
                    </div>
                </div>
            </div>
        `;

        const vprScore = vulnerability.vpr_score || 0;
        const severity = vulnerability.severity || "Low";
        const severityColor = severity === "Critical" ? "red" : 
                            severity === "High" ? "orange" : 
                            severity === "Medium" ? "yellow" : "green";
        
        document.getElementById("vulnerabilityRiskSummary").innerHTML = `
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-${vprScore >= 9 ? "red" : vprScore >= 7 ? "orange" : vprScore >= 4 ? "yellow" : "green"} h2 mb-1">${vprScore.toFixed(1)}</div>
                        <div class="text-muted small">VPR Score</div>
                        <div class="text-muted small mt-1">
                            ${vprScore >= 9 ? "Critical Risk" : vprScore >= 7 ? "High Risk" : vprScore >= 4 ? "Medium Risk" : "Low Risk"}
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-${severityColor} h3 mb-1">${severity}</div>
                        <div class="text-muted small">Severity</div>
                        <div class="text-muted small mt-1">CVSS Based</div>
                    </div>
                </div>
            </div>
        `;

        const affectedAssets = this.vulnerabilities.filter(v => v.cve === vulnerability.cve);
        document.getElementById("affectedAssetsCount").textContent = `${affectedAssets.length} assets`;

        const assetsGridDiv = document.getElementById("vulnerabilityAssetsGrid");
        assetsGridDiv.innerHTML = "";

        const assetsColumnDefs = [
            {
                headerName: "Hostname",
                field: "hostname",
                width: 200,
                cellRenderer: (params) => {
                    const hostname = params.value;
                    return `<a href="#" class="text-primary text-decoration-none fw-bold" onclick="vulnManager.viewDeviceDetails('${hostname}')">${hostname}</a>`;
                }
            },
            {
                headerName: "Port",
                field: "port",
                width: 100,
                cellRenderer: (params) => {
                    return `<span class="badge bg-secondary">${params.value || "N/A"}</span>`;
                }
            },
            {
                headerName: "First Seen",
                field: "first_seen",
                width: 150,
                cellRenderer: (params) => {
                    return params.value ? new Date(params.value).toLocaleDateString() : "N/A";
                }
            },
            {
                headerName: "Last Seen",
                field: "last_seen",
                width: 150,
                cellRenderer: (params) => {
                    const lastSeen = params.data.last_seen;
                    const scanDate = params.data.scan_date;
                    
                    if (lastSeen && lastSeen.trim() !== "") {
                        return new Date(lastSeen).toLocaleDateString();
                    } else if (scanDate && scanDate.trim() !== "") {
                        return new Date(scanDate).toLocaleDateString();
                    }
                    return "N/A";
                }
            },
            { headerName: "Plugin Output", field: "plugin_output", flex: 1 }
        ];

        const assetsGridOptions = {
            columnDefs: assetsColumnDefs,
            rowData: affectedAssets,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 15,
            animateRows: true
        };

        new agGrid.Grid(assetsGridDiv, assetsGridOptions);

        const modal = new bootstrap.Modal(document.getElementById("vulnerabilityModal"));
        modal.show();
    }

    async lookupCVE(cveId) {
        const cveIds = cveId.includes(",") ? cveId.split(",").map(id => id.trim()) 
                                           : cveId.includes(" ") ? cveId.split(" ").filter(id => id.startsWith("CVE-"))
                                           : [cveId.trim()];

        const ciscoClientId = localStorage.getItem("cisco_client_id");
        const ciscoClientSecret = localStorage.getItem("cisco_client_secret");

        if (ciscoClientId && ciscoClientSecret && cveIds.length === 1) {
            await this.lookupCVEWithCiscoAPI(cveIds[0], ciscoClientId, ciscoClientSecret);
        } else {
            this.openCVEPopups(cveIds);
        }
    }

    async lookupCVEWithCiscoAPI(cveId, clientId, clientSecret) {
        try {
            this.showLoading(`Looking up ${cveId} via Cisco PSIRT...`);
            
            const tokenResponse = await fetch("https://id.cisco.com/oauth2/default/v1/token", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Authorization": "Basic " + btoa(`${clientId}:${clientSecret}`)
                },
                body: "grant_type=client_credentials"
            });

            if (tokenResponse.ok) {
                const tokenData = await tokenResponse.json();
                
                const psirtResponse = await fetch(`https://api.cisco.com/security/advisories/cve/${cveId}`, {
                    headers: {
                        "Authorization": `Bearer ${tokenData.access_token}`,
                        "Accept": "application/json"
                    }
                });

                this.hideLoading();

                if (psirtResponse.ok) {
                    const data = await psirtResponse.json();
                    this.displayCVEInfo(cveId, data);
                } else {
                    this.showToast(`No Cisco advisory found for ${cveId}. Opening external lookup...`, "warning");
                    this.openCVEPopups([cveId]);
                }
            } else {
                this.hideLoading();
                this.showToast("Failed to authenticate with Cisco API. Using external lookup...", "warning");
                this.openCVEPopups([cveId]);
            }
        } catch (_error) {
            this.hideLoading();
            this.showToast("Error with Cisco API. Using external lookup...", "warning");
            this.openCVEPopups([cveId]);
        }
    }

    openCVEPopups(cveIds) {
        if (!Array.isArray(cveIds) || cveIds.length === 0) {
            this.showToast("No valid CVE IDs found", "warning");
            return;
        }

        let successCount = 0;
        let blockedCount = 0;

        cveIds.forEach((cveId, index) => {
            if (!cveId.startsWith("CVE-")) {
                return;
            }

            setTimeout(() => {
                const popup = window.open(
                    `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId.trim()}`,
                    `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                    "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes,top=50,left=" + (100 + index * 50)
                );
                
                if (popup) {
                    popup.focus();
                    successCount++;
                } else {
                    blockedCount++;
                }

                if (index === cveIds.length - 1) {
                    setTimeout(() => {
                        if (blockedCount > 0) {
                            this.showToast(`${successCount} CVE lookup(s) opened. ${blockedCount} popup(s) blocked. Please allow popups for full CVE lookups.`, "warning");
                        } else if (successCount > 0) {
                            this.showToast(`${successCount} CVE lookup(s) opened successfully`, "success");
                        }
                    }, 100);
                }
            }, index * 200);
        });
    }

    displayCVEInfo(cveId, data) {
        let message = `CVE Information for ${cveId}:\n\n`;
        if (data.advisories && data.advisories.length > 0) {
            const advisory = data.advisories[0];
            message += `Title: ${advisory.advisoryTitle}\n`;
            message += `Severity: ${advisory.sir}\n`;
            message += `CVSSv3 Score: ${advisory.cvssBaseScore}\n`;
            message += `Publication Date: ${advisory.publicationUrl}\n`;
        }
        alert(message);
    }

    exportData() {
        const dataToExport = this.filteredVulnerabilities;
        const csv = Papa.unparse(dataToExport);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Data exported successfully!", "success");
    }

    async refreshData() {
        this.showLoading("Refreshing data...");
        await new Promise(resolve => setTimeout(resolve, 1000));
        await this.loadData();
        this.hideLoading();
        this.showToast("Data refreshed successfully!", "success");
    }

    async fetchTenableHistoricalData() {
        const tenableApiKey = localStorage.getItem("tenable_api_key");
        const tenableSecretKey = localStorage.getItem("tenable_secret_key");
        
        if (!tenableApiKey || !tenableSecretKey) {
            this.showToast("Tenable API credentials not configured", "warning");
            return;
        }
        
        try {
            this.showLoading("Fetching historical VPR data from Tenable...");
            
            const response = await fetch(`${this.apiBase}/tenable/historical-vpr`, {
                headers: {
                    "X-Tenable-Api-Key": tenableApiKey,
                    "X-Tenable-Secret-Key": tenableSecretKey
                }
            });
            
            this.hideLoading();
            
            if (response.ok) {
                const data = await response.json();
                this.showToast(`Fetched ${data.count} historical VPR records`, "success");
                
                await this.loadData();
            } else {
                const error = await response.json();
                this.showToast("Failed to fetch Tenable data: " + error.error, "danger");
            }
        } catch (error) {
            this.hideLoading();
            this.showToast("Error fetching Tenable data: " + error.message, "danger");
        }
    }

    showClearDataConfirmation() {
        if (confirm("Are you sure you want to clear all vulnerability data? This action cannot be undone.")) {
            this.clearAllData();
        }
    }

    async clearAllData() {
        try {
            this.showLoading("Clearing all data...");
            
            const response = await fetch(`${this.apiBase}/vulnerabilities/clear`, {
                method: "DELETE"
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Clear operation failed");
            }

            this.showLoading("Updating display...");
            
            await this.loadData();
            
            this.hideLoading();
            
            this.showToast("All vulnerability data cleared successfully!", "success");
        } catch (error) {
            this.hideLoading();
            console.error("Error clearing data:", error);
            this.showToast("Error clearing data: " + error.message, "danger");
        }
    }

    showLoading(message) {
        this.hideLoading();
        
        const toastHtml = `
            <div class="toast show position-fixed top-0 end-0 m-3" id="progressToast" style="z-index: 9999;">
                        <div class="toast-header bg-primary text-white">
                            <div class="spinner-border spinner-border-sm me-2" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <strong class="me-auto">Processing</strong>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
                        </div>
                        <div class="toast-body">${message}</div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML("beforeend", toastHtml);
                
                setTimeout(() => this.hideLoading(), 10000);
    }

    hideLoading() {
        const toast = document.getElementById("progressToast");
        if (toast) {
            toast.remove();
        }
        
        document.querySelectorAll(".modal-backdrop").forEach(el => el.remove());
        document.body.classList.remove("modal-open");
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
    }

    showToast(message, type) {
        const toastContainer = document.getElementById("toastContainer") || this.createToastContainer();
        const toastId = "toast_" + Date.now();
        
        const toastHtml = `
            <div class="toast align-items-center text-bg-${type} border-0" role="alert" id="${toastId}">
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;
        
        toastContainer.insertAdjacentHTML("beforeend", toastHtml);
        
        const toastElement = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastElement);
        toast.show();
        
        toastElement.addEventListener("hidden.bs.toast", () => {
            toastElement.remove();
        });
    }

    createToastContainer() {
        const container = document.createElement("div");
        container.id = "toastContainer";
        container.className = "toast-container position-fixed bottom-0 end-0 p-3";
        container.style.zIndex = "9999";
        document.body.appendChild(container);
        return container;
    }

    editVulnerability(id) {
        const vuln = this.vulnerabilities[id] || this.filteredVulnerabilities[id];
        if (!vuln) {
            this.showToast("Vulnerability not found", "danger");
            return;
        }

        document.getElementById("editVulnId").value = id;
        document.getElementById("editHostname").value = vuln.hostname || "";
        document.getElementById("editIpAddress").value = vuln.ip_address || "";
        document.getElementById("editSeverity").value = vuln.severity || "";
        document.getElementById("editState").value = vuln.state || "open";
        document.getElementById("editNotes").value = vuln.notes || "";

        const modal = new bootstrap.Modal(document.getElementById("editVulnModal"));
        modal.show();
    }

    async saveVulnerabilityChanges() {
        const id = document.getElementById("editVulnId").value;
        const formData = {
            hostname: document.getElementById("editHostname").value,
            ip_address: document.getElementById("editIpAddress").value,
            severity: document.getElementById("editSeverity").value,
            state: document.getElementById("editState").value,
            notes: document.getElementById("editNotes").value
        };

        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                this.showToast("Vulnerability updated successfully!", "success");
                await this.loadData();
                bootstrap.Modal.getInstance(document.getElementById("editVulnModal")).hide();
            } else {
                this.showToast("Failed to update vulnerability", "danger");
            }
        } catch (error) {
            this.showToast("Error updating vulnerability: " + error.message, "danger");
        }
    }

    async deleteVulnerability(id) {
        if (!confirm("Are you sure you want to delete this vulnerability? This action cannot be undone.")) {
            return;
        }

        try {
            const response = await fetch(`${this.apiBase}/vulnerabilities/${id}`, {
                method: "DELETE"
            });

            if (response.ok) {
                this.showToast("Vulnerability deleted successfully!", "success");
                await this.loadData();
            } else {
                this.showToast("Failed to delete vulnerability", "danger");
            }
        } catch (error) {
            this.showToast("Error deleting vulnerability: " + error.message, "danger");
        }
    }

    async refreshVulnerability(id) {
        const vuln = this.vulnerabilities[id] || this.filteredVulnerabilities[id];
        if (!vuln) {
            this.showToast("Vulnerability not found", "danger");
            return;
        }

        this.showToast("Refreshing vulnerability data...", "info");
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        this.showToast("Vulnerability data refreshed!", "success");
    }

    exportDeviceReport(hostname) {
        const device = this.devices.find(d => d.hostname === hostname);
        if (!device) {return;}

        const csvData = device.vulnerabilities.map(vuln => ({
            "Device": hostname,
            "CVE": vuln.cve || "N/A",
            "VPR Score": vuln.vpr_score || 0,
            "Severity": vuln.severity,
            "Plugin Name": vuln.plugin_name,
            "Port": vuln.port || "N/A",
            "First Seen": vuln.first_seen ? new Date(vuln.first_seen).toLocaleDateString() : "N/A",
            "Last Seen": vuln.last_seen && vuln.last_seen.trim() !== "" 
                ? new Date(vuln.last_seen).toLocaleDateString() 
                : (vuln.scan_date && vuln.scan_date.trim() !== "" 
                    ? new Date(vuln.scan_date).toLocaleDateString() 
                    : "N/A")
        }));

        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `device_${hostname}_vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Device report exported for ${hostname}`, "success");
    }

    exportVulnerabilityReport() {
        const modal = document.getElementById("vulnerabilityModal");
        if (!modal.classList.contains("show")) {return;}

        const vulnTitle = modal.querySelector(".modal-title").textContent;
        const vulnInfo = modal.querySelector("#vulnerabilityInfo").innerHTML;
        
        const reportContent = `
            ${vulnTitle}\n
                    Generated: ${new Date().toLocaleString()}\n
                    ${vulnInfo.replace(/<[^>]*>/g, "").replace(/&nbsp;/g, " ")}
                `;

        const blob = new Blob([reportContent], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerability_report_${new Date().toISOString().split("T")[0]}.txt`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Vulnerability report exported", "success");
    }

    generateDevicePDF(_hostname) {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    generateVulnerabilityPDF() {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    exportDeviceData() {
        const modal = document.getElementById("deviceModal");
        if (!modal.classList.contains("show")) {
            this.showToast("No device modal is currently open", "warning");
            return;
        }

        const modalTitle = modal.querySelector(".modal-title").textContent;
        const hostname = modalTitle.replace("Device Security Overview", "").replace(/[^a-zA-Z0-9.-]/g, "").trim();
        
        const device = this.devices.find(d => d.hostname.includes(hostname) || hostname.includes(d.hostname));
        if (!device) {
            this.showToast("Could not find device data for export", "error");
            return;
        }

        const deviceSummary = {
            "Device Hostname": device.hostname,
            "Total Vulnerabilities": device.vulnerabilities.length,
            "Critical VPR": (device.criticalVPR || 0).toFixed(1),
            "High VPR": (device.highVPR || 0).toFixed(1),
            "Medium VPR": (device.mediumVPR || 0).toFixed(1),
            "Low VPR": (device.lowVPR || 0).toFixed(1),
            "Total VPR": (device.totalVPR || 0).toFixed(1),
            "Export Date": new Date().toLocaleString(),
            "Generated By": "HexTrackr Vulnerability Management System"
        };

        const vulnerabilityData = device.vulnerabilities.map(vuln => ({
            "CVE": vuln.cve || "N/A",
            "VPR Score": vuln.vpr_score || 0,
            "Severity": vuln.severity || "Low",
            "Plugin Name": vuln.plugin_name || "Unknown",
            "Description": vuln.description || vuln.plugin_name || "No description",
            "Solution": vuln.solution || "No solution provided",
            "Port": vuln.port || "N/A",
            "Protocol": vuln.protocol || "N/A",
            "First Seen": vuln.first_seen ? new Date(vuln.first_seen).toLocaleDateString() : "N/A",
            "Last Seen": vuln.last_seen && vuln.last_seen.trim() !== "" 
                ? new Date(vuln.last_seen).toLocaleDateString() 
                : (vuln.scan_date && vuln.scan_date.trim() !== "" 
                    ? new Date(vuln.scan_date).toLocaleDateString() 
                    : "N/A"),
            "Plugin Output": vuln.plugin_output || "No output available"
        }));

        let csvContent = "";
        
        csvContent += "DEVICE SECURITY OVERVIEW\n";
        csvContent += "========================\n\n";
        Object.entries(deviceSummary).forEach(([key, value]) => {
            csvContent += `${key},${value}\n`;
        });
        
        csvContent += "\n\nVULNERABILITY DETAILS\n";
        csvContent += "====================\n\n";
        
        csvContent += Papa.unparse(vulnerabilityData);

        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `device_${device.hostname}_comprehensive_report_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Comprehensive device data exported for ${device.hostname}`, "success");
    }

    generateDeviceReport() {
        const modal = document.getElementById("deviceModal");
        if (!modal.classList.contains("show")) {
            this.showToast("No device modal is currently open", "warning");
            return;
        }

        const modalTitle = modal.querySelector(".modal-title").textContent;
        const hostname = modalTitle.replace("Device Security Overview", "").replace(/[^a-zA-Z0-9.-]/g, "").trim();
        
        const device = this.devices.find(d => d.hostname.includes(hostname) || hostname.includes(d.hostname));
        if (!device) {
            this.showToast("Could not find device data for report generation", "error");
            return;
        }

        const reportHtml = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Device Security Report - ${device.hostname}</title>
            <link href="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/css/tabler.min.css" rel="stylesheet">
            <style>
                body { font-family: 'Segoe UI', sans-serif; margin: 20px; }
                .report-header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #206bc4; padding-bottom: 20px; }
                .summary-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 30px; }
                .stat-card { background: #f8fafc; padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #e2e8f0; }
                .vuln-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                .vuln-table th, .vuln-table td { padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; }
                .vuln-table th { background: #206bc4; color: white; }
                .severity-critical { color: #dc3545; font-weight: bold; }
                .severity-high { color: #fd7e14; font-weight: bold; }
                .severity-medium { color: #ffc107; font-weight: bold; }
                .severity-low { color: #198754; font-weight: bold; }
                .footer { margin-top: 40px; text-align: center; color: #6c757d; font-size: 0.9em; }
            </style>
        </head>
        <body>
            <div class="report-header">
                <h1>ðŸ›¡ï¸ Device Security Report</h1>
                <h2>${device.hostname}</h2>
                <p>Generated on ${new Date().toLocaleString()} by HexTrackr</p>
            </div>

            <div class="summary-stats">
                <div class="stat-card">
                    <h3 class="severity-critical">${device.criticalCount || 0}</h3>
                    <p>Critical<br>VPR: ${(device.criticalVPR || 0).toFixed(1)}</p>
                </div>
                <div class="stat-card">
                    <h3 class="severity-high">${device.highCount || 0}</h3>
                    <p>High<br>VPR: ${(device.highVPR || 0).toFixed(1)}</p>
                </div>
                <div class="stat-card">
                    <h3 class="severity-medium">${device.mediumCount || 0}</h3>
                    <p>Medium<br>VPR: ${(device.mediumVPR || 0).toFixed(1)}</p>
                </div>
                <div class="stat-card">
                    <h3 class="severity-low">${device.lowCount || 0}</h3>
                    <p>Low<br>VPR: ${(device.lowVPR || 0).toFixed(1)}</p>
                </div>
            </div>

            <h3>ðŸ“Š Total Risk Score: ${(device.totalVPR || 0).toFixed(1)} VPR</h3>

            <table class="vuln-table">
                <thead>
                    <tr>
                        <th>CVE</th>
                        <th>VPR Score</th>
                        <th>Severity</th>
                        <th>Plugin Name</th>
                        <th>Port</th>
                        <th>First Seen</th>
                    </tr>
                </thead>
                <tbody>
                    ${device.vulnerabilities.map(vuln => `
                        <tr>
                            <td>${vuln.cve || "N/A"}</td>
                            <td><strong>${vuln.vpr_score || 0}</strong></td>
                            <td class="severity-${(vuln.severity || "low").toLowerCase()}">${vuln.severity || "Low"}</td>
                            <td>${vuln.plugin_name || "Unknown"}</td>
                            <td>${vuln.port || "N/A"}</td>
                            <td>${vuln.first_seen ? new Date(vuln.first_seen).toLocaleDateString() : "N/A"}</td>
                        </tr>
                    `).join("")}
                </tbody>
            </table>

            <div class="footer">
                <p>This report contains ${device.vulnerabilities.length} vulnerabilities detected for ${device.hostname}</p>
                <p>Generated by HexTrackr Vulnerability Management System</p>
            </div>
        </body>
        </html>
        `;

        const blob = new Blob([reportHtml], { type: "text/html;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `device_${device.hostname}_security_report_${new Date().toISOString().split("T")[0]}.html`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`HTML security report generated for ${device.hostname}`, "success");
    }
}