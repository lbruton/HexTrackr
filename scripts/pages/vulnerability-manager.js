 
// eslint-disable-file
/* eslint-env browser, es6 */
/* global bootstrap, agGrid, Papa, Sortable, createVulnerabilityGridOptions, PaginationController, VulnerabilityDataManager, VulnerabilityStatisticsManager, VulnerabilityChartManager, window, document, console, setTimeout, FormData, fetch, confirm, localStorage, Blob, URL, btoa, alert */
/* exported ModernVulnManager */
 

/**
 * @fileoverview
 * This file defines the ModernVulnManager class, the core of the HexTrackr
 * vulnerability management dashboard. It handles all client-side logic, including:
 * - Data fetching, processing, and caching from the backend API.
 * - Initialization and management of the AG Grid for tabular data display.
 * - Rendering and updating of the ApexCharts for historical trend visualization.
 * - User interactions such as searching, filtering, and view switching.
 * - Modal dialogs for device details, vulnerability information, and CSV imports.
 * - Data import/export functionality.
 *
 * @version 2.0.0
 * @author Gemini
 * @date 2025-09-03
 */

// Note: PaginationController extracted to scripts/shared/pagination-controller.js

// Modern Vulnerability Management System
class ModernVulnManager {
    constructor() {
        this.currentView = "table";
        this.gridApi = null;
        // Statistics manager handles metric type
        this.apiBase = "/api"; // Base URL for API endpoints
        
        // Initialize data manager
        this.dataManager = new VulnerabilityDataManager("/api");
        
        // Initialize statistics manager
        this.statisticsManager = new VulnerabilityStatisticsManager(this.dataManager);
        
        // Initialize chart manager
        this.chartManager = new VulnerabilityChartManager("historicalChart", this.statisticsManager, this.dataManager);
        
        // Initialize pagination controllers
        this.devicePagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        this.vulnerabilityPagination = new PaginationController(6, [6, 12, 24, 48, 64, 96]);
        
        // Initialize WebSocket client and progress modal
        this.websocketClient = null;
        this.progressModal = null;
        this.initializeWebSocketAndProgressModal();
        
        // Setup data manager event listeners
        this.setupDataManagerListeners();
        
        this.setupEventListeners();
        this.initializeGrid();
        this.chartManager.initialize();
        this.loadData();
    }

    /**
     * Initialize WebSocket client and progress modal for real-time progress tracking
     */
    async initializeWebSocketAndProgressModal() {
        try {
            // Initialize WebSocket client if available
            if (typeof WebSocketClient !== "undefined") {
                this.websocketClient = new WebSocketClient();
                await this.websocketClient.connect();
                console.log("WebSocket client connected for progress tracking");
            } else {
                console.warn("WebSocket client not available - progress modal will work in manual mode");
            }
            
            // Initialize progress modal if available
            if (typeof ProgressModal !== "undefined") {
                this.progressModal = new ProgressModal(this.websocketClient);
                console.log("Progress modal initialized");
            } else {
                console.warn("Progress modal not available - falling back to traditional loading indicators");
            }
        } catch (error) {
            console.error("Error initializing WebSocket/Progress modal:", error);
            // Continue without WebSocket - modal will work in manual mode
        }
    }

    setupDataManagerListeners() {
        // Listen to data manager events
        this.dataManager.on("dataLoaded", (_data) => {
            this.updateChart();
            this.updateCurrentView();
        });

        this.dataManager.on("dataFiltered", (data) => {
            if (this.gridApi) {
                this.gridApi.setGridOption("rowData", data.filteredVulnerabilities);
            }
            this.updateCurrentView();
        });

        this.dataManager.on("statisticsLoaded", (_data) => {
            this.updateStatisticsDisplay();
        });

        this.dataManager.on("error", (data) => {
            this.showToast(data.message, "danger");
        });
    }

    setupEventListeners() {
        // Import CSV - Show date picker modal
        document.getElementById("importCsvBtn").addEventListener("click", () => {
            document.getElementById("csvFileInput").click();
        });

        document.getElementById("csvFileInput").addEventListener("change", (e) => {
            this.showScanDateModal(e);
        });

        // Confirm scan date and proceed with import
        document.getElementById("confirmScanDate").addEventListener("click", () => {
            this.proceedWithImport();
        });

        // Search and filters
        document.getElementById("searchInput").addEventListener("input", (_e) => {
            this.dataManager.filterData();
        });

        document.getElementById("severityFilter").addEventListener("change", (_e) => {
            this.dataManager.filterData();
        });

        // View switcher for Tabler.io button group
        document.querySelectorAll("[data-view]").forEach(btn => {
            btn.addEventListener("click", (e) => {
                const view = e.target.dataset.view || e.target.closest("[data-view]").dataset.view;
                if (view) {
                    this.switchView(view);
                }
            });
        });

        // Export button
        document.getElementById("exportBtn").addEventListener("click", () => {
            this.exportData();
        });

        // Refresh button - Check if exists before adding listener
        const refreshBtn = document.getElementById("refreshBtn");
        if (refreshBtn) {
            refreshBtn.addEventListener("click", () => {
                this.dataManager.refreshData();
            });
        }

        // Save vulnerability edit
        const saveVulnEdit = document.getElementById("saveVulnEdit");
        if (saveVulnEdit) {
            saveVulnEdit.addEventListener("click", () => {
                this.saveVulnerabilityChanges();
            });
        }

        // Device modal functionality is now handled by device-security-modal.js module
    }

    initializeGrid() {
        const gridOptions = createVulnerabilityGridOptions(this);
        const gridDiv = document.getElementById("vulnGrid");
        
        if (this.gridApi) {
            this.gridApi.destroy();
        }

        this.gridApi = agGrid.createGrid(gridDiv, gridOptions);
    }

    showScanDateModal(event) {
        this.pendingFile = event.target.files[0];
        if (!this.pendingFile) {return;}

        const today = new Date().toISOString().split("T")[0];
        document.getElementById("scanDateInput").value = today;

        const modal = new bootstrap.Modal(document.getElementById("scanDateModal"));
        modal.show();
    }

    async proceedWithImport() {
        const scanDate = document.getElementById("scanDateInput").value;
        if (!scanDate) {
            this.showToast("Please select a scan date", "danger");
            return;
        }

        const modal = bootstrap.Modal.getInstance(document.getElementById("scanDateModal"));
        modal.hide();

        await this.handleCsvImportWithDate(this.pendingFile, scanDate);
        
        this.pendingFile = null;
        document.getElementById("csvFileInput").value = "";
    }

    async handleCsvImportWithDate(file, scanDate) {
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                return;
            }
        }

        // Use progress modal if available, otherwise fall back to loading indicators
        const useProgressModal = this.progressModal && this.websocketClient?.isSocketConnected();
        let sessionId = null;

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");
            formData.append("scanDate", scanDate);

            if (useProgressModal) {
                // Show progress modal for real-time updates
                sessionId = `import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                formData.append("sessionId", sessionId);
                
                this.progressModal.show({
                    title: "Importing CSV Data",
                    sessionId: sessionId,
                    allowCancel: true,
                    onCancel: () => this.cancelCsvImport(sessionId),
                    initialMessage: `Uploading ${file.name}...`
                });
            } else {
                // Fall back to traditional loading indicator
                this.showLoading("Uploading CSV file...");
            }

            const response = await fetch(`${this.apiBase}/vulnerabilities/import-staging`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            const result = await response.json();

            if (!useProgressModal) {
                // Manual progress updates for fallback mode
                this.showLoading("Processing data...");
                await new Promise(resolve => setTimeout(resolve, 500));
                
                this.showLoading("Refreshing charts and data...");
                await this.loadData();
                
                this.hideLoading();
                
                let message = `CSV import completed! Processed ${result.rowsProcessed.toLocaleString()} rows from ${result.filename} with scan date ${scanDate}.`;
                if (result.insertCount || result.updateCount || result.removedStale) {
                    message += ` Added: ${result.insertCount || 0}, Updated: ${result.updateCount || 0}, Removed: ${result.removedStale || 0} stale items.`;
                }
                
                this.showToast(message, "success");
            } else {
                // Progress modal will handle completion via WebSocket events
                // Just refresh data when process completes
                setTimeout(async () => {
                    await this.loadData();
                }, 1000);
            }

        } catch (error) {
            console.error("Error importing CSV:", error);
            
            if (useProgressModal && this.progressModal) {
                this.progressModal.showError(`Import failed: ${error.message}`);
            } else {
                this.hideLoading();
                this.showToast("Error importing CSV: " + error.message, "danger");
            }
        }
    }

    /**
     * Cancel CSV import operation
     * @param {string} sessionId - Session ID to cancel
     */
    async cancelCsvImport(sessionId) {
        try {
            await fetch(`${this.apiBase}/vulnerabilities/import-cancel`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ sessionId })
            });
            
            this.showToast("CSV import cancelled", "warning");
        } catch (error) {
            console.error("Error cancelling import:", error);
            this.showToast("Failed to cancel import: " + error.message, "danger");
        }
    }

    async handleCsvImport(event) {
        const file = event.target.files[0];
        if (!file) {return;}

        if (file.size > 10 * 1024 * 1024) {
            if (!confirm(`This file is ${Math.round(file.size / (1024 * 1024))}MB. Large files will be processed server-side for better performance. Continue?`)) {
                event.target.value = "";
                return;
            }
        }

        this.showLoading("Uploading CSV file...");

        try {
            const formData = new FormData();
            formData.append("csvFile", file);
            formData.append("vendor", "cisco");

            const response = await fetch(`${this.apiBase}/vulnerabilities/import-staging`, {
                method: "POST",
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || "Import failed");
            }

            this.showLoading("Processing data...");
            const result = await response.json();

            this.showLoading("Updating display...");
            await this.loadData();

            this.hideLoading();
            this.showToast(`CSV import completed! Imported ${result.rowsProcessed.toLocaleString()} vulnerabilities from ${result.filename}.`, "success");

            event.target.value = "";
        } catch (error) {
            this.hideLoading();
            console.error("Error importing CSV:", error);
            this.showToast("Error importing CSV: " + error.message, "danger");
            event.target.value = "";
        }
    }

    calculateSeverity(vprScore) {
        if (vprScore >= 9.0) {return "Critical";}
        if (vprScore >= 7.0) {return "High";}
        if (vprScore >= 4.0) {return "Medium";}
        return "Low";
    }

    async loadData() {
        await this.dataManager.loadData();
    }

    updateStatisticsDisplay() {
        this.statisticsManager.updateStatisticsDisplay();
    }

    updateTrendIndicators(_currentStats) {
        this.statisticsManager.updateTrendIndicators(_currentStats);
    }

    calculateTrend(previous, current) {
        return this.statisticsManager.calculateTrend(previous, current);
    }

    /**
     * Updates pagination information display with actual row counts
     * Called by AG Grid when pagination changes
     */
    updatePaginationInfo(totalRows, currentPage, pageSize) {
        // This method is called by the AG Grid pagination handler
        // to update any custom pagination displays with actual counts
        console.log(`Pagination updated: ${totalRows} total rows, page ${currentPage + 1}, ${pageSize} per page`);
        
        // The AG Grid handles the pagination display automatically
        // This method is here for future custom pagination implementations
    }

    flipStatCards() {
        const cards = document.querySelectorAll(".stat-card-enhanced");
        
        cards.forEach(card => {
            const cardFront = card.querySelector(".card-front");
            const cardBack = card.querySelector(".card-back");
            
            if (cardFront && cardBack) {
                if (cardFront.style.display !== "none") {
                    cardFront.style.display = "none";
                    cardBack.style.display = "block";
                    this.statisticsManager.setCurrentMetricType("vpr");
                } else {
                    cardFront.style.display = "block";
                    cardBack.style.display = "none";
                    this.statisticsManager.setCurrentMetricType("count");
                }
            }
        });
        
        this.updateStatisticsDisplay();
    }

    extendTimelineData(originalData) {
        return this.dataManager.extendTimelineData(originalData);
    }

    updateChart() {
        if (!this.chartManager) {
            return;
        }
        // Delegate chart updates to the chart manager
        this.chartManager.update();
    }



    switchView(viewType) {
        const radioButton = document.getElementById(`view-${viewType}`);
        if (radioButton) {
            radioButton.checked = true;
        }

        document.querySelectorAll(".view-content").forEach(view => {
            view.classList.add("d-none");
        });

        document.getElementById(`${viewType}View`).classList.remove("d-none");
        
        this.currentView = viewType;
        this.updateCurrentView();
    }

    updateCurrentView() {
        switch (this.currentView) {
            case "table":
                if (this.gridApi) {
                    this.gridApi.setRowData(this.dataManager.getFilteredVulnerabilities());
                }
                break;
            case "devices":
                this.renderDeviceCards();
                break;
            case "vulnerabilities":
                this.renderVulnerabilityCards();
                break;
        }
    }

    renderDeviceCards() {
        const container = document.getElementById("deviceCards");
        const filteredDevices = this.dataManager.getDevices().filter(device => {
            const searchTerm = document.getElementById("searchInput").value.toLowerCase();
            return !searchTerm || device.hostname.toLowerCase().includes(searchTerm);
        });

        // Sort devices by total VPR score (high to low)
        filteredDevices.sort((a, b) => {
            const aTotalVPR = (a.criticalVPR || 0) + (a.highVPR || 0) + (a.mediumVPR || 0) + (a.lowVPR || 0);
            const bTotalVPR = (b.criticalVPR || 0) + (b.highVPR || 0) + (b.mediumVPR || 0) + (b.lowVPR || 0);
            return bTotalVPR - aTotalVPR;
        });

        // Update pagination with filtered count
        this.devicePagination.setTotalItems(filteredDevices.length);
        
        // Get current page data
        const paginatedDevices = this.devicePagination.getCurrentPageData(filteredDevices);

        container.innerHTML = paginatedDevices.map(device => {
            const criticalVPR = device.criticalVPR || 0;
            const highVPR = device.highVPR || 0;
            const mediumVPR = device.mediumVPR || 0;
            const lowVPR = device.lowVPR || 0;
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card device-card">
                    <div class="card-body">
                        <div class="device-hostname">
                            <i class="fas fa-server me-2 text-primary"></i>
                            ${device.hostname}
                        </div>
                        
                        <div class="device-stats">
                            <div>
                                <div class="text-muted small">Total Vulnerabilities</div>
                                <div class="fw-bold">${device.totalCount}</div>
                            </div>
                            <div class="text-end">
                                <div class="text-muted small">Total VPR</div>
                                <div class="device-total-vpr">${totalVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${device.criticalCount}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${device.highCount}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${device.mediumCount}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${device.lowCount}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        <div class="card-actions">
                            <button class="btn btn-primary" 
                                    onclick="vulnManager.viewDeviceDetails('${device.hostname}')">
                                <i class="fas fa-eye me-1"></i>View Device Details
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;}).join("");

        // Render pagination controls
        this.devicePagination.renderPaginationControls(
            "devicePaginationControls",
            () => this.renderDeviceCards(),
            () => this.renderDeviceCards()
        );

        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }

    renderVulnerabilityCards() {
        const container = document.getElementById("vulnerabilityCards");
        const groupedVulns = this.dataManager.groupVulnerabilitiesByCVE();
        
        // Sort vulnerability groups by total VPR score (high to low)
        const sortedVulnEntries = Object.entries(groupedVulns).sort(([,vulnsA], [,vulnsB]) => {
            const totalVPRA = vulnsA.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPRB = vulnsB.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            return totalVPRB - totalVPRA;
        });

        // Update pagination with total count
        this.vulnerabilityPagination.setTotalItems(sortedVulnEntries.length);
        
        // Get current page data
        const paginatedVulnEntries = this.vulnerabilityPagination.getCurrentPageData(sortedVulnEntries);

        container.innerHTML = paginatedVulnEntries.map(([cve, vulns]) => {
            const criticalVulns = vulns.filter(v => v.severity === "Critical");
            const highVulns = vulns.filter(v => v.severity === "High");
            const mediumVulns = vulns.filter(v => v.severity === "Medium");
            const lowVulns = vulns.filter(v => v.severity === "Low");
            
            const criticalVPR = criticalVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const highVPR = highVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const mediumVPR = mediumVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const lowVPR = lowVulns.reduce((sum, v) => sum + (v.vpr_score || 0), 0);
            const totalVPR = criticalVPR + highVPR + mediumVPR + lowVPR;

            const primaryVuln = vulns[0];
            const description = primaryVuln.description || primaryVuln.plugin_name || "No description available";
            
            // Create a safe data attribute for the vulnerability data
            const vulnDataId = `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            // Store the vulnerability data temporarily for modal access
            window.vulnModalData = window.vulnModalData || {};
            window.vulnModalData[vulnDataId] = primaryVuln;

            return `
            <div class="col-lg-4 col-md-6 mb-3 fade-in">
                <div class="card vulnerability-card" style="cursor: pointer;" data-vuln-id="${vulnDataId}" onclick="vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                    <div class="card-body">
                        <div class="vulnerability-title">
                            ${description.substring(0, 100)}${description.length > 100 ? "..." : ""}
                        </div>
                        
                        <div class="vulnerability-meta">
                            <div>
                                ${(() => {
                                    if (cve && cve.startsWith("CVE-")) {
                                        return `<a href="#" class="vulnerability-cve" 
                                                   onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${cve}');">
                                                    ${cve}
                                                </a>`;
                                    }
                                    
                                    // Check for Cisco SA ID in plugin name
                                    if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
                                        const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
                                        if (ciscoSaMatch) {
                                            const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                                            return `<a href="#" class="vulnerability-cve text-warning" 
                                                       onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${ciscoId}');">
                                                        ${ciscoId}
                                                    </a>`;
                                        }
                                    }
                                    
                                    return `<span class="text-muted">Plugin ${primaryVuln.plugin_id}</span>`;
                                })()}
                            </div>
                            <div class="text-end">
                                <div class="vulnerability-vpr text-primary">
                                    ${totalVPR.toFixed(1)}
                                </div>
                                <div class="text-muted small">Total VPR</div>
                            </div>
                        </div>

                        <div class="mb-3">
                            <span class="badge severity-${primaryVuln.severity.toLowerCase()}">
                                ${primaryVuln.severity}
                            </span>
                            <span class="text-muted ms-2">
                                <i class="fas fa-server me-1"></i>
                                ${vulns.length} device${vulns.length !== 1 ? "s" : ""}
                            </span>
                        </div>

                        <div class="vpr-mini-cards">
                            <div class="vpr-mini-card critical">
                                <div class="vpr-count text-red">${criticalVulns.length}</div>
                                <div class="vpr-label">Critical</div>
                                <div class="vpr-sum">${criticalVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card high">
                                <div class="vpr-count text-orange">${highVulns.length}</div>
                                <div class="vpr-label">High</div>
                                <div class="vpr-sum">${highVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card medium">
                                <div class="vpr-count text-yellow">${mediumVulns.length}</div>
                                <div class="vpr-label">Medium</div>
                                <div class="vpr-sum">${mediumVPR.toFixed(1)}</div>
                            </div>
                            <div class="vpr-mini-card low">
                                <div class="vpr-count text-green">${lowVulns.length}</div>
                                <div class="vpr-label">Low</div>
                                <div class="vpr-sum">${lowVPR.toFixed(1)}</div>
                            </div>
                        </div>

                        ${(() => {
                            // Check if we have CVE
                            if (cve && cve.startsWith("CVE-")) {
                                return `<div class="card-actions">
                                            <button class="btn btn-primary" 
                                                    onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${cve}')">
                                                <i class="fas fa-eye me-1"></i>Lookup Vulnerability Details
                                            </button>
                                        </div>`;
                            }
                            
                            // Check for Cisco SA ID in plugin name
                            if (primaryVuln.plugin_name && typeof primaryVuln.plugin_name === "string") {
                                const ciscoSaMatch = primaryVuln.plugin_name.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
                                if (ciscoSaMatch) {
                                    const ciscoId = `cisco-sa-${ciscoSaMatch[1]}`;
                                    return `<div class="card-actions">
                                                <button class="btn btn-primary" 
                                                        onclick="event.stopPropagation(); vulnManager.lookupVulnerability('${ciscoId}')">
                                                    <i class="fas fa-eye me-1"></i>Lookup Cisco Advisory
                                                </button>
                                            </div>`;
                                }
                            }
                            
                            // Default action for no external reference
                            return `<div class="card-actions">
                                        <button class="btn btn-primary" onclick="event.stopPropagation(); vulnManager.viewVulnerabilityDetails('${vulnDataId}')">
                                            <i class="fas fa-eye me-1"></i>View Vulnerability Details
                                        </button>
                                    </div>`;
                        })()}
                    </div>
                </div>
            </div>
        `;}).join("");

        // Render pagination controls
        this.vulnerabilityPagination.renderPaginationControls(
            "vulnerabilityPaginationControls",
            () => this.renderVulnerabilityCards(),
            () => this.renderVulnerabilityCards()
        );

        if (window.Sortable) {
            new Sortable(container, {
                animation: 150,
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag"
            });
        }
    }


    viewDeviceDetails(hostname) {
        // Delegate to the device security modal module
        if (window.deviceSecurityModal) {
            window.deviceSecurityModal.showDeviceDetails(hostname, this.dataManager);
        } else {
            console.error("Device security modal module not loaded");
            this.showToast("Device security modal module not available", "error");
        }
    }

    viewVulnerabilityDetails(vulnerabilityId) {
        // Delegate to the enhanced vulnerability details modal module
        if (window.vulnDetailsModal) {
            window.vulnDetailsModal.showVulnerabilityDetails(vulnerabilityId, this.dataManager);
        } else {
            console.error("Vulnerability details modal module not loaded");
            this.showToast("Vulnerability details modal module not available", "error");
            
            // Fallback to legacy modal
            this.viewVulnerabilityDetailsLegacy(vulnerabilityId);
        }
    }

    // Legacy vulnerability details method for backward compatibility
    viewVulnerabilityDetailsLegacy(vulnerabilityId) {
        // Handle both old direct object calls and new ID-based calls
        let vulnerability;
        if (typeof vulnerabilityId === "string") {
            // New approach: get vulnerability from temporary storage
            vulnerability = window.vulnModalData && window.vulnModalData[vulnerabilityId];
        } else {
            // Legacy approach: direct object passed
            vulnerability = vulnerabilityId;
        }
        
        if (!vulnerability) {
            console.error("Vulnerability data not found");
            return;
        }

        const vulnLink = this.getVulnerabilityLink(vulnerability);
        
        document.getElementById("vulnerabilityInfo").innerHTML = `
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Vulnerability ID:</div>
                    <div class="col-sm-8">
                        ${vulnLink.url ? 
                            `<a href="#" class="text-primary text-decoration-none fw-bold" 
                               onclick="vulnManager.lookupVulnerability('${vulnLink.id}')">${vulnLink.id}</a>` :
                            `<span class="fw-bold text-muted">${vulnLink.id}</span>`
                        }
                        ${vulnLink.type === "cisco" ? 
                            "<small class=\"text-warning ms-2\">(Cisco Advisory)</small>" : 
                            vulnLink.type === "plugin" ? 
                            "<small class=\"text-muted ms-2\">(Plugin ID)</small>" : ""
                        }
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Plugin Name:</div>
                    <div class="col-sm-8 fw-bold">${vulnerability.plugin_name || "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Description:</div>
                    <div class="col-sm-8">${vulnerability.description || vulnerability.plugin_name || "No description available"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Solution:</div>
                    <div class="col-sm-8">${vulnerability.solution || "No solution provided"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">First Seen:</div>
                    <div class="col-sm-8">${vulnerability.first_seen ? new Date(vulnerability.first_seen).toLocaleDateString() : "N/A"}</div>
                </div>
            </div>
            <div class="mb-3">
                <div class="row">
                    <div class="col-sm-4 text-muted">Port:</div>
                    <div class="col-sm-8">
                        <span class="badge bg-secondary">${vulnerability.port || "N/A"}</span>
                    </div>
                </div>
            </div>
        `;

        const vprScore = vulnerability.vpr_score || 0;
        const severity = vulnerability.severity || "Low";
        const severityColor = severity === "Critical" ? "red" : 
                            severity === "High" ? "orange" : 
                            severity === "Medium" ? "yellow" : "green";
        
        document.getElementById("vulnerabilityRiskSummary").innerHTML = `
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-${vprScore >= 9 ? "red" : vprScore >= 7 ? "orange" : vprScore >= 4 ? "yellow" : "green"} h2 mb-1">${vprScore.toFixed(1)}</div>
                        <div class="text-muted small">VPR Score</div>
                        <div class="text-muted small mt-1">
                            ${vprScore >= 9 ? "Critical Risk" : vprScore >= 7 ? "High Risk" : vprScore >= 4 ? "Medium Risk" : "Low Risk"}
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6">
                <div class="card card-sm">
                    <div class="card-body text-center">
                        <div class="text-${severityColor} h3 mb-1">${severity}</div>
                        <div class="text-muted small">Severity</div>
                        <div class="text-muted small mt-1">CVSS Based</div>
                    </div>
                </div>
            </div>
        `;

        const affectedAssets = this.dataManager.getAllVulnerabilities().filter(v => v.cve === vulnerability.cve);
        document.getElementById("affectedAssetsCount").textContent = `${affectedAssets.length} assets`;

        const assetsGridDiv = document.getElementById("vulnerabilityAssetsGrid");
        assetsGridDiv.innerHTML = "";

        const assetsColumnDefs = [
            {
                headerName: "Hostname",
                field: "hostname",
                width: 200,
                cellRenderer: (params) => {
                    const hostname = params.value;
                    return `<a href="#" class="text-primary text-decoration-none fw-bold" onclick="vulnManager.viewDeviceDetails('${hostname}')">${hostname}</a>`;
                }
            },
            {
                headerName: "Port",
                field: "port",
                width: 100,
                cellRenderer: (params) => {
                    return `<span class="badge bg-secondary">${params.value || "N/A"}</span>`;
                }
            },
            {
                headerName: "First Seen",
                field: "first_seen",
                width: 150,
                cellRenderer: (params) => {
                    return params.value ? new Date(params.value).toLocaleDateString() : "N/A";
                }
            },
            {
                headerName: "Last Seen",
                field: "last_seen",
                width: 150,
                cellRenderer: (params) => {
                    const lastSeen = params.data.last_seen;
                    const scanDate = params.data.scan_date;
                    
                    if (lastSeen && lastSeen.trim() !== "") {
                        return new Date(lastSeen).toLocaleDateString();
                    } else if (scanDate && scanDate.trim() !== "") {
                        return new Date(scanDate).toLocaleDateString();
                    }
                    return "N/A";
                }
            },
            { headerName: "Plugin Output", field: "plugin_output", flex: 1 }
        ];

        const assetsGridOptions = {
            columnDefs: assetsColumnDefs,
            rowData: affectedAssets,
            defaultColDef: {
                resizable: true,
                sortable: true,
                filter: true
            },
            pagination: true,
            paginationPageSize: 15,
            animateRows: true
        };

        new agGrid.Grid(assetsGridDiv, assetsGridOptions);

        const modal = new bootstrap.Modal(document.getElementById("vulnerabilityModal"));
        modal.show();
    }

    // Extract Cisco vulnerability ID from plugin name
    extractCiscoVulnId(pluginName) {
        if (!pluginName || typeof pluginName !== "string") {
            return null;
        }
        
        // Look for cisco-sa- pattern in plugin name
        const ciscoSaMatch = pluginName.match(/cisco-sa-([a-zA-Z0-9-]+)/i);
        if (ciscoSaMatch) {
            return `cisco-sa-${ciscoSaMatch[1]}`;
        }
        
        return null;
    }

    // Determine vulnerability ID type and create appropriate link
    getVulnerabilityLink(vulnData) {
        const { cve, plugin_name } = vulnData;
        
        // Check for CVE first
        if (cve && cve.startsWith("CVE-")) {
            return {
                id: cve,
                type: "cve",
                url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cve.trim()}`
            };
        }
        
        // Check for Cisco SA ID in plugin name
        const ciscoId = this.extractCiscoVulnId(plugin_name);
        if (ciscoId) {
            return {
                id: ciscoId,
                type: "cisco",
                url: `https://www.cisco.com/c/en/us/support/docs/csa/${ciscoId}.html`
            };
        }
        
        // Fall back to plugin ID
        return {
            id: `Plugin ${vulnData.plugin_id}`,
            type: "plugin",
            url: null
        };
    }

    // Enhanced lookup method that handles different vulnerability ID types
    async lookupVulnerability(vulnId, pluginName = null) {
        // If CVE, use existing CVE lookup
        if (vulnId && vulnId.startsWith("CVE-")) {
            return this.lookupCVE(vulnId);
        }
        
        // If it looks like a Cisco SA ID, open Cisco advisory
        if (vulnId && vulnId.startsWith("cisco-sa-")) {
            const popup = window.open(
                `https://www.cisco.com/c/en/us/support/docs/csa/${vulnId}.html`,
                `Cisco_Advisory_${vulnId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes"
            );
            
            if (popup) {
                popup.focus();
                this.showToast(`Opened Cisco advisory for ${vulnId}`, "success");
            } else {
                this.showToast("Popup blocked - please allow popups for vulnerability lookups", "warning");
            }
            return;
        }
        
        // If we have plugin name, try to extract Cisco ID from it
        if (pluginName) {
            const ciscoId = this.extractCiscoVulnId(pluginName);
            if (ciscoId) {
                return this.lookupVulnerability(ciscoId);
            }
        }
        
        // Default fallback
        this.showToast("No external vulnerability reference available for this item", "info");
    }

    async lookupCVE(cveId) {
        const cveIds = cveId.includes(",") ? cveId.split(",").map(id => id.trim()) 
                                           : cveId.includes(" ") ? cveId.split(" ").filter(id => id.startsWith("CVE-"))
                                           : [cveId.trim()];

        const ciscoClientId = localStorage.getItem("cisco_client_id");
        const ciscoClientSecret = localStorage.getItem("cisco_client_secret");

        if (ciscoClientId && ciscoClientSecret && cveIds.length === 1) {
            await this.lookupCVEWithCiscoAPI(cveIds[0], ciscoClientId, ciscoClientSecret);
        } else {
            this.openCVEPopups(cveIds);
        }
    }

    async lookupCVEWithCiscoAPI(cveId, clientId, clientSecret) {
        try {
            this.showLoading(`Looking up ${cveId} via Cisco PSIRT...`);
            
            const tokenResponse = await fetch("https://id.cisco.com/oauth2/default/v1/token", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "Authorization": "Basic " + btoa(`${clientId}:${clientSecret}`)
                },
                body: "grant_type=client_credentials"
            });

            if (tokenResponse.ok) {
                const tokenData = await tokenResponse.json();
                
                const psirtResponse = await fetch(`https://api.cisco.com/security/advisories/cve/${cveId}`, {
                    headers: {
                        "Authorization": `Bearer ${tokenData.access_token}`,
                        "Accept": "application/json"
                    }
                });

                this.hideLoading();

                if (psirtResponse.ok) {
                    const data = await psirtResponse.json();
                    this.displayCVEInfo(cveId, data);
                } else {
                    this.showToast(`No Cisco advisory found for ${cveId}. Opening external lookup...`, "warning");
                    this.openCVEPopups([cveId]);
                }
            } else {
                this.hideLoading();
                this.showToast("Failed to authenticate with Cisco API. Using external lookup...", "warning");
                this.openCVEPopups([cveId]);
            }
        } catch (_error) {
            this.hideLoading();
            this.showToast("Error with Cisco API. Using external lookup...", "warning");
            this.openCVEPopups([cveId]);
        }
    }

    openCVEPopups(cveIds) {
        if (!Array.isArray(cveIds) || cveIds.length === 0) {
            this.showToast("No valid CVE IDs found", "warning");
            return;
        }

        let successCount = 0;
        let blockedCount = 0;

        cveIds.forEach((cveId, index) => {
            if (!cveId.startsWith("CVE-")) {
                return;
            }

            setTimeout(() => {
                const popup = window.open(
                    `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId.trim()}`,
                    `CVE_Lookup_${cveId.replace(/[^a-zA-Z0-9]/g, "_")}`,
                    "width=1200,height=800,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=yes,status=yes,top=50,left=" + (100 + index * 50)
                );
                
                if (popup) {
                    popup.focus();
                    successCount++;
                } else {
                    blockedCount++;
                }

                if (index === cveIds.length - 1) {
                    setTimeout(() => {
                        if (blockedCount > 0) {
                            this.showToast(`${successCount} CVE lookup(s) opened. ${blockedCount} popup(s) blocked. Please allow popups for full CVE lookups.`, "warning");
                        } else if (successCount > 0) {
                            this.showToast(`${successCount} CVE lookup(s) opened successfully`, "success");
                        }
                    }, 100);
                }
            }, index * 200);
        });
    }

    displayCVEInfo(cveId, data) {
        let message = `CVE Information for ${cveId}:\n\n`;
        if (data.advisories && data.advisories.length > 0) {
            const advisory = data.advisories[0];
            message += `Title: ${advisory.advisoryTitle}\n`;
            message += `Severity: ${advisory.sir}\n`;
            message += `CVSSv3 Score: ${advisory.cvssBaseScore}\n`;
            message += `Publication Date: ${advisory.publicationUrl}\n`;
        }
        alert(message);
    }

    exportData() {
        const dataToExport = this.dataManager.getFilteredVulnerabilities();
        const csv = Papa.unparse(dataToExport);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerabilities_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Data exported successfully!", "success");
    }

    async refreshData() {
        this.showLoading("Refreshing data...");
        await new Promise(resolve => setTimeout(resolve, 1000));
        await this.loadData();
        this.hideLoading();
        this.showToast("Data refreshed successfully!", "success");
    }

    async fetchTenableHistoricalData() {
        const tenableApiKey = localStorage.getItem("tenable_api_key");
        const tenableSecretKey = localStorage.getItem("tenable_secret_key");
        
        this.showLoading("Fetching historical VPR data from Tenable...");
        
        const data = await this.dataManager.fetchTenableHistoricalData(tenableApiKey, tenableSecretKey);
        
        this.hideLoading();
        
        if (data) {
            this.showToast(`Fetched ${data.count} historical VPR records`, "success");
        } else {
            this.showToast("Failed to fetch Tenable data", "danger");
        }
    }

    showClearDataConfirmation() {
        if (confirm("Are you sure you want to clear all vulnerability data? This action cannot be undone.")) {
            this.clearAllData();
        }
    }

    async clearAllData() {
        this.showLoading("Clearing all data...");
        
        const success = await this.dataManager.clearAllData();
        
        this.hideLoading();
        
        if (success) {
            this.showToast("All vulnerability data cleared successfully!", "success");
        } else {
            this.showToast("Error clearing data", "danger");
        }
    }

    showLoading(message) {
        this.hideLoading();
        
        const toastHtml = `
            <div class="toast show position-fixed top-0 end-0 m-3" id="progressToast" style="z-index: 9999;">
                        <div class="toast-header bg-primary text-white">
                            <div class="spinner-border spinner-border-sm me-2" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <strong class="me-auto">Processing</strong>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
                        </div>
                        <div class="toast-body">${message}</div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML("beforeend", toastHtml);
                
                setTimeout(() => this.hideLoading(), 10000);
    }

    hideLoading() {
        const toast = document.getElementById("progressToast");
        if (toast) {
            toast.remove();
        }
        
        document.querySelectorAll(".modal-backdrop").forEach(el => el.remove());
        document.body.classList.remove("modal-open");
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
    }

    showToast(message, type) {
        const toastContainer = document.getElementById("toastContainer") || this.createToastContainer();
        const toastId = "toast_" + Date.now();
        
        const toastHtml = `
            <div class="toast align-items-center text-bg-${type} border-0" role="alert" id="${toastId}">
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;
        
        toastContainer.insertAdjacentHTML("beforeend", toastHtml);
        
        const toastElement = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastElement);
        toast.show();
        
        toastElement.addEventListener("hidden.bs.toast", () => {
            toastElement.remove();
        });
    }

    createToastContainer() {
        const container = document.createElement("div");
        container.id = "toastContainer";
        container.className = "toast-container position-fixed bottom-0 end-0 p-3";
        container.style.zIndex = "9999";
        document.body.appendChild(container);
        return container;
    }

    editVulnerability(id) {
        const allVulns = this.dataManager.getAllVulnerabilities();
        const filteredVulns = this.dataManager.getFilteredVulnerabilities();
        const vuln = allVulns[id] || filteredVulns[id];
        if (!vuln) {
            this.showToast("Vulnerability not found", "danger");
            return;
        }

        document.getElementById("editVulnId").value = id;
        document.getElementById("editHostname").value = vuln.hostname || "";
        document.getElementById("editIpAddress").value = vuln.ip_address || "";
        document.getElementById("editSeverity").value = vuln.severity || "";
        document.getElementById("editState").value = vuln.state || "open";
        document.getElementById("editNotes").value = vuln.notes || "";

        const modal = new bootstrap.Modal(document.getElementById("editVulnModal"));
        modal.show();
    }

    async saveVulnerabilityChanges() {
        const id = document.getElementById("editVulnId").value;
        const formData = {
            hostname: document.getElementById("editHostname").value,
            ip_address: document.getElementById("editIpAddress").value,
            severity: document.getElementById("editSeverity").value,
            state: document.getElementById("editState").value,
            notes: document.getElementById("editNotes").value
        };

        const success = await this.dataManager.saveVulnerability(id, formData);
        if (success) {
            this.showToast("Vulnerability updated successfully!", "success");
            bootstrap.Modal.getInstance(document.getElementById("editVulnModal")).hide();
        } else {
            this.showToast("Failed to update vulnerability", "danger");
        }
    }

    async deleteVulnerability(id) {
        if (!confirm("Are you sure you want to delete this vulnerability? This action cannot be undone.")) {
            return;
        }

        const success = await this.dataManager.deleteVulnerability(id);
        if (success) {
            this.showToast("Vulnerability deleted successfully!", "success");
        } else {
            this.showToast("Failed to delete vulnerability", "danger");
        }
    }

    async refreshVulnerability(id) {
        const allVulns = this.dataManager.getAllVulnerabilities();
        const filteredVulns = this.dataManager.getFilteredVulnerabilities();
        const vuln = allVulns[id] || filteredVulns[id];
        if (!vuln) {
            this.showToast("Vulnerability not found", "danger");
            return;
        }

        this.showToast("Refreshing vulnerability data...", "info");
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        this.showToast("Vulnerability data refreshed!", "success");
    }

    exportDeviceReport(hostname) {
        const reportData = this.dataManager.exportDeviceReport(hostname);
        if (!reportData) {
            this.showToast(`Device ${hostname} not found`, "danger");
            return;
        }

        const csv = Papa.unparse(reportData.csvData);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", reportData.filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast(`Device report exported for ${hostname}`, "success");
    }

    exportVulnerabilityReport() {
        const modal = document.getElementById("vulnerabilityModal");
        if (!modal.classList.contains("show")) {return;}

        const vulnTitle = modal.querySelector(".modal-title").textContent;
        const vulnInfo = modal.querySelector("#vulnerabilityInfo").innerHTML;
        
        const reportContent = `
            ${vulnTitle}\n
                    Generated: ${new Date().toLocaleString()}\n
                    ${vulnInfo.replace(/<[^>]*>/g, "").replace(/&nbsp;/g, " ")}
                `;

        const blob = new Blob([reportContent], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `vulnerability_report_${new Date().toISOString().split("T")[0]}.txt`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        this.showToast("Vulnerability report exported", "success");
    }

    generateDevicePDF(_hostname) {
        this.showToast("PDF generation feature coming soon!", "info");
    }

    generateVulnerabilityPDF() {
        this.showToast("PDF generation feature coming soon!", "info");
    }


}

// Page-specific refresh function for Settings modal and Progress modal integration
window.refreshPageData = function(type) {
    if (type === "vulnerabilities" && window.modernVulnManager) {
        console.log("Refreshing vulnerability data after import completion");
        window.modernVulnManager.loadData();
    }
};