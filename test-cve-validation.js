#!/usr/bin/env node

/**
 * Test script for T039 - CVE validation error handling
 * Tests the enhanced validateAndSanitizeCVE function
 */

// Mock validateAndSanitizeCVE function for testing
function validateAndSanitizeCVE(cveString, context = {}) {
    const validationResult = {
        value: "",
        isValid: true,
        errors: [],
        warnings: []
    };
    
    if (!cveString) {
        return context.returnObject ? validationResult : "";
    }
    
    // Security check for SQL injection attempts
    const sqlPatterns = [
        /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER|CREATE)\b)/gi,
        /(--|\||;|\/\*|\*\/)/g,
        /(\bOR\b\s*\d+\s*=\s*\d+|\bAND\b\s*\d+\s*=\s*\d+)/gi
    ];
    
    for (const pattern of sqlPatterns) {
        if (pattern.test(cveString)) {
            console.error(`[SECURITY] SQL injection attempt blocked: ${cveString.substring(0, 100)}...`);
            validationResult.isValid = false;
            validationResult.errors.push("Invalid characters detected - potential security threat");
            return context.returnObject ? validationResult : "";
        }
    }
    
    // XSS prevention check
    const xssPatterns = [
        /<script[^>]*>.*?<\/script>/gi,
        /<iframe[^>]*>.*?<\/iframe>/gi,
        /javascript:/gi,
        /on\w+\s*=/gi,
        /<img[^>]*onerror=/gi
    ];
    
    for (const pattern of xssPatterns) {
        if (pattern.test(cveString)) {
            console.warn(`[SECURITY] XSS attempt blocked: ${cveString.substring(0, 100)}...`);
            validationResult.isValid = false;
            validationResult.errors.push("HTML/Script tags not allowed in CVE field");
            return context.returnObject ? validationResult : "";
        }
    }
    
    // Handle multiple CVEs
    const cvePattern = /CVE-\d{4}-\d{4,}/gi;
    const ciscoPattern = /cisco-sa-\d{8}-\w+/gi;
    
    const cveMatches = cveString.match(cvePattern) || [];
    const ciscoMatches = cveString.match(ciscoPattern) || [];
    
    // Check for malformed CVE patterns
    const malformedPatterns = [
        { pattern: /CVE\d{4}-\d{4,}/gi, message: "Missing hyphen after 'CVE'" },
        { pattern: /CVE-\d{1,3}-\d{4,}/gi, message: "Invalid year format (should be 4 digits)" },
        { pattern: /CVE-\d{4}-\d{1,3}(?!\d)/gi, message: "Invalid CVE number (should be at least 4 digits)" },
        { pattern: /cve-\d{4}-\d{4,}(?![\s,]|$)/gi, message: "CVE identifier should be uppercase" }
    ];
    
    for (const check of malformedPatterns) {
        const matches = cveString.match(check.pattern);
        if (matches) {
            validationResult.warnings.push(`${check.message}: ${matches.join(", ")}`);
        }
    }
    
    const allMatches = [...new Set([...cveMatches, ...ciscoMatches])];
    
    if (allMatches.length === 0) {
        if (/cve/i.test(cveString)) {
            validationResult.warnings.push("No valid CVE format found. Expected format: CVE-YYYY-NNNN (e.g., CVE-2023-1234)");
        }
        validationResult.value = "";
    } else {
        validationResult.value = allMatches.join(", ");
        
        const potentialCVECount = (cveString.match(/CVE/gi) || []).length;
        if (potentialCVECount > allMatches.length) {
            validationResult.warnings.push(`Found ${allMatches.length} valid CVE(s) out of ${potentialCVECount} potential references`);
        }
    }
    
    return context.returnObject ? validationResult : validationResult.value;
}

// Test cases for T039
const testCases = [
    // Valid cases
    { input: "CVE-2023-1234", expected: "CVE-2023-1234" },
    { input: "CVE-2023-1234, CVE-2023-5678", expected: "CVE-2023-1234, CVE-2023-5678" },
    { input: "cisco-sa-20230101-test", expected: "cisco-sa-20230101-test" },
    
    // Malformed cases that should still extract valid parts
    { input: "CVE2023-1234", expected: "" }, // Missing hyphen
    { input: "CVE-23-1234", expected: "" }, // Invalid year
    { input: "CVE-2023-123", expected: "" }, // Invalid CVE number
    { input: "cve-2023-1234", expected: "CVE-2023-1234" }, // Lowercase
    
    // Security threats
    { input: "CVE-2023-1234; DROP TABLE users;", expected: "" },
    { input: "<script>alert('xss')</script>", expected: "" },
    { input: "CVE-2023-1234 OR 1=1", expected: "" },
    
    // Empty/null cases
    { input: "", expected: "" },
    { input: null, expected: "" },
];

console.log("üß™ Testing T039 - Enhanced CVE Validation");
console.log("=" * 50);

let passed = 0;
let failed = 0;

testCases.forEach((test, index) => {
    try {
        const result = validateAndSanitizeCVE(test.input);
        const success = result === test.expected;
        
        console.log(`Test ${index + 1}: ${success ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        console.log(`  Input: "${test.input}"`);
        console.log(`  Expected: "${test.expected}"`);
        console.log(`  Got: "${result}"`);
        
        if (!success) {
            failed++;
        } else {
            passed++;
        }
        
        // Test with returnObject for warnings/errors
        const detailedResult = validateAndSanitizeCVE(test.input, { returnObject: true });
        if (detailedResult.warnings.length > 0) {
            console.log(`  Warnings: ${detailedResult.warnings.join('; ')}`);
        }
        if (detailedResult.errors.length > 0) {
            console.log(`  Errors: ${detailedResult.errors.join('; ')}`);
        }
        
        console.log("");
    } catch (error) {
        console.log(`Test ${index + 1}: ‚ùå ERROR - ${error.message}`);
        failed++;
    }
});

console.log("=" * 50);
console.log(`Results: ${passed} passed, ${failed} failed`);
console.log(failed === 0 ? "üéâ All tests passed!" : "‚ö†Ô∏è  Some tests failed!");